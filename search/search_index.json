{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"Overview of the project","text":"<p>This code was developed by Jules Colas during his PhD thesis. The PhD manuscript can be found here The different tools that were used in his PhD thesis are regrouped here.</p> <p>It contains: </p> <ul> <li>A Fortran code used to perform Parabolic equation simulation. </li> <li>A Fortran LES code used to compute the atmospheric flow around a wind farm.</li> <li>A Python code used to compute the source power emitted by each segment of a wind turbine blade considering realistic inflow condition.</li> <li>Post and Pre processing tools used to chain this different code in order to perform a full acoustic wind farm simulation.</li> </ul>"},{"location":"WAPE.html","title":"PE_2D_WAPE Documentation","text":""},{"location":"WAPE.html#overview","title":"Overview","text":"<p>The <code>PE_2D_WAPE</code> program is a Fortran implementation designed to perform 2D Parabolic Equation (PE) simulations for wave propagation in various media. The program utilizes several modules to handle different aspects of the simulation, including reading input parameters, initializing domains, performing wave propagation, and writing output data.</p>"},{"location":"WAPE.html#modules","title":"Modules","text":""},{"location":"WAPE.html#types","title":"<code>types</code>","text":"<p>This module defines various data types used throughout the program.  These types include structures for simulation parameters, domain definitions, mesh configurations, and more.</p>"},{"location":"WAPE.html#splines","title":"<code>splines</code>","text":"<p>This module provides functionalities for to spline interpolation, which are used for interpolating data on different grids.</p>"},{"location":"WAPE.html#utils","title":"<code>utils</code>","text":"<p>This module contains utility functions that assist in various computational tasks, such as mathematical operations and data manipulation.</p>"},{"location":"WAPE.html#interpo","title":"<code>interpo</code>","text":"<p>This module handles interpolation tasks, providing functions to interpolate flow or acoustic data between different mesh grids.</p>"},{"location":"WAPE.html#read_write","title":"<code>read_write</code>","text":"<p>This module is responsible for reading input data from configuration files and writing output data to files. It supports reading HDF5 files for flow field data.</p>"},{"location":"WAPE.html#wape","title":"<code>wape</code>","text":"<p>This module contains the core wave propagation algorithms.  It includes subroutines for different WAPE formulation, such as arbitrary Mach number (Ostashev et al 2020) propagation and classic wave propagation (Salomons 2001).</p>"},{"location":"WAPE.html#init","title":"<code>init</code>","text":"<p>This module handles the initialization of various parameters and domains required for the simulation.</p>"},{"location":"WAPE.html#main-program","title":"Main Program","text":""},{"location":"WAPE.html#pe_2d_wape","title":"<code>PE_2D_WAPE</code>","text":"<p>The main program <code>PE_2D_WAPE</code> follows these steps:</p> <ol> <li>Read Parameters: Reads simulation parameters from an input configuration file <code>input.nml</code>.</li> <li>Read Flow Field: If external flow is enabled, reads the flow field data from an HDF5 file.</li> <li>Initialize Domain and Mesh: Initializes the domain and mesh for each propagation angle.</li> <li>Interpolate Mean Flow: Interpolates the mean flow over the coarse grid.</li> <li>Loop Over Frequencies: For each frequency, initializes the mesh and performs wave propagation.</li> <li>Perform Wave Propagation: Executes the wave propagation algorithm for each frequency and angle.</li> <li>Interpolate and Write Output: Interpolates the results and writes the output data to files.</li> <li>Deallocate Memory: Deallocates memory used for mesh and flow data.</li> </ol>"},{"location":"WAPE.html#subroutines","title":"Subroutines","text":""},{"location":"WAPE.html#propa_1angle_1freq_arbitrary","title":"<code>propa_1angle_1freq_arbitrary</code>","text":"<p>This subroutine performs wave propagation for a single angle and frequency using an arbitrary Mach number approach. It initializes the necessary parameters, sets up the PML (Perfectly Matched Layer), and solves the wave propagation equation (arbitrary Mach Ostashev 2020).</p>"},{"location":"WAPE.html#propa_1angle_1freq","title":"<code>propa_1angle_1freq</code>","text":"<p>This subroutine performs classic wave propagation for a single angle and frequency.  It follows a similar structure to <code>propa_1angle_1freq_arbitrary</code> but uses a different set of equations for the wave propagation (classic WAPE from salomons 2001).</p>"},{"location":"WAPE.html#propa_1angle_1freq_arbitrary_new","title":"<code>propa_1angle_1freq_arbitrary_new</code>","text":"<p>This subroutine is an alternative implementation of the arbitrary Mach number wave propagation. It includes some modifications to the wave propagation equations (Arbitrary mach and phase preserving Ostashev 2023).</p>"},{"location":"WAPE.html#propa_1angle_1freq_arbitrary2","title":"<code>propa_1angle_1freq_arbitrary2</code>","text":"<p>This subroutine is another variant of the arbitrary Mach number wave propagation, with further modifications to the wave propagation equations.</p>"},{"location":"WAPE.html#usage","title":"Usage","text":"<p>To use the <code>PE_2D_WAPE</code> program, follow these steps:</p> <ol> <li>Prepare Input Files: Create the necessary input configuration files and HDF5 flow field files.</li> <li>Compile the Program: Compile the Fortran code using a Fortran compiler that supports the required modules.</li> <li>Run the Simulation: Execute the compiled program, providing the input configuration file as an argument.</li> <li>Analyze Output: Review the output data files generated by the simulation for analysis.</li> </ol>"},{"location":"WAPE.html#dependencies","title":"Dependencies","text":"<ul> <li>Fortran compiler (e.g., <code>gfortran</code>, <code>ifort</code>)</li> <li>HDF5 library for reading and writing HDF5 files</li> </ul>"},{"location":"WAPE.html#input-for-the-simulation","title":"Input for the simulation","text":""},{"location":"WAPE.html#overview_1","title":"Overview","text":"<p>The <code>PE_2D_WAPE</code> program requires a set of input parameters to configure and run the simulation.  These parameters are grouped logically into different categories such as general parameters, frequencies, angles, domain definition, numerical parameters, source parameters, external flow parameters, and output parameters.</p>"},{"location":"WAPE.html#input-parameters","title":"Input Parameters","text":""},{"location":"WAPE.html#general-parameters","title":"General Parameters","text":"<p>These parameters define the basic settings for the simulation.</p> <ul> <li> <p><code>case_name</code>: A string identifying the case name.</p> </li> <li> <p><code>var0%c</code>: Speed of sound in the medium (default: 343 m/s).</p> </li> <li> <p><code>var0%rho</code>: Density of the medium (default: 1.2 kg/m\u00b3).</p> </li> <li> <p><code>var0%gamma</code>: Ratio of specific heats (default: 1.4).</p> </li> </ul>"},{"location":"WAPE.html#frequencies","title":"Frequencies","text":"<p>These parameters define the frequencies at which the simulation will be run.</p> <ul> <li> <p><code>nb_freq</code>: Number of frequencies.</p> </li> <li> <p><code>frequencies</code>: Array of frequencies (in Hz).</p> </li> </ul>"},{"location":"WAPE.html#angles","title":"Angles","text":"<p>These parameters define the angles at which the simulation will be run.</p> <ul> <li> <p><code>nb_theta</code>: Number of angles.</p> </li> <li> <p><code>theta</code>: Array of angles (in degrees).</p> </li> </ul>"},{"location":"WAPE.html#domain-definition","title":"Domain Definition","text":"<p>These parameters define the physical dimensions of the simulation domain.</p> <ul> <li> <p><code>Lx1</code>: Length of the domain in the positive x-direction.</p> </li> <li> <p><code>Lx2</code>: Length of the domain in the negative x-direction.</p> </li> <li> <p><code>Ly1</code>: Length of the domain in the positive y-direction.</p> </li> <li> <p><code>Ly2</code>: Length of the domain in the negative y-direction.</p> </li> <li> <p><code>Lz</code>: Length of the domain in the z-direction.</p> </li> </ul>"},{"location":"WAPE.html#numerical-parameters","title":"Numerical Parameters","text":"<p>These parameters define the numerical settings for the simulation.</p> <ul> <li> <p><code>dx</code>: Grid spacing in the x-direction.</p> </li> <li> <p><code>cfl</code>: Courant-Friedrichs-Lewy number for stability.</p> </li> </ul>"},{"location":"WAPE.html#pml-perfectly-matched-layer","title":"PML (Perfectly Matched Layer)","text":"<ul> <li> <p><code>size</code>: Size of the PML.</p> </li> <li> <p><code>param</code>: PML parameter.</p> </li> <li> <p><code>n</code>: PML exponent.</p> </li> </ul>"},{"location":"WAPE.html#impedance-variable-porosity-from-attenborough-et-al-2010","title":"Impedance (Variable porosity from Attenborough et al 2010)","text":"<ul> <li> <p><code>imp%sigmae</code>: Effective flow resistivity for impedance.</p> </li> <li> <p><code>imp%alphae</code>: Effective porosity change rate for impedance.</p> </li> <li> <p><code>imp%rigid</code>: Boolean flag for rigid impedance.   <pre><code>imp%rigid=.false.\n</code></pre></p> </li> </ul>"},{"location":"WAPE.html#source-parameters","title":"Source Parameters","text":"<p>These parameters define the source location and properties.</p> <ul> <li> <p><code>src%pos_x</code>: x-coordinate of the source.</p> </li> <li> <p><code>src%pos_z</code>: z-coordinate of the source.</p> </li> </ul>"},{"location":"WAPE.html#external-flow-parameters","title":"External Flow Parameters","text":"<p>These parameters define the external flow settings.</p> <ul> <li> <p><code>external_flow</code>: Boolean flag to enable reading from Twente LES data.</p> </li> <li> <p><code>uniform</code>: Boolean flag for constant flow equal to <code>u0</code>.</p> </li> <li> <p><code>logarithmic</code>: Boolean flag for logarithmic profile with <code>z0=0.002</code>.</p> </li> <li> <p><code>u0</code>: Constant flow velocity.</p> </li> <li> <p><code>arbitrary</code>: Boolean flag to enable Ostashev WAPE (Ostashev et al 2020 JASA).</p> </li> <li> <p><code>arbitrary_new</code>: Boolean flag to enable new phase-preserving WAPE (Ostasheb et al 2024 JASA).</p> </li> <li> <p><code>fdir</code>: Path to LES data.</p> </li> </ul>"},{"location":"WAPE.html#twente-parameters","title":"Twente Parameters","text":"<p>These parameters are needed to rescale and position the flow.</p> <ul> <li> <p><code>fname</code>: Filename for Twente data.</p> </li> <li> <p><code>tinput%ratio</code>: Ratio for Twente data (used to rescale the flow by \\(u_*\\)).</p> </li> <li> <p><code>tinput%z_i</code>: length scaling for Twente data.</p> </li> <li> <p><code>tinput%delta</code>: Delta for Twente data.</p> </li> <li> <p><code>tinput%T_scale_K</code>: Temperature scale for Twente data.</p> </li> <li> <p><code>tinput%Lx</code>: Length in the x-direction for Twente data (before rescaling).</p> </li> <li> <p><code>tinput%Ly</code>: Length in the y-direction for Twente data (before rescaling).</p> </li> <li> <p><code>tinput%Lz</code>: Length in the z-direction for Twente data (before rescaling).</p> </li> <li> <p><code>tinput%posx</code>: x-coordinate position for Twente data (before rescaling).</p> </li> <li> <p><code>tinput%posy</code>: y-coordinate position for Twente data (before rescaling).</p> </li> <li> <p><code>tinput%posz</code>: z-coordinate position for Twente data (before rescaling).</p> </li> </ul>"},{"location":"WAPE.html#output-parameters","title":"Output Parameters","text":"<p>These parameters define the output settings for the simulation.</p> <ul> <li> <p><code>dout</code>: Output  space interval.</p> </li> <li> <p><code>nb_receiver</code>: Number of receivers.</p> </li> <li> <p><code>heights</code>: Array of heights for receivers.</p> </li> <li> <p><code>side</code>: Boolean flag to enable side output to be saved.</p> </li> <li> <p><code>top</code>: Boolean flag to enable top output (currently not functional).</p> </li> <li> <p><code>continuation</code>: Boolean flag to enable continuation from the last computed angles.</p> </li> <li> <p><code>nb_xplane</code>: Number of x-planes where the solution must be recorded.</p> </li> <li> <p><code>xplane</code>: Array of x-coordinates for the planes.</p> </li> <li> <p><code>nb_yplane</code>: Number of y-planes where the solution must be recorded.</p> </li> <li> <p><code>yplane</code>: Array of y-coordinates for the planes.</p> </li> </ul>"},{"location":"WAPE.html#example-input-file","title":"Example Input File","text":"<pre><code>$input\n! general parameters\n!------------------------------------------------------------------------------\ncase_name='c0'\nvar0%c=343\nvar0%rho=1.2\nvar0%gamma=1.4\n\n! Frequencies\nnb_freq=4\nfrequencies(1)=50,100,200,500\n\n! Angles\nnb_theta=1\ntheta(1)=0\n\n! Domain definition\nLx1=3500.0\nLx2=500.0\nLy1=1000.0\nLy2=1000.0\nLz=300\n\n! Numerical parameters\n!------------------------------------------------------------------------------\ndx=0.5\ncfl=0.1\n! PML\nsize=30\nparam=50000.0\nn=2.5\n! impedance\nimp%sigmae=50000.0\nimp%alphae=100.0\nimp%rigid=.false.\n\n! Source\nsrc%pos_x=0.0\nsrc%pos_z=90\n\n! External Flow\n!------------------------------------------------------------------------------\n! if .true. read from twente LES\nexternal_flow=.true.\n! if .true. constant flow equal to u0\nuniform=.false.\n\n! if .true. log profile with z0=0.002\nlogarithmic=.false.\nu0=11\n\n! Set the type of WAPE used\n! if .true. Ostashev WAPE, else classic WAPE\narbitrary=.true.\n\n! if true newa phase preserving WAPE\narbitrary_new=.false.\n\n! (i am not sure this does somethind)\ninterpolation=.true.\n\n! path to LES data\nfdir='/store/lmfa-2/acoustique-nl/simu_jules/LES/2T/C1/blue/output/'\n\n! twente paramaters needed to rescale and positionned the flow\nfname='tavg'\ntinput%ratio=1\ntinput%z_i=1000.0\ntinput%delta=0.25\ntinput%T_scale_K=293.15\ntinput%Lx=6.0\ntinput%Ly=3.44\ntinput%Lz=1.0\ntinput%posx=1.0\ntinput%posy=1.72\ntinput%posz=0.04\n\n! Set output paramaters\n!------------------------------------------------------------------------------\ndout=1\nnb_receiver=3\nheights(1)=2.0, 10, 100\nside=.true.\n\n! does not doe anything\ntop=.false.\n\n! if continuation set to true resart from the last computed angles\n! not yet a continuation with respect to frequency\ncontinuation=.false.\n\n! Set the plane in the complete domain where the solution must be recorded\nnb_xplane=1\nxplane(1)=1000\nnb_yplane=1\nyplane(1)=1000\n$end input\n</code></pre> <p>This documentation provides a comprehensive overview of the input parameters required for the <code>PE_2D_WAPE</code> program, grouped logically for better understanding and configuration.</p>"},{"location":"installation.html","title":"Installation","text":"<p>Note: This code base was specifically designed to run on the ECL cluster (PMCs2I).  Hence, the specific installation can be present in here like the name of the partition, the specific modules and their path.  The code is usually run on the cluster using SLURM so here again some specificity to this infrastructure can be found. The simulation can be run locally nonetheless, however it could be very long in the case of wind farm simulation.</p>"},{"location":"installation.html#running-fortran-code","title":"Running Fortran code","text":"<p>To run the Fortran code the only needed library is HDF5 which is used to read and write file.</p> <p>The code found in <code>src/kernel/New_PE_c</code> can then be compiled using the gfortran compiler with  <pre><code>make\n</code></pre></p> <p>Warning</p> <p>Be aware that the path to the library may have to be modified for your specific infrastructure.</p> <p>On the PMCS2I cluster you need to first run: </p> <pre><code>module purge\nmodule load  HDF5/1.10.1-intel-2018a\n</code></pre> <p>you can then compile the code in the <code>src/kernel/New_PE_c/</code> folder with </p> <pre><code>make intel\n</code></pre> <p>Example of launch files and input file can be found in <code>example/propagation</code>.</p>"},{"location":"installation.html#running-python-code","title":"Running Python code","text":"<p>The code base is design to run with Python/3.10.  The code is not tested either for lower or higher version of python and some library may have changed (typically Matplotlib or SciPy).</p> <p>On PMCS2I Python 3.10 can be loaded with  <pre><code>module purge \nmodule load Python/3.10.8-GCCcore-12.2.0\n</code></pre> Before installing the python libraries needed for the code, first create a virtual environment with: <pre><code>python3 -m venv venv\n</code></pre> Activate the venv with  <pre><code>source venv/bin/activate\n</code></pre> on Windows  <pre><code>.\\venv\\Scripts\\activate\n</code></pre> You can exit the venv with the command <pre><code>deactivate\n</code></pre></p> <p>Use the package manager pip to install the requirements  <pre><code>pip install -r requirements.txt\n</code></pre> To install the local library developed for this work use: ```bash pip install -e src/</p>"},{"location":"examples/complete_simulation.html","title":"Complete windfarm simulation","text":""},{"location":"examples/complete_simulation.html#setting-up-the-propagation-simulation","title":"Setting up the propagation simulation","text":"<p>The propagation simulation is similar to the two turbine example.</p> <p>A typical input.py file would be the following.</p> <p>Setting up the Propagation Simulation</p> <p>The propagation simulation is similar to the two turbine example.</p> <p>A typical input.py file would look like the following:</p> <pre><code>from prepost import Simu\nfrom prepost import source as src\nimport sys\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Input for the simulation\n# -----------------------------------------------------------------------------\nsimu = Simu('c0')\nxmin = 500\nxmax = 4000\nymin = 700\nymax = 2740\nzmax = 300\n\n# absolute path\nles_path = '/&lt;path&gt;/&lt;to&gt;/&lt;les&gt;/&lt;results&gt;/'\nsrc_path = '&lt;path&gt;/&lt;to&gt;/&lt;src&gt;/&lt;folder&gt;/kernel/New_PE_c/PE_2D_WAPE'\n\n# vcentral frequency band\nfc = [50, 63, 80, 100]\n# number of simulation per frequency band\nNfc = [1,  1,  1,   1]\nsimu.set_frequencies(fc, Nfc)\n# if set to true save the complete solution in the xz plane \nsimu.set_input('side', False)\n\n# define Acoustic domain inside the LES domain \n# if acoustic domain larger the LES fiels are copied outside of the domain box\nsimu.defineDomain(xmin, xmax, ymin, ymax, zmax)\n\n# define sources height to compute \n# discretize a rotor of D = 120m with 3 source height in this case\nNh = 3\ndh = 120/Nh\nheights = np.arange(90-60+dh/2, 90+60, dh)\nprint(heights)\nheights = np.rint(heights).astype(int)\nprint(heights)\n\n# set planes where solution must be saved \n# ususlly ususefull to set the planes corresponding to tau=0 and tau = 180\n# here we set the planes corresponding to tau =0,180,90,270\nsimu.set_xplanes([1000])\nsimu.set_yplanes([1720])\n\n# define computational angle \ntau = np.array([0,30,60,90,120,150,180,210,240,270,300,330])\n\n# Define the simulation in the Simu() class\n# -----------------------------------------------------------------------------\n# define the cases for the objects simu. \n# number of height, angles, turbines (as described in the LES simulations)\n# ratio allows to scale the LES fields.\nsimu.defineCases(heights, tau, flow_path=les_path,src_path=src_path,ratio=1.04)\n\n# Creates the files for the simulation\n# distribute tau allows to compute angles in parallels, not very usefull for large wind farm. \n# the is an inherent parallelization on the turbines and height computed. \n# each case has uts own launch.sh file \nsimu.distributeCases(distribute_tau=None, mem=6000,\n                     time=\"0-01:00:00\", turbine_index=None)\n# show simulation time in days\nprint(\"Simu time = %s days\"%(simu.computeSimulationTime()/60/60/24))\n\n# create launch files to run several simulation in parallel in the same job\nsimu.createLaunchFiles(mem=6000,\n                       time=\"0-01:00:00\", turbine_index=None)\n\n# Launch simulation from python\n# Usually I launch the simulation from the terminal an check that every thing is \n# running fine\n# ------------------------------------------------------------------------------\n# launch cases using the files created in simu.createLaunchFiles\nsimu.launchCases2()\n\n# -----------------------------------------------------------------------------\nsimu.save()\n</code></pre>"},{"location":"examples/complete_simulation.html#setting-up-the-source-simulation","title":"Setting up the source simulation","text":"<p>To launch source simulation that match the propagation simulation a function in class <code>Simu</code> is used to launch the different source simulation for each turbine of the wind farm. </p> <p>First the previously saved <code>Simu</code> object is loaded.  <pre><code>import numpy as np\nfrom prepost import Simu\nfrom prepost.source import WindTurbine, Mesh\n\n\niTurb = [0,1]\nprint('Making source ...')\nprint('------------------------------------------------------------------')\nsimu = Simu('c0')\nsimu.load('./c0.dat')\n</code></pre></p> <p>Then a wind turbine geometry is defined using the <code>WindTurbine</code> class</p> <pre><code>wt = WindTurbine()\nwt.default()\nwt.Nblade = 3\nwt.Nbeta = 12\nwt.Lspan = 1.2*wt.Lspan\nwt.seg = 1.2*wt.seg\nwt.href = 90\n</code></pre> <p>Note</p> <p>The span and hub height of the simulation must match the geometry defined for the LES,  and also the source height for which the PE simulation were computed.</p> <p>Then a mesh is set up for the source simulation. <pre><code>ny = 60\nnx = 90\n\nx = np.linspace(simu.x1-100, simu.x2+100, nx)\ny = np.linspace(simu.y1-100, simu.y2+100, ny)\nz = np.array([2])\n\nmesh = Mesh(polar=False)\nmesh.set_cartesian_mesh(x, y, z)\n</code></pre> Here the boundary of the mesh is taken slightly larger than the propagation boundary. </p> <p>Note</p> <p>The source mesh is very coarse here because away from the source there is not a lot of variation. A way to create a more refine mesh without increasing too much the computational cost is to use a polar mesh with increased number of point close to the source and cross wind.  Then interpolate this mesh to the same Cartesian mesh as the propagation results.</p> <p>Finally, the simulation is launched  <pre><code>print(simu.frequencies)\n\nomega = 12.1 * np.pi * 2 / 60\nomega = None\nsimu.makeSource(wt, mesh, offset=0, plot=False, iTurb=iTurb, omega=omega,\n                Ncore=8, fname='./xy/spp_polar')\n</code></pre></p> <p>For large simulation run the case using a sbatch script such as:</p> <pre><code>#!/bin/bash\n#SBATCH --job-name=source\n#SBATCH --output=out.out # output messages go here\n#SBATCH --error=err.err    # error messages go here\n#SBATCH --mail-type=ALL\n#SBATCH --partition=haswell # partition name\n#SBATCH --nodes=1\n#SBATCH --cpus-per-task=1\n#SBATCH --mem=64000\n#SBATCH --time=0-01:00:00\nmodule purge \nmodule load Python/3.10.8-GCCcore-12.2.0\nexport KMP_AFFINITY=granularity=fine,compact,1,0\nexport OMP_STACKSIZE=1g\nlimit -s unlimited\n\nsource venv/bin/activate\n\npython input_source.py\n</code></pre>"},{"location":"examples/complete_simulation.html#post-processing","title":"Post processing","text":"<p>Once both the propagation and source simulation are performed, the post processing  function can be used to compute the SPL, OASPL, AM etc ... The different post processing functions can be found in spl_process</p> <p>First a check can be performed using the <code>Simu</code> class to verify that all propagation simulation were correctly run.  <pre><code>from prepost import Source\n\nworkdir = './'\ncase = 'c0'\n\nsimu = pp.Simu(workdir + case)\nsimu.load(workdir + 'c0.dat')\n\nprint('checking delta L ...')\nprint('------------------------------------------------------------------')\nsimu.check_run_cases()\n</code></pre></p> <p>Then the different PE simulations are concatenated and saved in one <code>DeltaLField</code> object for each turbine.  <pre><code>from prepost import concatenate_all_dl\n\n# -----------------------------------------------------------------------------\nworkdir = './'\ncase = 'c0'\npath2Pe = workdir\niTurb = [0, 1]\n\n# post process from PE h5 files\n# -----------------------------------------------------------------------------\nprint('reading delta L ...')\nprint('------------------------------------------------------------------')\nconcatenate_all_dl(case, path2Pe, refine=4, iTurb=iTurb,\n                          z=2, stepx=5,\n                          dl_fname=workdir+'/xy/DL_polar')\n</code></pre></p> <p>Note</p> <p>here <code>nx</code> and <code>ny</code> are not specified hence the <code>DeltaL</code> fields are saved in polar coordinates system.</p> <p>The \\(\\Delta L\\) and \\(S_{ff}\\) are then added using the <code>conbine_dl_function</code>.  The method used is described in Colas Phd Thesis</p> <p><pre><code>from prepost import combine_dl_src\nprint('combining ...')\nprint('------------------------------------------------------------------')\ncombine_dl_src(case, path2Pe, iTurb=iTurb,\n                  dl_fname=workdir+'/xy/DL_polar',\n                  spp_fname=workdir+'/xy/spp_polar',\n                  spl_fname=workdir+'/xy/spl_s_polar_',\n                  polar=False,third=False)\n</code></pre> Details on the function can be found here. Here the source results are given in Cartesian coordinate system while the \\(\\Delta L\\) results are in polar system.  Hence, the two grids don't match, and the source results are interpolated on the \\(\\Delta L\\) results grid. The function then saves the new source field interpolated as <code>spp_polar</code> and the SPL  as <code>spl_s_polar</code>.</p> <p>From this point different post-processing can be performed in different order depending on the need of the study.  Interpolation on Cartesian grid can be done for the SPL.  Computation of different quantity such as OASPL, AM, time averaged.  Conversion from the results as function of the rotor angle to results as a function of receiver time. </p> <p>Depending on the previous post-processing and/or the quantity loaded the function will apply to these quantities.  Here after an example of a chain of post-processing is given. </p> <p>In order to sum the contribution of the different turbine the results must be computed on the same grid which is not the case yet.  To do so the SPL in polar system are interpolated on a common Cartesian grid. </p> <p><pre><code>iTurb = [0,1]\nfor ii in iTurb:\n    spl = pp.SplField()\n    spl.load(workdir + '/xy/spl_s_polar_' + str(ii) + '.dat', seg=True,\n             time=False, oaspl=False, am=False, mean=False, z=2)\n\n    # define the common cartesian grid\n    x = np.linspace(simu.x1, simu.x2, 350)\n    y = np.linspace(simu.y1, simu.y2, 220)\n    spl.interpolate_from_polar(x, y)\n    spl.save(workdir + '/xy/spl_s_cart_'+str(ii) + '.dat')\n</code></pre> Note that here we load the SPL as function of the frequency, but we could have computed the OASPL, the AM and the averaged OASPL first, then only do the interpolation for this quantity. </p> <p>To compute the OASPL first the results are converted to third octave band then the atmospheric absorption is applied along with the A weighting finally the OASPL are computed</p> <p><pre><code>fc = [50, 63, 80, 100]\nNfc = [1,  1,  1,   1]\nfor ii in iTurb:\n    spl = pp.SplField()\n    spl.load(workdir+'/xy/spl_s_cart_%s.dat' % ii, seg=True, time=False,\n             am=False, oaspl=False, mean=False)\n    spl.compute_third_octave(fc, Nfc)\n    spl.atm_absorption()\n    spl.Aweight()\n    spl.compute_oaspl()\n    spl.SPL_seg = None\n    spl.save(workdir+'/xy/oaspl_dbA_s_cart_%s.dat' % ii)\n    spl = None\n</code></pre> Here we loaded the SPL previously interpolated in Cartesian coordinate system so the OASPL is only computed for this quantity. Note also that we set <code>spl.SPL_seg</code> to <code>None</code> so that only the OASPL is saved in the file <code>oaspl_dbA_s_cart</code>.</p> <p>Warning</p> <p>for this example very few frequencies are considered hence the OASPL quantity is not valid in this context.</p> <p>The OASPL is still a function of the rotor angle.  It can be converted to a function of the receiver time, by accounting for the propagation time between each segment and the receiver. </p> <p><pre><code>print('compute time reciver ...')\nprint('------------------------------------------------------------------')\npp.convert_to_receiver_time(\n    case, path2Pe, iTurb=iTurb, spl_fname=workdir+'/xy/spl_s_cart_',\n    spl_fname_out=workdir+'/xy/spl_t_cart_', oaspl=False)\n</code></pre> Here we converted the SPL results, but we could also have applied the post-processing to the OASPL results.  <pre><code>print('compute time reciver ...')\nprint('------------------------------------------------------------------')\npp.convert_to_receiver_time(\n    case, path2Pe, iTurb=iTurb, spl_fname=workdir+'/xy/oaspl_dBA_s_cart_',\n    spl_fname_out=workdir+'/xy/oaspl_dBA_t_cart_', oaspl=True)\n</code></pre></p> <p>Finally, the contribution of multiple turbine can be added. This is done by first loading simulation results for one turbine then by adding the results of a second turbine to this field.  The field containing the contribution of multiple turbine can then be saved in a new file. <pre><code>spl0 = pp.SplField()\nspl0.load(workdir + '/xy/spl_t_cart_0.dat', seg=True,\n          time=True, am=False, mean=False, z=2)\nfor ii in iTurb[1:]:\n    spl1 = pp.SplField()\n    spl1.load(workdir + \"/xy/spl_t_cart_%s.dat\"%ii, seg=True,\n              time=True, am=False, mean=False, z=2)\n    spl0.combine_2_turbines(spl1, tmax=250)\n    spl1 = None\n\nspl0.save(workdir + '/xy/oaspl_t_cart_sum.dat')\n</code></pre></p>"},{"location":"examples/complete_simulation.html#plotting","title":"Plotting","text":"<p>Plotting can be done manually by loading the quantities saved in the class <code>SplField</code>and using matplotlib or any other plotting library. </p> <pre><code>from prepost import SplField\nimport matplotlib.pyplot as plt\n\nworkdir = './'\n\nspl = SplField()\nprint('toto')\nspl.load(workdir +'/xy/spl_s_polar_0.dat',seg=True,time=False,oaspl=False)\nspl.info()\n\nplt.figure()\nspl.compute_time_average()\nplt.pcolormesh(spl.x_grid[:,:,0],\n               spl.y_grid[:,:,0],\n               spl.mean_seg[:,:,0,0])\nplt.xlabel('x (m)')\nplt.ylabel('y (m)')\nplt.show()\n</code></pre> <p>The class <code>SplField</code> also provide function for plotting the results.</p> <p>Warning</p> <p>These functions only works with Cartesian fields.  </p> <pre><code>from prepost import SplField\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nworkdir = './'\n\nspl = SplField()\nspl.load(workdir +'/xy/spl_s_cart_0.dat',seg=True,time=False,oaspl=False)\nspl.info()\nplt.figure()\nspl.compute_time_average()\nplt.subplot(211)\nspl.plot_mean(time=True,OA=False,z=2,freq=100)\nplt.xlabel('x (m)')\nplt.ylabel('y (m)')\nplt.clim(8,44)\nplt.gca().set_aspect('equal',\"box\")\n\n\nspl = SplField()\nspl.load(workdir +'/xy/spl_s_cart_1.dat',seg=True,time=False,oaspl=False)\nspl.info()\nspl.compute_time_average()\nplt.subplot(212)\nspl.plot_mean(time=False,OA=False,z=2,freq=50)\nplt.xlabel('x (m)')\nplt.ylabel('y (m)')\nplt.clim(8,44)\nplt.gca().set_aspect('equal',\"box\")\nplt.show()\n</code></pre> <p>Here the plot are 2D cartography at 2\u00a0m height.  But the function can be slightly modified to plot line plot crossing the wind turbine positions.</p> <pre><code>workdir = './'\nsimu = Simu('c0')\nsimu.load('./c0.dat')\n\nspl = SplField()\nspl.load(workdir +'/xy/spl_s_cart_0.dat',seg=True,time=False,oaspl=False)\nspl.info()\nplt.figure()\nspl.compute_time_average()\nspl.plot_mean(time=True, OA=False,\n                y=simu.ty[0]*simu.les.z_i,\n                z=2,freq=100)\n\n\nspl = SplField()\nspl.plot_mean(time=True, OA=False,\n                y=simu.ty[1]*simu.les.z_i,\n                z=2,freq=100)\nspl.info()\nspl.compute_time_average()\nspl.plot_mean(time=False,OA=False,z=2,freq=50)\n\n\nplt.xlabel('x (m)')\nplt.ylabel('SPL (dB)')\nplt.ylim(8,44)\nplt.show()\n</code></pre>"},{"location":"examples/les_input.html","title":"LES input","text":""},{"location":"examples/les_input.html#wind-turbine-and-mesh-set-up","title":"Wind turbine and mesh set up","text":"<p>Similarly to the previous example library are loaded, the wind turbine geometry  and the mesh are set up. </p> <pre><code>import prepost as pp\nfrom prepost.source.utils import interp_3D_atmos_data\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n\n# Create the object wind turbine\n# -----------------------------------------------------------------------------\nwt = pp.source.WindTurbine()\n# set the parameter to the default turbine \n# the default corresponds to the turbine define in Cotte et al . \nwt.default()\n# set the number of blades\nwt.Nblade = 3\n# set the number of angles to descretize 1/Nblade of the rotor\nwt.Nbeta = 12\n# Resest the span to reach R=60m\nwt.Lspan = 1.2*wt.Lspan\nwt.seg = 1.2*wt.seg\n# Set th wind turbine hub \nwt.href = 90\n\n\n# define the computational domain \n# the wind turbine is assumed to be at (0,0)\n# -----------------------------------------------------------------------------\nny = 20\nnx = 40\n\nx = np.linspace(-200, 1000, nx)\ny = np.linspace(-100, 100, ny)\nz = np.array([2])\n\n# create the Mesh object\nmesh = pp.source.Mesh(polar=False)\n# set the mesh arrays \nmesh.set_cartesian_mesh(x, y, z)\nmesh.cartesian_2_polar()\n</code></pre>"},{"location":"examples/les_input.html#read-les-data","title":"Read LES data","text":"<p>Warning</p> <p>In this example the flow data are read from the output of a Large Eddy simulation code developed at the University of Twente. Without this code and its output this section will not work.</p> <p>The <code>LES</code> class is used to read the LES data.  The output file are read then the turbulence dissipation rate is computed from the flow data. <pre><code>les = pp.Les('/store/lmfa-2/acoustique-nl/simu_jules/LES/2T/C1/blue/')\nles.read(ratio=1)\nles.dissipation()\n</code></pre> The position of the wind turbine inside the flow is retrieved from the LES object. And then the wind speed at hub height is interpolated from the flow data.  <pre><code>offset = 0\nxS = np.array([[les.turbines[0,1]*les.z_i-offset]])\nyS = np.array([[les.turbines[0,2]*les.z_i]])\nzS = np.array([[wt.href]])\nU_hub,epsilon_hub = interp_3D_atmos_data(les,xS,yS,zS)\n</code></pre> This is done in order to control the rotational speed and twist of the blade with respect of this reference wind speed.  <pre><code>wt.controlRotSpeed(U_hub)\nwt.setOptimalTwist(U_hub, 4)\nwt.absolute_pos = (les.turbines[0,1]*les.z_i,\n                   les.turbines[0,2]*les.z_i)\nprint('U_hub', U_hub)\nprint('epsilon_hub', epsilon_hub)\nprint('Omega', wt.omega*60/(2*np.pi))\n</code></pre> The <code>absolute_pos</code> parameter is used to define the position of the wind turbine inside the flow and is used after to interpolate the flow data at each segment and angular positions of the blades. </p>"},{"location":"examples/les_input.html#source-computation","title":"Source computation","text":"<p>Finally the source computation is performed using the class <code>Source</code> similarly to the previous example. </p> <pre><code># define frequencies \n# -----------------------------------------------------------------------------\nfrequencies = np.array([50,100,200,500,800,1000])\n\n# Compute sound power\n# -----------------------------------------------------------------------------\nNcore = 4\nsrc = pp.Source(wt, les, mesh)\nsrc.computeSpp(frequencies, Ncore)\nsrc.mesh.polar_2_cartesian()\n\nsrc.save(\"./swl.dat\", atmos_data=False)\n</code></pre>"},{"location":"examples/les_input.html#data-visualization","title":"Data visualization","text":"<p>The computed acoustic quantity can be plotted similarly to the previous example.  Note that polar plot of the inflow quantity can also be plotted with the <code>Source</code> class. </p> <p><pre><code>src = Source()\nsrc.load(\"./swl.dat\")\nsrc.plot_all_u()\nplt.show()\n</code></pre> This function plots different quantity such as the incoming wind speed, the rotational, speed, the angle of attack, the turbulence dissipation rate for each segment and each angular position of the rotor.</p> <p>Single quantity can also be plotted.  <pre><code>plt.figure()\nsrc.plot_Uinf()\nplt.figure()\nsrc.plot_AoA()\n</code></pre></p>"},{"location":"examples/propa_1_turbine.html","title":"One wind turbine","text":""},{"location":"examples/propa_1_turbine.html#launching-the-pe-fortran-code","title":"Launching the PE fortran code","text":"<p>The simulation are run using the Fortran code <code>src/kernel/New_PE_c/</code>.  See the installation section for compilation instruction.  The code is also briefly explained in the WAPE section.</p> <p>An example of an input file is given here</p> <pre><code>$input\n! general parameters \n!------------------------------------------------------------------------------\ncase_name='c0'\nvar0%c=343\nvar0%rho=1.2\nvar0%gamma=1.4\n\n! Frequencies \nnb_freq=4\nfrequencies(1)=50,100,200,500\n\n! Angles \nnb_theta=1\ntheta(1)=0\n\n! Domain definition \nLx1=3500.0\nLx2=500.0\nLy1=1000.0\nLy2=1000.0\nLz=300\n\n! Numerical parameters \n!------------------------------------------------------------------------------\ndx=0.5\ncfl=0.1\n! PML\nsize=30\nparam=50000.0\nn=2.5\n! impedance\nimp%sigmae=50000.0\nimp%alphae=100.0\nimp%rigid=.false.\n\n! Source \nsrc%pos_x=0.0\nsrc%pos_z=90\n\n! External Flow \n!------------------------------------------------------------------------------\n! if .true. read from twente LES\nexternal_flow=.true.\n! if .true. constant flow equal to u0\nuniform=.false.\n\n! if .true. log profile with z0=0.002\nlogarithmic=.false.\nu0=11\n\n! Set the type of WAPE used\n! if .true. Ostashev WAPE, else classic WAPE\narbitrary=.true.\n\n! if true newa phase preserving WAPE\narbitrary_new=.false.\n\n! (i am not sure this does somethind) \ninterpolation=.true.\n\n! path to LES data\nfdir='/store/lmfa-2/acoustique-nl/simu_jules/LES/2T/C1/blue/output/'\n\n! twente paramaters needed to rescale and positionned the flow \nfname='tavg'\ntinput%ratio=1\ntinput%z_i=1000.0\ntinput%delta=0.25\ntinput%T_scale_K=293.15\ntinput%Lx=6.0\ntinput%Ly=3.44\ntinput%Lz=1.0\ntinput%posx=1.0\ntinput%posy=1.72\ntinput%posz=0.04\n\n! Set output paramaters \n!------------------------------------------------------------------------------\ndout=1\nnb_receiver=3\nheights(1)=2.0, 10, 100\nside=.true.\n\n! does not doe anything \ntop=.false.\n\n! if continuation set to true resart from the last computed angles\n! not yet a continuation with respect to frequency \ncontinuation=.false.\n\n! Set the plane in the complete domain where the solution must be recorded\nnb_xplane=1\nxplane(1)=1000\nnb_yplane=1\nyplane(1)=1000\n$end input\n</code></pre>"},{"location":"examples/propa_1_turbine.html#data-visualization","title":"Data visualization","text":"<p>Once the code has finished running</p> <p>The PE results can be loaded using the Python class <code>PeResults</code></p> <pre><code>from prepost import PeResults\nimport matplotlib.pyplot as plt\n\n# Inputs\n# ------------------------------------------------------------------------------\npe = PeResults(casename='c0', iTurb=0, height=90, tau=0)\n</code></pre> <p>Warning</p> <p>The class needs a name case, a Turbine index a source height and a propagation angle  due to a previous implementation where the file name was defined from these quantities.  In the newest version the file name is directly passed to the read function.</p> <p>The fortran code saves the \\(\\Delta L\\) (sound pressure level relative to the free field) either in the entire domain (2D propagation plane) or for a set of receivers at given heights. In the first case we can plot the 2D cartography for the propagation angle \\(\\tau=0\\) with : <pre><code>pe.read_carto(fname='./c0_0000.h5')\npe.plotSide(freq=500)\nplt.clim(-10,10)\nplt.show()\n</code></pre></p> <p>In the second case we can plot the \\(\\Delta L\\) as a function of \\(x\\) for a given receiver height \\(z=2\\) m with: <pre><code>pe.read_receiver('./c0_0000.h5')\npe.plotLine(freq=500, z=2)\nplt.ylim(-10,10)\nplt.show()\n</code></pre></p>"},{"location":"examples/propa_2_turbines.html","title":"Multiple turbines","text":""},{"location":"examples/propa_2_turbines.html#setting-up-and-launching-the-simulations","title":"Setting up and launching the simulations","text":"<p>To set up multiple propagation simulation from the LES results we first need to create a simulation object <pre><code>from prepost import Simu\n# create simu object\n# -----------------------------------------------------------------------------\nsimu = Simu('c0')\n</code></pre> When creating this object a default dictionary of the input needed for the Fortran code is created.  We can then modify the different inputs for our specific case: </p> <pre><code># define frequency content\n# -----------------------------------------------------------------------------\nfc = [50, 100, 200]\nsimu.set_frequencies(fc)\n\n#  define output parameters\n# -----------------------------------------------------------------------------\nsimu.set_input('side', True)\n#set plane to save solution\n# same referentiel as LES sim\nsimu.set_xplanes([1000])\nsimu.set_yplanes([1720])\n\n# define domain\n# -----------------------------------------------------------------------------\nxmin = 0\nxmax = 1000 + 2000\nymin = 1720 - 1000\nymax = 1720 + 1000\nzmax = 300\nsimu.defineDomain(xmin, xmax, ymin, ymax, zmax)\n</code></pre> <p>Note</p> <p>In the <code>Simu</code> class the domain is rectangular with the same coordinates system as the LES results For the propagation simulation the domain is rectangular, and the wind turbine position is at the origin. This translation is performed when creating the input.nml files for each Fortran simulation.</p> <p>We can then define the source heights used to discretize the wind turbine rotor and the propagation angles:</p> <pre><code># discretize the rotor with equivalent source height\nR = 60\nhub = 90\nNh = 3\ndh = 2*R/Nh\nheight = np.arange(hub-R+dh/2, hub+R, dh)\nheights = np.rint(height).astype(int)\n\ntau = np.array([0,20,40,60,80, 90,100,120,140,160,180,200,220,240,260,270])\n</code></pre> <p>Finally, the path to the LES results used as input for the simulation and the absolute path to the Fortran executable must be given to the <code>defineCases</code> function <pre><code># define cases with height, angles and flow \n# needs to be absolute path\nles_path = '&lt;absolute&gt;/&lt;path&gt;/LES/2T/S2/blue/'\nsrc_path = '&lt;absolute&gt;/&lt;path&gt;/windfarm_noise/src/kernel/New_PE_c/PE_2D_WAPE'\nsimu.defineCases(heights, tau, flow_path=les_path,\n                 src_path=src_path, ratio=1.0)\n</code></pre></p> <p>Once the cases are defined in the <code>Simu</code> object we can create all the input.nml files need to run the cases.  <pre><code>simu.distributeCases(distribute_tau=None, mem=1000,\n                     time=\"01:00:00\", turbine_index=None)\n</code></pre></p> <p>The cases are organized in a tree with a folder for each turbine simulation, a subfolder for each source height and finally each propagation angle is store in the different file which contains all the frequencies computed. </p> <pre><code>\u251c\u2500\u2500 t0\n\u2502   \u251c\u2500\u2500&lt;height_0&gt;\n\u2502   \u2502       c0_0000.dat\n\u2502   \u2502       c0_0020.dat\n\u2502   \u2502     \n\u2502   \u251c\u2500\u2500&lt;height_1&gt;\n\u2502   \u2502       c0_0000.dat\n\u2502   \u2502       c0_0020.dat\n\u2502   \u2502     \n\u2502   \u251c\u2500\u2500&lt;height_1&gt;\n\u2502   \u2502       c0_0000.dat\n\u2502   \u2502       c0_0020.dat\n\u2502   \u2502     \n\u251c\u2500\u2500 t1\n\u2502   \u251c\u2500\u2500&lt;height_0&gt;\n\u2502   \u2502       c0_0000.dat\n\u2502   \u2502       c0_0020.dat\n\u2502   \u2502     \n\u2502   \u251c\u2500\u2500&lt;height_1&gt;\n\u2502   \u2502       c0_0000.dat\n\u2502   \u2502       c0_0020.dat\n\u2502   \u2502     \n\u2502   \u251c\u2500\u2500&lt;height_1&gt;\n\u2502   \u2502       c0_0000.dat\n\u2502   \u2502       c0_0020.dat\n\u2502   \u2502     \n</code></pre> <p>In each subfolder a <code>launch.sh</code> and <code>input.nml</code> file is present to run the simulation. To cases can then be submitted manually with command <pre><code>sbacth launch.sh\n</code></pre> or all at once with the python function </p> <pre><code>simu.launchCases(turbine_index=None)\n</code></pre> <p>Warning</p> <p>In the case of large wind farm this can result in a very large number of jobs being submitted at the same which can creates problem in SLURM queue.  To avoid this, the following method is preferable. </p> <p>After creating all the input files the function can be used </p> <p><pre><code>simu.createLocalLaunchFiles(mem=6000, time=\"01:00:00\", turbine_index=None)\n</code></pre> This regroups several cases in one node with respect to the maximum memory allocated per cases (here 6Gb).</p> <p>Warning</p> <p>This method was tailored to run on the haswell partition of the PMCS2I cluster, the maximum size of a haswell node (64Gb) is hard coded in the function</p> <p>This function creates several launch.sh files in the parent directory which should reduce largely the number of SLURM jobs.  <p>The job can then be launched manually or with the command  <pre><code>simu.launchCases2()\n</code></pre></p> <p>Finally, the <code>Simu</code> can be saved to be use in the post-processing routines. </p> <pre><code>simu.save()\n</code></pre>"},{"location":"examples/propa_2_turbines.html#post-processing-for-top-view","title":"Post processing for top view","text":"<p>To post process the simulations we can either use the <code>PeResults</code> to read individual propagation planes or we can use the <code>DeltaLfield</code> class which allows concatenating all propagation angle and source height into one matrix.</p> <pre><code>from prepost import concatenate_all_dl\n</code></pre> <p>First we can check that all simulation were run properly  <pre><code>from prepost import Simu\nworkdir = './'\ncase = 'c0'\nsimu = Simu(workdir + case)\nsimu.load(workdir + 'c0.dat')\nsimu.check_run_cases()\n</code></pre></p> <p>Warning</p> <p>The <code>check_run_cases</code> only check that the output files exists. It does not check if all frequency were computed or if the files are not corrupted. </p> <p>A wrapper for the class is also written which allows to read all the simulation as defined in the object <code>Simu</code> and save it in a file as a <code>DeltaLField</code> object. </p> <pre><code>from prepost import concatenate_all_dl\npath2Pe = './'\ncase = 'c0'\niTurb = [0]\nconcatenate_all_dl(case, path2Pe, refine=5, iTurb=iTurb,\n                      z=2, stepx=5,\n                      dl_fname=workdir+'/xy/DL_polar')\n</code></pre> <p>This function reads the <code>Simu</code> object, then according to the case defined it reads all the PE receiver results and concatenate the propagation fields. Details of the function can be found here.</p> <p>To visualize the data first load the deltaLField object: Then we can use the <code>plot_top_cartesian</code> function to plot a top view of the results. </p> <pre><code>from prepost import DeltaLField\nimport matplotlib.pyplot as plt\n\ndl = DeltaLField()\ndl.load('./xy/DL_polar0.dat')\n\nplt.subplot(211)\ndl.plot_top_cart(z=2, freq=200, height=130, cmap='RdBu_r')\nplt.clim(-8, 8)\nplt.xlim(0, 3000)\nplt.ylim(720, 2720)\nplt.gca().set_aspect('equal', adjustable='box')\n\ndl.load('./xy/DL_polar1.dat')\nplt.subplot(212)\ndl.plot_top_cart(z=2, freq=50, height=90, cmap='RdBu_r')\nplt.clim(-8, 8)\nplt.xlim(0, 3000)\nplt.ylim(720, 2720)\nplt.gca().set_aspect('equal', adjustable='box')\nplt.show()\n</code></pre> <p></p>"},{"location":"examples/propa_2_turbines.html#post-processing-for-side-view","title":"Post-processing for side view","text":"<p>Create a side view of the delta L field a wrapper is also implemented.  The <code>concatenate_side_dl</code> function allows to concatenate PE results to obtain a 2D field in  a plane of propagation.  The fields are interpolated on a grid <code>(nx,nz)</code>. Note that in this example two opposite propagation planes are concatenated. Another set of angle could be <code>[20 ,200]</code> or just one angle.  Note that order is important the second propagation angle will be reverse so that the increasing x direction is in the first angles given direction. </p> <p><pre><code>from prepost import concatenate_side_dl\n# create side view fields\n# -----------------------------------------------------------------------------\npp.concatenate_side_dl(case, path2Pe, iTurb=iTurb,\n            tau=[0,180], nx=900, nz=151, dl_fname=workdir+'/xz/DL')\n</code></pre> After this post-processing, the Delta is store in the same variable as for the top view. The field is a ND matrix of size <code>(nx, ny, nz, Nfreq, Nheight)</code> with <code>ny=1</code>.  The same set of plotting function or interpolating function of the <code>DeltaLField</code>class can then be used to visualize the data. </p> <pre><code>from prepost import DeltaLField\nimport matplotlib.pyplot as plt\n\ndl = DeltaLField()\ndl.load('./xz/DL0.dat')\n\nplt.subplot(211)\ndl.plot_xz(y=1480,freq=100,height=130,cmap=\"RdBu_r\")\nplt.clim(-10,10)\n\n\ndl = DeltaLField()\ndl.load('./xz/DL1.dat')\nprint(dl.y_array)\n\nplt.subplot(212)\ndl.plot_xz(y=1960,freq=100,height=130,cmap=\"RdBu_r\")\nplt.clim(-10,10)\n\nplt.show()\n</code></pre>"},{"location":"examples/propagation.html","title":"General","text":"<p>The propagation simulation can be performed either directly with the Fortran code (see the first example) or by using a Python class that allows to set up several PE simulation to assess the noise from a wind farm (see second example). </p>"},{"location":"examples/simple_input.html","title":"Simple input","text":"<p>First example allows computing the noise generated from a wind turbine with a simple power profile as input for the flow. </p> <p>First you need to load the useful libraries. <pre><code>from prepost.source import Windturbine\nfrom prepost.source import Mesh\nfrom prepost.source import Source\nfrom prepost import Les\nimport numpy as np\nimport matplotlib.pyplot as plt\n</code></pre></p>"},{"location":"examples/simple_input.html#wind-turbine-geometry","title":"Wind turbine geometry","text":"<p>Then we first define the geometry of the wind turbine with the class <code>WindTurbine</code>.</p> <pre><code>wt = WindTurbine()\n# set the parameter to the default turbine \n# the default corresponds to the turbine define in Cotte et al . \nwt.default()\n# set the number of blades\nwt.Nblade = 3\n# set the number of angles to descretize 1/Nblade of the rotor\nwt.Nbeta = 12\n# Resest the span to reach R=60m\nwt.Lspan = 1.2*wt.Lspan\nwt.seg = 1.2*wt.seg\n# Set th wind turbine hub \nwt.href = 90\n</code></pre> <p>The default wind turbine is created. It is similar to the one used in Cott\u00e9 et al (2019).  But with a slightly wider diameter (50\u00a0m radius instead of 48\u00a0m). </p> <p>The number of blade is set to 3 and the number of discretization angle to 12.  The angular step is equal to \\(\\Delta \\beta = 2\\pi /\\)(Nbeta.Nblade).</p> <p>We then readjust the diameter of the blade by scaling the span and the position of each segment to obtain a radius of 60\u00a0m.  Finally, the hub height is set a 90\u00a0m. </p>"},{"location":"examples/simple_input.html#mesh-definition","title":"Mesh definition","text":"<p>After defining the wind turbine geometry the mesh on which the simulation must be performed is defined.  Here we do not compute a sound power level (which would be independent of the position) but the sound pressure level in free field, which depends on the distance between the source and the receiver and the angle between each pair of receivers and sources. </p> <p><pre><code>ny = 40\nnx = 20\n\nx = np.linspace(-200, 200, nx)\ny = np.linspace(-100, 100, ny)\nz = np.array([2])\n\n# create the Mesh object\nmesh = Mesh(polar=False)\n# set the mesh arrays \nmesh.set_cartesian_mesh(x, y, z)\nmesh.cartesian_2_polar()\n</code></pre> Here a Cartesian mesh is defined from the three vector \\(x\\), \\(y\\), and \\(z\\). The code also allows to define a polar mesh with \\(x\\), \\(\\tau\\) and \\(z\\), where x is the radius and \\(\\tau\\) the propagation angle. In order for the mesh to be used in the source model the coordinates must always be converted to polar which is done at the last step. To do so the wind turbine is always considered to bee at position \\((x=0,y=0)\\).</p>"},{"location":"examples/simple_input.html#atmospheric-conditions","title":"Atmospheric conditions","text":"<p>As previously stated the code developed in this project is tailored to work with  Large eddy simulation results from the PoF group at the university of Twente.  However, it is also possible to create your own flow data that you can input to the source model. </p> <p>The flow data must contain a Cartesian mesh defined by three vector x, y, and z and the streamiwse component of the wind speed and turbulence dissipation rate as 2D matrix which size corresponds to (z,y,x). </p> <p>In this example we create a simple flow data to obtain a stratified flow (constant in x and y direction) with a power profile and a wind speed at hub height of 11.4 m/s.  Here the turbulent dissipation rate is set constant equal to 0.01 m2/s3 <pre><code>atmos = Les('./')\natmos.z = np.linspace(0,200,100)\natmos.y = np.array([-1000,1000])\natmos.x = np.array([-1000,1000])\nZ,Y,X = np.meshgrid(atmos.z,atmos.y,atmos.x,indexing='ij')\n\nU_hub = 11.5 # ms \nalpha = 0.4\nepsilon = 0.01\n\natmos.u = U_hub * (Z/wt.href) ** alpha\nprint(atmos.u.shape)\n\n# plt.plot(atmos.u[:,0,0],atmos.z)\natmos.epsilon = np.zeros_like(atmos.u) +  epsilon\n</code></pre></p>"},{"location":"examples/simple_input.html#source-computation","title":"Source computation","text":"<p>Finally the source computation is performed using the class <code>Source</code></p> <p><pre><code># define frequencies\nfrequencies = np.array([50,100,200,500,800,1000])\n\n# set the rotational speed \nomega = 12.1 * 2 * np.pi / 60\nwt.controlRotSpeed(U_hub, omega=omega)\n#define the blade twist \nwt.setOptimalTwist(U_hub, 4)\n\nprint('U_hub', U_hub)\nprint('Omega', wt.omega*60/(2*np.pi))\n\nsrc = Source(wt, atmos, mesh)\n\nNcore = 4\nsrc.computeSpp(frequencies, Ncore)\nsrc.mesh.polar_2_cartesian()\n\nsrc.save(\"./swl.dat\")\n</code></pre> The data computed are saved in the file <code>swl.dat</code></p>"},{"location":"examples/simple_input.html#data-visualization","title":"Data visualization","text":"<p>To visualize the data previously computed first the data are loaded using the <code>Source</code> class. <pre><code>src = Source()\nsrc.load(\"./swl.dat\")\n</code></pre></p> <p>Then a receiver position is chosen to plot the data <pre><code>x = 200\ny = 0\nix = np.abs(src.mesh.x_array - x).argmin()\niy = np.abs(src.mesh.y_array - y).argmin()\n</code></pre></p> <p>The SWL (sound power level) computed for each segment is logarithmicaly sum over all the segments and is averaged over the angular position of the rotor to obtain the total SWL of the turbine.  <pre><code>SWL_true = 10*np.log10(np.sum(10**(src.SWL[ix, 0, iy, ...]/10),\n                  (0, 2))/src.Nbeta) + Aweight(src.frequencies)\n</code></pre></p> <p>Note</p> <p>here a A-weighting is added to the spectrum with the function <code>Aweight()</code></p> <p>Another possibility is to compute the distance between the wind turbine hub and the receiver <pre><code>x = src.mesh.x_array[ix]\ny = src.mesh.y_array[iy]\nR = np.sqrt((x-src.wt.absolute_pos[0])**2 + (y-src.wt.absolute_pos[1])**2)\n</code></pre> Then a pseudo Sound power level is computed from the Sound pressure level in free field.  The difference with the previous sound power level (SWL_true) is that here the distance between the source and the receiver are the same for all segments. In our case the computation is done for the trailing edge (TEN) and turbulent inflow (TIN) noise and for the total SPL. <pre><code>SWL = 10*np.log10(np.sum(10**(src.Spp[ix, 0, iy, ...]/10),\n                         (0,2))/src.Nbeta)+Aweight(src.frequencies)+10*np.log10(4*np.pi*R*R)\nTIN = 10*np.log10(np.sum(10**(src.Spp_tin[ix, 0, iy, ...]/10),\n                         (0,2))/src.Nbeta)+Aweight(src.frequencies)+10*np.log10(4*np.pi*R*R)\nTEN = 10*np.log10(np.sum(10**(src.Spp_ten[ix, 0, iy, ...]/10),\n                         (0,2))/src.Nbeta)+Aweight(src.frequencies)+10*np.log10(4*np.pi*R*R)\n</code></pre></p> <p>Finally, the spectrum at this receiver location can be plotted using Matplotlib <pre><code>plt.plot(src.frequencies, TEN, 'r:')\nplt.plot(src.frequencies, TIN, 'b:')\nplt.plot(src.frequencies, SWL, 'k')\nplt.plot(src.frequencies, SWL_true, 'g--')\nplt.legend(['TEN','TIN','SWL','SWL_true'])\nplt.xscale('log')\n\nplt.show()\n</code></pre></p>"},{"location":"examples/source.html","title":"General","text":"<p>The full script for the examples presented here after can be found in <code>example/source/</code>. They demonstrate how to use the python code to compute the Sound Pressure level in free field (\\(S_{ff}\\)) using the model developed by Cott\u00e9 et al.  The model definition can be found either in Colas Phd Thesis</p> <p>Or in these different works:</p> <p>Y. Tian. Modeling of wind turbine noise sources and propagation in the atmosphere. PhD thesis, Universit\u00e9 Paris Saclay (COmUE), Feb. 2016. </p> <p>Y. Tian and B. Cott\u00e9. Wind Turbine Noise Modeling Based on Amiet\u2019s Theory: Effects of Wind Shear and Atmospheric Turbulence. Acta Acustica united with Acustica, 102(4):626\u2013 639, July 2016. ISSN 16101928. doi: 10.3813/AAA.918979</p> <p>B. Cott\u00e9. Extended source models for wind turbine noise propagation. The Journal of the Acoustical Society of America, 145(3):1363\u20131371, Mar. 2019. ISSN 0001-4966. doi: 10.1121/1.5093307</p> <p>D. Mascarenhas, B. Cott\u00e9, and O. Doar\u00e9. Synthesis of wind turbine trailing edge noise in free field. JASA Express Letters, 2(3):033601, Mar. 2022. ISSN 2691-1191. doi: 10.1121/10.0009658</p>"},{"location":"reference/audio_tools.html","title":"Reference for <code>prepost/audio_tools.py</code>","text":""},{"location":"reference/audio_tools.html#src.prepost.audio_tools.c","title":"<code>c(celerity=343)</code>","text":"<p>Return the celerity of sound in m/s.</p>"},{"location":"reference/audio_tools.html#src.prepost.audio_tools.c--returns","title":"Returns","text":"<p>c : float     The sound celerity in m/s.</p>"},{"location":"reference/audio_tools.html#src.prepost.audio_tools.c--parameters","title":"Parameters","text":"<p>celerity : float, default=343     The celerity in m/s.</p> Source code in <code>src/prepost/audio_tools.py</code> <pre><code>def c(celerity=343):\n\n    \"\"\"Return the celerity of sound in m/s.\n\n    Returns\n    -------\n    c : float\n        The sound celerity in m/s.\n\n    Parameters\n    ----------\n    celerity : float, default=343\n        The celerity in m/s.\n    \"\"\"\n\n    c = celerity\n    return c\n</code></pre>"},{"location":"reference/audio_tools.html#src.prepost.audio_tools.k","title":"<code>k(f, c=343)</code>","text":"<p>Return the acoustic wave number in rad/m.</p>"},{"location":"reference/audio_tools.html#src.prepost.audio_tools.k--returns","title":"Returns","text":"<p>k : float     The acoustic wave number in rad/m.</p>"},{"location":"reference/audio_tools.html#src.prepost.audio_tools.k--parameters","title":"Parameters","text":"<p>f : float     The frequency in Hz. c : float     The sound speed in m/s (default = 343 m/s).</p> Source code in <code>src/prepost/audio_tools.py</code> <pre><code>def k(f, c=343):\n\n    \"\"\"Return the acoustic wave number in rad/m.\n\n    Returns\n    -------\n    k : float\n        The acoustic wave number in rad/m.\n\n    Parameters\n    ----------\n    f : float\n        The frequency in Hz.\n    c : float\n        The sound speed in m/s (default = 343 m/s).\n    \"\"\"\n    return 2 * np.pi * f / c\n</code></pre>"},{"location":"reference/audio_tools.html#src.prepost.audio_tools.omega","title":"<code>omega(f)</code>","text":"<p>Return the acoustic pulsating frequency in rad.</p>"},{"location":"reference/audio_tools.html#src.prepost.audio_tools.omega--returns","title":"Returns","text":"<p>omega : float     The acoustic pulsating frequency in rad.</p>"},{"location":"reference/audio_tools.html#src.prepost.audio_tools.omega--parameters","title":"Parameters","text":"<p>f : float     The frequency in Hz.</p> Source code in <code>src/prepost/audio_tools.py</code> <pre><code>def omega(f):\n\n    \"\"\"Return the acoustic pulsating frequency in rad.\n\n    Returns\n    -------\n    omega : float\n        The acoustic pulsating frequency in rad.\n\n    Parameters\n    ----------\n    f : float\n        The frequency in Hz.\n    \"\"\"\n    return 2 * np.pi * f\n</code></pre>"},{"location":"reference/audio_tools.html#src.prepost.audio_tools.cart2sph","title":"<code>cart2sph(x, y, z, degree=True)</code>","text":"<p>Return the spherical coordinate <code>r, theta, phi</code> of an array <code>x, y, z</code> in  cartesian coordinates.</p>"},{"location":"reference/audio_tools.html#src.prepost.audio_tools.cart2sph--returns","title":"Returns","text":"<p>r : float     The value in spherical coordinates theta : float     The value in spherical coordinates phi : float     The value in spherical coordinates</p>"},{"location":"reference/audio_tools.html#src.prepost.audio_tools.cart2sph--parameters","title":"Parameters","text":"<p>x : float     The value in Cartesian coordinate y : float     The value in Cartesian coordinate z : float     The value in Cartesian coordinate degree : bool, default=True     If true, returns the spherical coordinates in degree.</p>"},{"location":"reference/audio_tools.html#src.prepost.audio_tools.cart2sph--description","title":"Description","text":"<p>Spherical coordinate system used:           Define :math:<code>r</code> to be distance (radius) from a point to the origin,     :math:<code>\\theta</code> to be the colatitude angle and  :math:<code>\\phi</code> to be the      azimuthal angle. The ISO 80000-2:2019 convention is used.</p> Source code in <code>src/prepost/audio_tools.py</code> <pre><code>def cart2sph(x, y, z, degree=True):\n    \"\"\"Return the spherical coordinate ``r, theta, phi`` of an array ``x, y, z`` in \n    cartesian coordinates.\n\n    Returns\n    -------\n    r : float\n        The value in spherical coordinates\n    theta : float\n        The value in spherical coordinates\n    phi : float\n        The value in spherical coordinates\n\n    Parameters\n    ----------\n    x : float\n        The value in Cartesian coordinate\n    y : float\n        The value in Cartesian coordinate\n    z : float\n        The value in Cartesian coordinate\n    degree : bool, default=True\n        If true, returns the spherical coordinates in degree.\n\n    Description\n    -----------\n    Spherical coordinate system used:        \n        Define :math:`r` to be distance (radius) from a point to the origin,\n        :math:`\\\\theta` to be the colatitude angle and  :math:`\\\\phi` to be the \n        azimuthal angle. The ISO 80000-2:2019 convention is used.\n\n    \"\"\"\n    x, y, z = np.array(x), np.array(y), np.array(z)\n    if x.shape != y.shape != z.shape:\n        raise ValueError('Arg arrays must have the same shape')\n    r, theta, phi = np.zeros(x.shape), np.zeros(x.shape), np.zeros(x.shape)\n    r = np.sqrt(x**2 + y**2 + z**2) # Radius\n    theta = np.arctan2(np.sqrt(x**2 + y**2), z) # Azimuth\n    phi = np.arctan2(y, x) # Colatitude \n\n\n    if degree==True:\n        return r, np.rad2deg(theta), np.rad2deg(phi)\n    else:\n        return r, theta, phi\n</code></pre>"},{"location":"reference/audio_tools.html#src.prepost.audio_tools.sph2cart","title":"<code>sph2cart(r, theta, phi, deg=True)</code>","text":"<p>Return the Cartesian coordinate <code>x, y, z</code> of an array <code>r, theta, phi</code> in  spherical coordinates.</p>"},{"location":"reference/audio_tools.html#src.prepost.audio_tools.sph2cart--returns","title":"Returns","text":"<p>x : float     The value in Cartesian coordinate y : float     The value in Cartesian coordinate z : float     The value in Cartesian coordinate</p>"},{"location":"reference/audio_tools.html#src.prepost.audio_tools.sph2cart--parameters","title":"Parameters","text":"<p>r : float     The value in spherical coordinates theta : float     The value in spherical coordinates phi : float     The value in spherical coordinates</p>"},{"location":"reference/audio_tools.html#src.prepost.audio_tools.sph2cart--description","title":"Description","text":"<p>Spherical coordinate system used:           Define :math:<code>r</code> to be distance (radius) from a point to the origin,     :math:<code>\\theta</code> to be the colatitude angle and  :math:<code>\\phi</code> to be the      azimuthal angle. The ISO 80000-2:2019 convention is used.</p> Source code in <code>src/prepost/audio_tools.py</code> <pre><code>def sph2cart(r, theta, phi, deg=True):\n\n    \"\"\"Return the Cartesian coordinate ``x, y, z`` of an array ``r, theta, phi`` in \n    spherical coordinates.\n\n    Returns\n    -------\n    x : float\n        The value in Cartesian coordinate\n    y : float\n        The value in Cartesian coordinate\n    z : float\n        The value in Cartesian coordinate\n\n    Parameters\n    ----------\n    r : float\n        The value in spherical coordinates\n    theta : float\n        The value in spherical coordinates\n    phi : float\n        The value in spherical coordinates\n\n    Description\n    -----------\n    Spherical coordinate system used:        \n        Define :math:`r` to be distance (radius) from a point to the origin,\n        :math:`\\\\theta` to be the colatitude angle and  :math:`\\\\phi` to be the \n        azimuthal angle. The ISO 80000-2:2019 convention is used.\n\n    \"\"\"\n    r, theta, phi = np.array(r), np.array(theta), np.array(phi)\n    if (r.shape != theta.shape != phi.shape):\n        raise ValueError('Arg arrays must have the same shape')\n    x, y, z = np.zeros(r.shape), np.zeros(r.shape), np.zeros(r.shape)\n\n    if deg==True:\n        x = r * np.sin(np.deg2rad(theta)) * np.cos(np.deg2rad(phi))\n        y = r * np.sin(np.deg2rad(theta)) * np.sin(np.deg2rad(phi))\n        z = r * np.cos(np.deg2rad(theta))\n    else:\n        x = r * np.sin(theta) * np.cos(phi)\n        y = r * np.sin(theta) * np.sin(phi)\n        z = r * np.cos(theta)\n\n    return x, y, z\n</code></pre>"},{"location":"reference/audio_tools.html#src.prepost.audio_tools.lmfa_room_dim","title":"<code>lmfa_room_dim()</code>","text":"<p>Returns the x, y and z dimensions of the listening room at LMFA.</p>"},{"location":"reference/audio_tools.html#src.prepost.audio_tools.lmfa_room_dim--returns","title":"Returns","text":"<p>room_dim : array (3,)     The dimensionss of the listening room.</p> Source code in <code>src/prepost/audio_tools.py</code> <pre><code>def lmfa_room_dim():\n\n    \"\"\"Returns the x, y and z dimensions of the listening room at LMFA.\n\n    Returns\n    -------\n    room_dim : array (3,)\n        The dimensionss of the listening room.\n\n    \"\"\" \n\n    room_dim = np.array([3, 4, 2.7])\n\n    return room_dim\n</code></pre>"},{"location":"reference/audio_tools.html#src.prepost.audio_tools.lmfa_xyz_spkr","title":"<code>lmfa_xyz_spkr()</code>","text":"<p>Returns the x, y and z coordinates of the listening room loudspeakers at LMFA.</p>"},{"location":"reference/audio_tools.html#src.prepost.audio_tools.lmfa_xyz_spkr--returns","title":"Returns","text":"<p>xyz : array (22, 3)     The coordiantes of the loudspeakers.</p> Source code in <code>src/prepost/audio_tools.py</code> <pre><code>def lmfa_xyz_spkr():\n\n    \"\"\"Returns the x, y and z coordinates of the listening room loudspeakers at LMFA.\n\n    Returns\n    -------\n    xyz : array (22, 3)\n        The coordiantes of the loudspeakers.\n\n    \"\"\" \n\n    xyz = np.array([[1.4,1.9,0],[1.4,1,0],[1.4,0,0],[1.4,-1,0],[1.4,-1.9,0], # Center front\n                        [0,1.9,0],[0,-1.9,0], # Center center\n                        [-1.4,1,0],[-1.4,0,0],[-1.4,-1,0], # Center back\n                        [1.4,1.9,1.25],[1.4,0,1.25],[1.4,-1.9,1.25], # Up front\n                        [0,1.9,1.25],[0,0,1.25],[0,-1.9,1.25], # Up center\n                        [-1.4,1,1.25],[-1.4,0,1.25],[-1.4,-1,1.25], # Up back\n                        [1.4,1.9,-1.25],[1.4,0,-1.25],[1.4,-1.9,-1.25]]) # Bottom front\n\n    return xyz\n</code></pre>"},{"location":"reference/audio_tools.html#src.prepost.audio_tools.get_hrir","title":"<code>get_hrir(theta, phi)</code>","text":"<p>Return the Head Related Impulse Responses corresponding from the closest angles <code>theta, phi</code> as FIR filters.</p>"},{"location":"reference/audio_tools.html#src.prepost.audio_tools.get_hrir--returns","title":"Returns","text":"<p>rir_l : array     The left ear RIR  rir_r : float     The right ear RIR</p>"},{"location":"reference/audio_tools.html#src.prepost.audio_tools.get_hrir--parameters","title":"Parameters","text":"<p>theta : float     The azimuthal angle in degrees phi : float     The colatitude angle in degrees</p>"},{"location":"reference/audio_tools.html#src.prepost.audio_tools.get_hrir--description","title":"Description","text":"<p>Spherical coordinate system used:           Define :math:<code>r</code> to be distance (radius) from a point to the origin,     :math:<code>\\theta</code> to be the azimuthal angle in the :math:<code>xy</code>-plane from      the :math:<code>x</code>-axis with :math:<code>0\\leq\\theta&lt;2\\pi</code>, and :math:<code>\\phi</code> to      be the polar angle (also known as the zenith angle and colatitude, with     :math:<code>\\phi=90^\\circ - \\delta</code> where :math:<code>\\delta</code> is the latitude)      from the positive :math:<code>z</code>-axis with :math:<code>0\\leq \\phi \\leq \\pi</code>.      This is the convention commonly used in mathematics.</p> Source code in <code>src/prepost/audio_tools.py</code> <pre><code>def get_hrir(theta, phi):\n\n    \"\"\"\n    Return the Head Related Impulse Responses corresponding from the closest angles ``theta, phi`` as FIR filters.\n\n    Returns\n    -------\n    rir_l : array\n        The left ear RIR \n    rir_r : float\n        The right ear RIR\n\n    Parameters\n    ----------\n    theta : float\n        The azimuthal angle in degrees\n    phi : float\n        The colatitude angle in degrees\n\n    Description\n    -----------\n    Spherical coordinate system used:        \n        Define :math:`r` to be distance (radius) from a point to the origin,\n        :math:`\\\\theta` to be the azimuthal angle in the :math:`xy`-plane from \n        the :math:`x`-axis with :math:`0\\leq\\\\theta&lt;2\\pi`, and :math:`\\phi` to \n        be the polar angle (also known as the zenith angle and colatitude, with\n        :math:`\\phi=90^\\circ - \\delta` where :math:`\\delta` is the latitude) \n        from the positive :math:`z`-axis with :math:`0\\leq \\phi \\leq \\pi`. \n        This is the convention commonly used in mathematics. \n\n    \"\"\"\n    HRTF_path = path.dirname(__file__) + '/HRTF_44100.sofa' # Path to sofa HRIR file\n    HRTF = sofa.Database.open(HRTF_path) # Open sofa data\n\n    # Retrieve source positions of the HRIR measurements\n    src_positions = HRTF.Source.Position.get_values(system=\"spherical\") \n\n    # Get cartesian coordinates of the source positions for : \n    # r=1, colatitude = 90 - latitude, azimuth\n    vec_cart_src = np.stack(sph2cart(1, 90-src_positions[:,1], src_positions[:,0]), axis=1)\n    # Get cartesian coordinates of the given source angles\n    vec_cart_source = np.stack(sph2cart(1, theta, phi), axis=0)\n    # Retrieve the index of the nearest grid point based on dot product\n    idx = np.argmax(vec_cart_source@vec_cart_src.T).squeeze()\n    #\n    # n_samples = int(np.floor(((src_positions[0,2]-0.1)/c())*HRTF.Data.SamplingRate.get_values(indices={\"M\":idx})))\n    # Get IR for the left ear (receiver 0)\n    ir_l = HRTF.Data.IR.get_values(indices={\"M\":idx, \"R\":0, \"E\":0})\n    # ir_l = np.concatenate((np.roll(ir_l, -n_samples)[:-n_samples], np.zeros(n_samples)))\n    # Get IR for the right ear (receiver 1)\n    ir_r = HRTF.Data.IR.get_values(indices={\"M\":idx, \"R\":1, \"E\":0})\n    # ir_r = np.concatenate((np.roll(ir_r, -n_samples)[:-n_samples], np.zeros(n_samples)))\n\n    return ir_l, ir_r\n</code></pre>"},{"location":"reference/audio_tools.html#src.prepost.audio_tools.binaural","title":"<code>binaural(sound, ir_l, ir_r)</code>","text":"<p>Return normalized binaural stereo sound.</p>"},{"location":"reference/audio_tools.html#src.prepost.audio_tools.binaural--returns","title":"Returns","text":"<p>binaural_sound : array     The binaural stereo sound</p>"},{"location":"reference/audio_tools.html#src.prepost.audio_tools.binaural--parameters","title":"Parameters","text":"<p>sound : array     The sound file to convolve rir_l : array     The IR filter for the left ear rir_r : array     The IR filter for the right ear fs : float     The sampling frequency play : bool, default=True     If true, plays the binaural sound file using sounddevice.</p>"},{"location":"reference/audio_tools.html#src.prepost.audio_tools.binaural--description","title":"Description","text":"Source code in <code>src/prepost/audio_tools.py</code> <pre><code>def binaural(sound, ir_l, ir_r):\n\n    \"\"\"\n    Return normalized binaural stereo sound.\n\n    Returns\n    -------\n    binaural_sound : array\n        The binaural stereo sound\n\n    Parameters\n    ----------\n    sound : array\n        The sound file to convolve\n    rir_l : array\n        The IR filter for the left ear\n    rir_r : array\n        The IR filter for the right ear\n    fs : float\n        The sampling frequency\n    play : bool, default=True\n        If true, plays the binaural sound file using sounddevice.\n\n    Description\n    -----------\n\n    \"\"\"\n\n    # Lenght of the sound file\n    N = sound.shape[0]\n    # Initialize binaural stereo sound matrix\n    binaural_sound = np.zeros((N, 2))\n    # Convolve left side\n    binaural_sound[:,0] = fftconvolve(sound, ir_l)[:N]\n    # Convolve right side\n    binaural_sound[:,1] = fftconvolve(sound, ir_r)[:N]\n\n    return binaural_sound\n</code></pre>"},{"location":"reference/audio_tools.html#src.prepost.audio_tools.decoder_binaural","title":"<code>decoder_binaural(blm, lmax=3, method='mode_matching', src='plane')</code>","text":"<p>Return decoded sound file.</p>"},{"location":"reference/audio_tools.html#src.prepost.audio_tools.decoder_binaural--returns","title":"Returns","text":"<p>binaural_sound : 2-D array     sound.shape[0] by 2 matrix </p>"},{"location":"reference/audio_tools.html#src.prepost.audio_tools.decoder_binaural--parameters","title":"Parameters","text":"<p>blm : array     The encoded sound file of shape lmax by N samples lmax : int     The ambisonic order (lmax &gt; 0) method : string, default='mode_matching'     Deconding method. Should be 'mode_matching' src : string, default='plane'     The type of source to consider for encoding. Should be 'plane or 'monopole'.</p>"},{"location":"reference/audio_tools.html#src.prepost.audio_tools.decoder_binaural--description","title":"Description","text":"Source code in <code>src/prepost/audio_tools.py</code> <pre><code>def decoder_binaural(blm: np.ndarray, lmax: int=3, method:str='mode_matching', src='plane'):\n\n    \"\"\"Return decoded sound file.\n\n    Returns\n    -------\n    binaural_sound : 2-D array\n        sound.shape[0] by 2 matrix \n\n    Parameters\n    ----------\n    blm : array\n        The encoded sound file of shape lmax by N samples\n    lmax : int\n        The ambisonic order (lmax &gt; 0)\n    method : string, default='mode_matching'\n        Deconding method. Should be 'mode_matching'\n    src : string, default='plane'\n        The type of source to consider for encoding. Should be 'plane or 'monopole'.\n\n    Description\n    -----------\n\n    \"\"\"\n\n    HRTF_path = path.dirname(__file__) + '/HRTF_44100.sofa' # Path to sofa HRIR file\n    HRTF = sofa.Database.open(HRTF_path) # Open sofa data\n\n    # Retrieve source positions of the HRIR measurements\n    src_positions = HRTF.Source.Position.get_values(system=\"spherical\") \n\n    if method=='mode_matching':\n\n        C = np.zeros(shape=((lmax + 1)**2, src_positions.shape[0]))\n\n        if src=='plane':\n\n            # Spherical harmonic coefficients of the loudspeakers\n            for src_count in range(src_positions.shape[0]):       \n                C[:, src_count] = spharm_acn(lmax, 90-src_positions[src_count,1], src_positions[src_count,0])\n\n        elif src=='monopole' :\n\n            print('Sorry, not implemented yet')\n\n        elif (src != 'plane' != 'monopole'):\n            raise ValueError('src must be plane or monopole')\n\n        # Matrix pseudo inverse to obtain the decoding matrix\n        decoder = np.linalg.pinv(C, rcond=1/100)\n        # Calculate the loudspeaker signals from the target SH sound field\n        w = decoder@blm\n        # Initialize binaural stereo sound file\n        binaural_sound = np.zeros((blm.shape[1], 2))\n        # Sum the binaural signals from each loudspeaker\n        for i_src in range(src_positions.shape[0]):\n            # Retrieve IRs from sofa file\n            ir_l, ir_r = get_hrir(90-src_positions[i_src,1], src_positions[i_src,0])\n            # Convolve noise with IRs\n\n            binaural_sound += binaural(w[i_src,:], ir_l, ir_r)\n\n        return binaural_sound\n</code></pre>"},{"location":"reference/audio_tools.html#src.prepost.audio_tools.lm2acn","title":"<code>lm2acn(coeffs)</code>","text":"<p>Out of Class version of lm2acn. Reshapes a matrix of coefficients from i-l-m to ACN  (Ambisonic Channel Number ordering).</p> Source code in <code>src/prepost/audio_tools.py</code> <pre><code>def lm2acn(coeffs):\n    \"\"\" \n    Out of Class version of lm2acn.\n    Reshapes a matrix of coefficients from i-l-m to ACN \n    (Ambisonic Channel Number ordering).\n\n    \"\"\"\n    lmax = coeffs.shape[2]-1\n    newcoeffs = np.zeros([(lmax+1)**2], dtype = type(coeffs[0, 0, 0]))\n    for acn in range((lmax+1)**2):\n        l = int(np.sqrt(acn))\n        m = int(acn - l**2 - l)\n        if m&lt;0:\n            i = 1\n        else:\n            i = 0\n        newcoeffs[acn] = coeffs[i, l, abs(m)]\n    return newcoeffs\n</code></pre>"},{"location":"reference/audio_tools.html#src.prepost.audio_tools.acn2lm","title":"<code>acn2lm(coeffs)</code>","text":"<p>Converts the matrix of coefficients of an SHCoeffs instance  from ACN (Ambisonic Channel Number ordering) to i-l-m</p> Source code in <code>src/prepost/audio_tools.py</code> <pre><code>def acn2lm(coeffs):\n    \"\"\" \n    Converts the matrix of coefficients of an SHCoeffs instance \n    from ACN (Ambisonic Channel Number ordering) to i-l-m\n    \"\"\"\n    lmax = int(np.sqrt(coeffs.size))\n    newcoeffs = np.zeros([2, lmax, lmax], dtype = type(coeffs[0]))\n    for acn in range(coeffs.size):\n        l = int(np.sqrt(acn))\n        m = int(acn - l**2 - l)\n        if m&lt;0:\n            i = 1\n        else:\n            i = 0\n        newcoeffs[i, l, np.abs(m)] = coeffs[acn]\n    coeffs = newcoeffs\n    return coeffs\n</code></pre>"},{"location":"reference/audio_tools.html#src.prepost.audio_tools.spharm_acn","title":"<code>spharm_acn(lmax, theta, phi, **kwargs)</code>","text":"<p>Returns the :math:<code>4\\pi</code>-normalized real spherical harmonic of degree <code>l</code>  and order <code>m</code> in the ACN ordering.</p>"},{"location":"reference/audio_tools.html#src.prepost.audio_tools.spharm_acn--returns","title":"Returns","text":"<p>y : float     The spherical harmonic <code>ylm</code> evaluated at argument (<code>theta</code>,      <code>phi</code>).</p>"},{"location":"reference/audio_tools.html#src.prepost.audio_tools.spharm_acn--parameters","title":"Parameters","text":"<p>l : integer     The spherical harmonic order. theta : float     The colatitude angle in degree. phi : float     The azimuth angle in degree.</p>"},{"location":"reference/audio_tools.html#src.prepost.audio_tools.spharm_acn--description","title":"Description","text":"<p>The :math:<code>4\\pi</code>-normalized real spherical harmonic of degree l and order m is defiened as follows:</p> <p>.. math ::     \begin{equation}     Y_{lm}( heta,\u000barphi) = \\sqrt{(2l+1)(2 - \\delta(m))      \frac{(l-|m|)!}{(l+|m|)!}}      \\left \\lbrace \begin{array}{ll} P_{lm}     (\\sin(\u000barphi)) \\cos (m  heta) &amp; \\mbox{if \\(m \\ge 0\\)} \\     P_{l|m|}(\\sin (\u000barphi)) \\sin (|m|       heta) &amp; \\mbox{if \\(m &lt; 0\\)},     \\end{array}  ight.     \\end{equation}</p> <p>where :math:<code>P_{lm}</code> is the associated Legendre polynomial of degree :math:<code>l</code> and order :math:<code>m</code>.</p> Source code in <code>src/prepost/audio_tools.py</code> <pre><code>def spharm_acn(lmax, theta, phi, **kwargs):\n    \"\"\"\n    Returns the :math:`4\\pi`-normalized real spherical harmonic of degree ``l`` \n    and order ``m`` in the ACN ordering.\n\n    Returns\n    -------\n    y : float\n        The spherical harmonic ``ylm`` evaluated at argument (``theta``, \n        ``phi``).\n\n    Parameters\n    ----------\n    l : integer\n        The spherical harmonic order.\n    theta : float\n        The colatitude angle in degree.\n    phi : float\n        The azimuth angle in degree.\n\n    Description\n    -----------\n    The :math:`4\\pi`-normalized real spherical harmonic of degree l and order m\n    is defiened as follows:\n\n    .. math ::\n        \\begin{equation}\n        Y_{lm}(\\theta,\\varphi) = \\sqrt{(2l+1)(2 - \\delta(m)) \n        \\frac{(l-|m|)!}{(l+|m|)!}} \n        \\left \\lbrace \\begin{array}{ll} P_{lm}\n        (\\sin(\\varphi)) \\cos (m \\theta) &amp; \\mbox{if $m \\ge 0$} \\\\\n        P_{l|m|}(\\sin (\\varphi)) \\sin (|m| \\theta) &amp; \\mbox{if $m &lt; 0$},\n        \\end{array} \\right.\n        \\end{equation}\n\n    where :math:`P_{lm}` is the associated Legendre polynomial of degree\n    :math:`l` and order :math:`m`.\n    \"\"\"\n    Ylm = pyshtools.expand.spharm(lmax, theta, phi, **kwargs)\n    Yacn = lm2acn(Ylm)\n    return Yacn\n</code></pre>"},{"location":"reference/audio_tools.html#src.prepost.audio_tools.encoder","title":"<code>encoder(sound, lmax, theta, phi, src='plane')</code>","text":"<p>Return encoded sound file.</p>"},{"location":"reference/audio_tools.html#src.prepost.audio_tools.encoder--returns","title":"Returns","text":"<p>blm : 2-D array     (lmax+1)**2 by sound.shape[0] matrix</p>"},{"location":"reference/audio_tools.html#src.prepost.audio_tools.encoder--parameters","title":"Parameters","text":"<p>sound : array     The sound file to convolve lmax : int     The ambisonic order theta : float     The colatitude angle of the source phi : float     the azimuthal angle of the source src : string, default='plane'     The type of source to consider for encoding. Should be 'plane or 'monopole'.</p>"},{"location":"reference/audio_tools.html#src.prepost.audio_tools.encoder--description","title":"Description","text":"Source code in <code>src/prepost/audio_tools.py</code> <pre><code>def encoder(sound, lmax, theta, phi, src='plane'):\n\n    \"\"\"Return encoded sound file.\n\n    Returns\n    -------\n    blm : 2-D array\n        (lmax+1)**2 by sound.shape[0] matrix\n\n    Parameters\n    ----------\n    sound : array\n        The sound file to convolve\n    lmax : int\n        The ambisonic order\n    theta : float\n        The colatitude angle of the source\n    phi : float\n        the azimuthal angle of the source\n    src : string, default='plane'\n        The type of source to consider for encoding. Should be 'plane or 'monopole'.\n\n    Description\n    -----------\n\n    \"\"\"\n    # Get the spherical harmonic coefficients at the given angles\n    ylm = spharm_acn(lmax, theta, phi)\n\n    if src=='plane':\n        # Encoding the source signal\n        blm = np.tile(sound, ((lmax+1)**2,1)).T * ylm\n\n        return blm.T\n\n    elif src=='monopole':\n        print('Sorry, not implemented yet ...')\n\n    elif (src != 'plane' != 'monopole'):\n        raise ValueError('src must be plane or monopole')\n</code></pre>"},{"location":"reference/audio_tools.html#src.prepost.audio_tools.decoder","title":"<code>decoder(blm, lmax, spkr=None, method='mode_matching', src='plane')</code>","text":"<p>Return decoded sound file.</p>"},{"location":"reference/audio_tools.html#src.prepost.audio_tools.decoder--returns","title":"Returns","text":"<p>w : 2-D array     spkr.shape[0] by sound.shape[0] matrix</p>"},{"location":"reference/audio_tools.html#src.prepost.audio_tools.decoder--parameters","title":"Parameters","text":"<p>blm : array     The encoded sound file lmax : int     The ambisonic order (lmax &gt; 0) spkr : array, default=None     The N loudspeaker positions in cartesian coordinates (N,3). If None, the loudspeaker configuration from LMFA is used. method : string, default='mode_matching'     Deconding method. Should be 'mode_matching' src : string, default='plane'     The type of source to consider for encoding. Should be 'plane or 'monopole'.</p>"},{"location":"reference/audio_tools.html#src.prepost.audio_tools.decoder--description","title":"Description","text":"Source code in <code>src/prepost/audio_tools.py</code> <pre><code>def decoder(blm, lmax, spkr=None, method='mode_matching', src='plane'):\n\n    \"\"\"Return decoded sound file.\n\n    Returns\n    -------\n    w : 2-D array\n        spkr.shape[0] by sound.shape[0] matrix\n\n    Parameters\n    ----------\n    blm : array\n        The encoded sound file\n    lmax : int\n        The ambisonic order (lmax &gt; 0)\n    spkr : array, default=None\n        The N loudspeaker positions in cartesian coordinates (N,3). If None, the loudspeaker configuration from LMFA is used.\n    method : string, default='mode_matching'\n        Deconding method. Should be 'mode_matching'\n    src : string, default='plane'\n        The type of source to consider for encoding. Should be 'plane or 'monopole'.\n\n    Description\n    -----------\n\n    \"\"\"\n\n    if spkr is None:\n        spkr = lmfa_xyz_spkr()\n\n    # Get spherical coordinates of loudspeakers (no need for r values)\n    _, th_spkr, ph_spkr = cart2sph(spkr[:,0], spkr[:,1], spkr[:,2])\n\n    if method=='mode_matching':\n\n        C = np.zeros(shape=((lmax + 1)**2, spkr.shape[0]))\n\n        if src=='plane':\n\n            # Spherical harmonic coefficients of the loudspeakers\n            for spkr_count in range(spkr.shape[0]):       \n                C[:, spkr_count] = spharm_acn(lmax, th_spkr[spkr_count], ph_spkr[spkr_count])\n\n            # Matrix pseudo inverse to obtain the decoding matrix\n            d = np.linalg.pinv(C, rcond=1/100)\n            # Calculate the loudspeaker signals from the target SH sound field\n            w = d@blm\n\n            return w\n\n        elif src=='monopole' :\n\n            print('Sorry, not implemented yet')\n\n        elif (src != 'plane' != 'monopole'):\n            raise ValueError('src must be plane or monopole')\n</code></pre>"},{"location":"reference/auralization.html","title":"Reference for <code>prepost/auralization.py</code>","text":""},{"location":"reference/auralization.html#src.prepost.auralization.cart2sph","title":"<code>cart2sph(x, y, z, degree=True)</code>","text":"Source code in <code>src/prepost/auralization.py</code> <pre><code>def cart2sph(x, y, z, degree=True):\n    x, y, z = np.array(x), np.array(y), np.array(z)\n    r, theta, phi = np.zeros(x.shape), np.zeros(x.shape), np.zeros(x.shape)\n    r = np.sqrt(x**2 + y**2 + z**2)  # Radius\n    theta = np.arctan2(np.sqrt(x**2 + y**2), z)  # Azimuth\n    phi = np.arctan2(y, x)  # Colatitude\n    return r, theta, phi\n</code></pre>"},{"location":"reference/auralization.html#src.prepost.auralization.decode_room","title":"<code>decode_room(signal)</code>","text":"Source code in <code>src/prepost/auralization.py</code> <pre><code>def decode_room(signal: np.ndarray):\n    print('decoding room ...')\n    L = 3\n    signal_listening_room = audio_tools.decoder(signal, lmax=L)\n    return signal_listening_room\n</code></pre>"},{"location":"reference/auralization.html#src.prepost.auralization.decode_bin","title":"<code>decode_bin(signal)</code>","text":"Source code in <code>src/prepost/auralization.py</code> <pre><code>def decode_bin(signal: np.ndarray):\n    L = 3\n    signal_bin = audio_tools.decoder_binaural(signal, lmax=L)\n    return signal_bin\n</code></pre>"},{"location":"reference/auralization.html#src.prepost.auralization.decode","title":"<code>decode(signal, lmax=3)</code>","text":"Source code in <code>src/prepost/auralization.py</code> <pre><code>def decode(signal: np.ndarray,lmax=3):\n    print('decoding ...')\n    N = signal.shape[1]\n    fs = SAMPLING\n    signal_listening_room = audio_tools.decoder(signal, lmax=lmax)\n    # Get speakers configuration\n    spkr = audio_tools.lmfa_xyz_spkr()\n    _, th_spkr, ph_spkr = audio_tools.cart2sph(\n        spkr[:, 0], spkr[:, 1], spkr[:, 2])\n\n    # Initialize binaural stereo sound file\n    signal_binaural = np.zeros((N, 2))\n    # Sum the binaural signals from each loudspeaker\n    for i_spkr in range(spkr.shape[0]):\n        # Retrieve IRs from sofa file\n        ir_l, ir_r = audio_tools.get_hrir(th_spkr[i_spkr], ph_spkr[i_spkr])\n        # Convolve noise with IRs\n        signal_binaural += audio_tools.binaural(\n            signal_listening_room[i_spkr, :], ir_l, ir_r)\n\n    # Normalization\n    signal_binaural /= signal_binaural.max()\n\n    return signal_listening_room, signal_binaural\n</code></pre>"},{"location":"reference/auralization.html#src.prepost.auralization.interpolate_frequency","title":"<code>interpolate_frequency(f0, s0, nsamples, sampling=44100)</code>","text":"Source code in <code>src/prepost/auralization.py</code> <pre><code>def interpolate_frequency(f0: np.ndarray, s0: np.ndarray, nsamples: int, sampling=44100):\n    dt = 1/sampling\n    f1 = rfftfreq(nsamples, dt)\n    interpoland = interp1d(f0, s0, 'linear', bounds_error=False, fill_value=0)\n    s1 = interpoland(f1)\n    return f1, s1\n</code></pre>"},{"location":"reference/auralization.html#src.prepost.auralization.compute_rec_angles","title":"<code>compute_rec_angles(splField)</code>","text":"Source code in <code>src/prepost/auralization.py</code> <pre><code>def compute_rec_angles(splField: SplField):\n    x = splField.x_grid[:, 0, 0].reshape(-1, 1, 1, 1, 1, 1)\n    y = splField.y_grid[0, :, 0].reshape(1, -1, 1, 1, 1, 1)\n    z = splField.z_grid[0, 0, :].reshape(1, 1, -1, 1, 1, 1)\n\n    splField.wt.computeBeta()\n    beta = splField.wt.beta.reshape(\n        1, 1, 1, 1, splField.wt.Nblade, splField.wt.Nbeta)\n\n    if splField.FULL_ROTATION:\n        beta = np.concatenate((beta, beta+2*np.pi/3, beta+4*np.pi/3), axis=5)\n\n    seg = splField.wt.seg.reshape(1, 1, 1, splField.wt.Nseg, 1, 1)\n\n    # compute segment location\n    zS = (np.cos(beta) * seg + splField.wt.href)\n    xS = -np.sin(beta) * seg * np.sin(splField.wt.tau) + splField.xS\n    yS = -np.sin(beta) * seg * np.cos(splField.wt.tau) + splField.yS\n    # compute distance between source and receiver\n\n    r, theta, phi = cart2sph((x-xS), (y-yS), (zS-z))\n    return r, theta, phi\n</code></pre>"},{"location":"reference/auralization.html#src.prepost.auralization.compute_receiver_time","title":"<code>compute_receiver_time(splField)</code>","text":"Source code in <code>src/prepost/auralization.py</code> <pre><code>def compute_receiver_time(splField: SplField):\n    print('compute receiver time ...')\n    c0 = 343\n    # (nx,ny,nz,src.wt.Nseg,src.wt.Nblade,len(freq),src.Nbeta)\n    x = splField.x_grid[:, 0, 0].reshape(-1, 1, 1, 1, 1, 1)\n    y = splField.y_grid[0, :, 0].reshape(1, -1, 1, 1, 1, 1)\n    z = splField.z_grid[0, 0, :].reshape(1, 1, -1, 1, 1, 1)\n\n    splField.wt.computeBeta()\n    beta = splField.wt.beta.reshape(\n        1, 1, 1, 1, splField.wt.Nblade, splField.wt.Nbeta)\n    beta = np.concatenate((beta, beta+2*np.pi/3, beta+4*np.pi/3), axis=5)\n    seg = splField.wt.seg.reshape(1, 1, 1, splField.wt.Nseg, 1, 1)\n\n    # compute segment location\n    # modif source :\n    zS = (np.cos(beta) * seg + splField.wt.href)\n    xS = -np.sin(beta) * seg * np.sin(splField.wt.tau) + splField.xS\n    yS = -np.sin(beta) * seg * np.cos(splField.wt.tau) + splField.yS\n\n    # compute distance between source and receiver\n    R = np.sqrt((x - xS)**2 + (y - yS)**2 + (z - zS)**2)\n\n    # absolute time of signal reception\n    splField.t = R/c0 + beta[:, :, :, :, 0,\n                             :].reshape(1, 1, 1, 1, 1, -1)/splField.wt.omega\n\n    # copy first angle at the end\n    splField.t = np.concatenate(\n        (splField.t, splField.t[..., 0:1]+2*np.pi/splField.wt.omega), 5)\n    print('done.')\n</code></pre>"},{"location":"reference/auralization.html#src.prepost.auralization.convert_freq_to_time","title":"<code>convert_freq_to_time(f0, s0, nsamples)</code>","text":"Source code in <code>src/prepost/auralization.py</code> <pre><code>def convert_freq_to_time(f0: np.ndarray, s0: np.ndarray, nsamples: int):\n    frequencies, spp = interpolate_frequency(f0, s0, nsamples)\n    phase = np.random.rand(len(frequencies))*2*np.pi\n    spectrum = np.sqrt(spp)*np.exp(1j*phase)\n    # print(spectrum)\n    signal = irfft(spectrum)\n    return signal\n</code></pre>"},{"location":"reference/auralization.html#src.prepost.auralization.freq_to_time","title":"<code>freq_to_time(splField, x, y, z, sampling=44100, lmax=3)</code>","text":"Source code in <code>src/prepost/auralization.py</code> <pre><code>def freq_to_time(splField: SplField, x: float, y: float, z: float,\n                 sampling=44100, lmax=3):\n    Nsph = (lmax + 1)**2\n    ix = np.argmin(np.abs(splField.x_grid[:, 0, 0]-x))\n    iy = np.argmin(np.abs(splField.y_grid[0, :, 0]-y))\n    iz = np.argmin(np.abs(splField.z_grid[0, 0, :]-z))\n\n    # compute angle between source and receiver\n    r, theta_rad, phi_rad = compute_rec_angles(splField)\n    splField.compute_real_receiver_time(loop=False, last=True)\n\n    print('compute time signal  ...')\n    if splField.third:\n        print('signal in third octave not possible to process.')\n        quit()\n    spp = 10**(splField.SPL_seg[ix, iy, iz, :, :, :, :]/10)*2e-5\n\n    r = r[ix, iy, iz, :, :, :]\n    theta = theta_rad[ix, iy, iz, :, :, :] * 180 / np.pi\n    phi = phi_rad[ix, iy, 0, :, :, :] * 180 / np.pi\n    t = splField.t[ix, iy, iz, :, :, :]\n\n    t = t - np.min(t)\n    T = 2*np.pi/(splField.wt.omega)\n\n    nsamples_tot = int(T*sampling)\n\n    temp_signal = np.zeros((nsamples_tot))\n    temp_signal_sph = np.zeros((Nsph, nsamples_tot))\n\n    it = 0\n    overlap = 20\n    alpha = 0.1\n    for iblade in range(spp.shape[1]):\n        # for iblade in range(1):\n        for iseg in range(spp.shape[0]):\n            it = int(t[iseg, iblade, 0]*sampling)\n            for ibeta in range(0, spp.shape[3]):\n                deltaT = (t[iseg, iblade, ibeta+1]-t[iseg, iblade, ibeta])\n                nsamples = int(sampling*deltaT) + 2*overlap\n                i0 = it - overlap\n                iend = it + overlap + int(deltaT*sampling)\n                indices = np.arange(i0, iend, 1) % nsamples_tot\n                # print(spp[iseg,iblade,:,ibeta])\n                si = convert_freq_to_time(splField.frequencies,\n                                          spp[iseg, iblade, :, ibeta],\n                                          nsamples+1)\n\n                si_sph = audio_tools.encoder(si, lmax,\n                                             theta[iseg, iblade, ibeta],\n                                             phi[iseg, iblade, ibeta])\n\n                window = tukey(nsamples, alpha)\n                temp_signal[indices] = si[:nsamples] * \\\n                    window + temp_signal[indices]\n                temp_signal_sph[:, indices] = si_sph[:, :nsamples] * \\\n                    window[None, :] + temp_signal_sph[:, indices]\n                it = it+int(deltaT*sampling)\n\n    # temp_signal = 0.8*temp_signal/np.max(temp_signal)\n    # temp_signal_sph = 0.8*temp_signal_sph/np.max(temp_signal_sph)\n    print(temp_signal_sph.shape)\n\n    return temp_signal_sph\n</code></pre>"},{"location":"reference/auralization.html#src.prepost.auralization.freq_to_spherical","title":"<code>freq_to_spherical(splField, x, y, z, lmax=3, sampling=44100)</code>","text":"Source code in <code>src/prepost/auralization.py</code> <pre><code>def freq_to_spherical(splField: SplField, x: float, y: float, z: float, lmax: float = 3, sampling=44100):\n    Nsph = (lmax + 1)**2\n    ix = np.argmin(np.abs(splField.x_grid[:, 0, 0]-x))\n    iy = np.argmin(np.abs(splField.y_grid[0, :, 0]-y))\n    iz = np.argmin(np.abs(splField.z_grid[0, 0, :]-z))\n\n    # compute angle between source and receiver\n\n    r, theta_rad, phi_rad = compute_rec_angles(splField)\n    splField.compute_real_receiver_time(loop=True, last=True)\n    # splField.compute_real_receiver_time(loop=False, last=True)\n\n    print('compute time signal  ...')\n    fc = [50, 63, 80, 100, 125, 160, 200, 250, 315, 400, 500, 630, 800, 1000]\n    Nfc = [1,  1,  1,   1,   1,  1,   2,   2,   3,   4,   4,   4,   5,  5]\n    splField.compute_third_octave(fc, Nfc)\n\n    spp = np.sum(10**(splField.SPL_seg[ix, iy, iz, :, :, :, :]/10)*4e-10,\n                 axis=2)\n\n    # spp = spp\n    r = r[ix, iy, iz, :, :, :]\n    theta = theta_rad[ix, iy, iz, :, :, :] * 180 / np.pi\n    phi = phi_rad[ix, iy, 0, :, :, :] * 180 / np.pi\n    t = splField.t[ix, iy, iz, :, :, :]\n\n    print(theta.shape)\n    # plt.plot(theta[0, 1, :])\n    # plt.plot(theta[0, 2, :])\n    # plt.figure()\n    # plt.plot(phi[0, 0, :])\n    # plt.plot(phi[0,1,:])\n    # plt.plot(phi[0,2,:])\n    # plt.show()\n    # quit()\n\n    T = 2*np.pi/(splField.wt.omega)\n    nsamples_tot = int(T*sampling)\n    temp_signal_sph = np.zeros((Nsph, nsamples_tot))\n\n    it = 0\n    overlap = 0\n    alpha = 0.1\n    print(\"test\")\n    print(spp.shape[1])\n    for iblade in range(spp.shape[1]):\n        # for iblade in range(1):\n        for iseg in range(spp.shape[0]):\n            t0 = t[iseg, iblade, 0]\n            i_first = int((t0 % T) * sampling)\n            it = i_first\n            # it = int(t[iseg, iblade, 0]*sampling)\n            for ibeta in range(0, spp.shape[2]):\n                tend = t[iseg, iblade, ibeta+1]\n                iend = int((tend % T) * sampling)\n                if iend &gt; it:\n                    indices = np.arange(it, iend, 1)\n                else:\n                    indices = np.concatenate([np.arange(it, nsamples_tot, 1),\n                                               np.arange(0, iend, 1)], axis=0)\n\n                # deltaT = (t[iseg, iblade, ibeta+1]-t[iseg, iblade, ibeta])\n                # nsamples = int(sampling*deltaT) + 2*overlap\n                # i0 = it - overlap\n                # iend = it + overlap + int(deltaT*sampling)\n                # indices = np.arange(i0, iend, 1) % nsamples_tot\n\n                spl_sph = audio_tools.encoder(spp[iseg, iblade, ibeta],\n                                              lmax, theta[iseg, iblade, ibeta],\n                                              phi[iseg, iblade, ibeta])\n                # window = tukey(nsamples, alpha)\n                # if overlap &gt; 0:\n                #     temp_signal_sph[:, indices] = spl_sph[:, :] * \\\n                #         window[None, :] + temp_signal_sph[:, indices]\n                # else:\n                #    temp_signal_sph[:, indices] = (spl_sph[:, :] +\n                #                                   temp_signal_sph[:, indices])\n                temp_signal_sph[:, indices] = (spl_sph[:, :] +\n                                               temp_signal_sph[:, indices])\n                t0 = tend\n                it = iend\n                # it = it+int(deltaT*sampling)\n\n    # temp_signam_sph = 10*np.log10(temp_signal_sph/2e-5)\n\n    # temp_signal = 0.8*temp_signal/np.max(temp_signal)\n    # temp_signal_sph = 0.8*temp_signal_sph/np.max(temp_signal_sph)\n\n    return temp_signal_sph\n</code></pre>"},{"location":"reference/auralization.html#src.prepost.auralization.normalized_signals","title":"<code>normalized_signals(directory='./')</code>","text":"Source code in <code>src/prepost/auralization.py</code> <pre><code>def normalized_signals(directory: str = './'):\n    max_pressure = 0\n    for file in os.listdir(directory):\n        if file.startswith(\"bin\"):\n            rate, signal_bin = read(directory+file)\n            signal_max = np.max(signal_bin)\n\n            if signal_max &gt; max_pressure:\n                max_pressure = signal_max\n\n    for file in os.listdir(directory):\n        if file.startswith(\"bin\"):\n            rate, signal_bin = read(directory+file)\n            signal_bin = signal_bin/max_pressure\n            write(directory+file, rate, signal_bin)\n    print(max_pressure)\n    max_pressure = 0\n    for file in os.listdir(directory):\n        if file.startswith(\"multi\"):\n            rate, signal_multi = read(directory+file)\n            signal_max = np.max(signal_multi)\n            if signal_max &gt; max_pressure:\n                max_pressure = signal_max\n    print(max_pressure)\n    # quit()\n    for file in os.listdir(directory):\n        if file.startswith(\"multi\"):\n            rate, signal_multi = read(directory+file)\n            signal_multi = signal_multi/max_pressure\n            write(directory+file, rate, signal_multi)\n</code></pre>"},{"location":"reference/auralization.html#src.prepost.auralization.combine_turbines","title":"<code>combine_turbines(directory, length_s=10)</code>","text":"Source code in <code>src/prepost/auralization.py</code> <pre><code>def combine_turbines(directory, length_s=10):\n\n    coordinates = []\n    turbines = []\n    for file in os.listdir(directory):\n        data = file.split('_')\n        coordinates.append((int(data[2]), int(data[3][:-4])))\n        turbines.append((data[1]))\n    coordinates = list(dict.fromkeys(coordinates))\n    turbines = list(dict.fromkeys(turbines))\n    if 'sum' in turbines:\n        turbines.remove('sum')\n    print(turbines)\n\n    nsamples = 44100*length_s\n    for (x, y) in coordinates:\n        signal = np.zeros((nsamples, 16))\n        for t in turbines:\n            print('multi_%s_%s_%s.wav' % (t, x, y))\n            rate, signal_i = read(directory + 'multi_%s_%s_%s.wav' % (t, x, y))\n            nsamples_i = signal_i.shape[0]\n            print(nsamples_i)\n            n = nsamples//nsamples_i\n            r = nsamples % nsamples_i\n            for ii in range(n):\n                signal[ii*nsamples_i:(ii+1)*nsamples_i, :] += signal_i\n            signal[n*nsamples_i:, :] += signal_i[:r, :]\n\n        write(directory + 'multi_sum_%s_%s.wav' % (x, y), rate, signal)\n</code></pre>"},{"location":"reference/auralization.html#src.prepost.auralization.decode_room","title":"<code>decode_room(signal)</code>","text":"Source code in <code>src/prepost/auralization.py</code> <pre><code>def decode_room(signal: np.ndarray):\n    print('decoding room ...')\n    L = 3\n    signal_listening_room = audio_tools.decoder(signal, lmax=L)\n    return signal_listening_room\n</code></pre>"},{"location":"reference/auralization.html#src.prepost.auralization.decode_bin_multi","title":"<code>decode_bin_multi(directory)</code>","text":"Source code in <code>src/prepost/auralization.py</code> <pre><code>def decode_bin_multi(directory):\n    L = 3\n    for file in os.listdir(directory):\n        if file.startswith(\"multi\"):\n            rate, signal = read(directory + file)\n            print(signal.shape)\n            signal_bin = audio_tools.decoder_binaural(signal.T, lmax=L)\n            print(signal_bin.shape)\n            write(directory + 'bin' + file[5:], rate, signal_bin)\n</code></pre>"},{"location":"reference/combine.html","title":"Reference for <code>prepost/combine.py</code>","text":""},{"location":"reference/combine.html#src.prepost.combine.combine","title":"<code>combine(src, field, fc, Nfc)</code>","text":"Source code in <code>src/prepost/combine.py</code> <pre><code>def combine(src,field,fc,Nfc):\n    # 2D OASPL computation\n    #---------------------------------------------------------------------------\n    print('combining ...')\n    proximity = src.wt.proximity(field.height)\n    # src.wt.plotProximity(proximity)\n    # print(proximity[:,6])\n    shape_Spp = src.Spp[...,0,0,0].shape\n    shape_deltaL = field.deltaL[...,0,0].shape\n    if shape_deltaL != shape_Spp :\n        print('Spp and delta L must be of same size')\n        print(shape_deltaL)\n        print(shape_Spp)\n        quit()\n    if len(shape_Spp)==2 :\n        (nx,nz) = shape_Spp\n        adDim = 1\n    elif len(shape_Spp)==1 :\n        (nx,) = shape_Spp\n        nz = 1\n        adDim = 0\n    else :\n        print('space dimension not handle bny the actual code ')\n        quit()\n\n    final_OASPL_time = np.zeros(np.shape(src.Spp[...,0,0,:]))\n    final_OASPL_A_time = np.zeros(np.shape(src.Spp[...,0,0,:]))\n    final_SPL_freq_time =  np.zeros(np.shape(src.Spp[...,0,:,:]))\n    final_SPL_seg_freq_time =  np.zeros(np.shape(src.Spp))\n    final_SPL_freq_third_time = np.zeros(np.shape(src.Spp[...,0,0,0]) + (len(fc), src.wt.Nbeta))\n\n    for ibeta in np.arange(0,src.wt.Nbeta):\n        print('ibeta = ' + str(ibeta))\n        # create coresponding matrix for Spp and Delta L fo onre angle \n        #---------------------------------------------------------------------------------------------------\n        SPL_tot_ff = src.Spp[..., ibeta]\n        delta_L = np.zeros_like(SPL_tot_ff)\n        for iseg in range(src.wt.Nblade*src.wt.Nseg):\n            print('iseg = ' + str(iseg) )\n            print('delta L index : ' + str(proximity[iseg,ibeta]))\n            print(delta_L.shape)\n            delta_L[...,iseg, :] = field.deltaL[..., proximity[iseg,ibeta]]\n        t0 = time.time()\n\n        #   sum Spp and Delta L\n        #--------------------------------------------------------------------------------------------------\n        SPL_seg_freq = SPL_tot_ff + delta_L \n        final_SPL_seg_freq_time[...,ibeta] = SPL_seg_freq\n        t_combine = time.time()\n        pp_seg_freq = 10 ** (SPL_seg_freq / 10) * 4e-10\n        print('combine in : ' + str(t_combine - t0) + 's.')\n\n        # Compute third octave band\n        #------------------------------------------------------------------------------------------------\n        SPL_seg_freq_third = np.zeros(np.shape(src.Spp[...,0,0]) + (len(fc),))\n        for ifreq in range(len(Nfc)):\n            temp_array = 10*np.log10(fc[ifreq]*0.232/Nfc[ifreq]* np.sum(10 ** (SPL_seg_freq[..., int(np.sum(Nfc[0:ifreq])):int(np.sum(Nfc[0:ifreq+1]))]/10), axis=len(SPL_seg_freq.shape)-1))\n            # temp_array[temp_array == -inf] = 0\n            SPL_seg_freq_third[..., ifreq] = temp_array\n        pp_seg_freq_third = 10 ** (SPL_seg_freq_third / 10) * 4e-10\n\n        # compute sum over segments\n        #--------------------------------------------------------------------------------------------------\n        pp_freq = np.sum(pp_seg_freq.reshape(nx*nz,src.Nseg*src.Nblade,src.Nfreq), axis = 1)\n        SPL_freq = np.squeeze(10 * np.log10(pp_freq / 4e-10).reshape(nx,nz,src.Nfreq))\n\n        pp_freq_third = np.sum(pp_seg_freq_third.reshape(nx*nz,src.Nseg*src.Nblade,len(Nfc)), axis = 1)\n        SPL_freq_third = np.squeeze(10 * np.log10(pp_freq_third/ 4e-10))\n        t_sseg = time.time()\n        print('sum over segments in ' + str(t_sseg - t_combine) + 's.')\n\n        # absorpiton atmospherique \n        #-----------------------------------------------------------------------------------------------\n        R = np.sqrt((np.squeeze(field.x_grid))**2 + (np.squeeze(field.z_grid)- src.wt.href)**2)\n        c0 =343 \n        rGP = 287.06;\n        rho0 = 1.2# masse volumique de l'air au sol\n        gamma = 1.4# constante adiabatique\n\n        rh = 80# humidite relative (%)\n        p0 = rho0*c0**2/gamma# pression atmospherique\n        T0 = c0**2/(gamma*rGP)# t\n        alpha = atm_absorption(T0,p0,rh\n        ,fc).reshape(1,-1)*R.reshape(nx*nz,-1)\n        SPL_freq_third = SPL_freq_third - alpha \n\n\n        # compute OASPL and OASPL_A\n        #----------------------------------------------------------------------------------------------\n        freq = computeThirdOctaveFrequencies(fc,Nfc)\n        aweight = Aweight(fc).reshape(1,-1)\n\n        OASPL_A = 10*np.log10(np.squeeze(np.sum(10**((SPL_freq_third+aweight)/10),axis = 1)))\n        OASPL = 10*np.log10(np.squeeze(np.sum(10**(SPL_freq_third/10),axis = 1)))\n        # if adDim == 0 : \n        OASPL_A = np.squeeze(OASPL_A.reshape(nx,nz))\n        OASPL = np.squeeze(OASPL.reshape(nx,nz))\n        SPL_freq_third = np.squeeze(SPL_freq_third.reshape(nx,nz,len(fc)))\n        SPL_freq = np.squeeze(SPL_freq.reshape(nx,nz,len(freq)))\n\n        t_sfreq = time.time()\n        print('sum over frequency in ' + str(t_sfreq - t_sseg) + 's.')\n\n        # save value \n        #-------------------------------------------------------------------------------------------------\n        final_OASPL_time[..., ibeta] = OASPL\n        final_OASPL_A_time[..., ibeta] = OASPL_A\n        final_SPL_freq_time[..., ibeta] = SPL_freq\n        final_SPL_freq_third_time[...,ibeta] = SPL_freq_third\n        t_copy = time.time()\n        print('copying in  ' + str(t_copy - t_sfreq) + 's.')\n    final_SPL_seg_freq_time = final_SPL_seg_freq_time.reshape(nx,nz,src.Nseg,src.Nblade,len(freq),src.Nbeta)\n    return final_SPL_freq_time, final_OASPL_time, final_OASPL_A_time\n</code></pre>"},{"location":"reference/combine.html#src.prepost.combine.combine_linear","title":"<code>combine_linear(src, field, fc, Nfc)</code>","text":"Source code in <code>src/prepost/combine.py</code> <pre><code>def combine_linear(src,field,fc,Nfc):\n    # 2D OASPL computation\n    #---------------------------------------------------------------------------\n    print('combining ...')\n    proximity = src.wt.proximityLinear(field.height)\n    # src.wt.plotProximity(proximity)\n    # print(proximity[:,6])\n    shape_Spp = src.SppInterpolated[...,0,0,0].shape\n    shape_deltaL = field.deltaLInterpolated[...,0,0].shape\n    if shape_deltaL != shape_Spp :\n        print('Spp and delta L must be of same size')\n        print(shape_deltaL)\n        print(shape_Spp)\n        quit()\n    if len(shape_Spp)==2 :\n        (nx,nz) = shape_Spp\n        adDim = 1\n    elif len(shape_Spp)==1 :\n        (nx,) = shape_Spp\n        nz = 1\n        adDim = 0\n    else :\n        print('space dimension not handle bny the actual code ')\n        quit()\n\n    final_OASPL_time = np.zeros(np.shape(src.SppInterpolated[...,0,0,:]))\n    final_OASPL_A_time = np.zeros(np.shape(src.SppInterpolated[...,0,0,:]))\n    final_SPL_freq_time =  np.zeros(np.shape(src.SppInterpolated[...,0,:,:]))\n    final_SPL_seg_freq_time =  np.zeros(np.shape(src.SppInterpolated))\n    final_SPL_freq_third_time = np.zeros(np.shape(src.SppInterpolated[...,0,0,0]) + (len(fc), src.wt.Nbeta))\n\n    for ibeta in np.arange(0,src.wt.Nbeta):\n        print('ibeta = ' + str(ibeta))\n        # create coresponding matrix for Spp and Delta L fo one angle \n        #---------------------------------------------------------------------------------------------------\n        SPL_tot_ff = src.SppInterpolated[..., ibeta]\n        delta_L = np.zeros_like(SPL_tot_ff)\n        for iseg in range(src.wt.Nblade*src.wt.Nseg):\n            print('iseg = ' + str(iseg) )\n            print('delta L index : ' + str(proximity[iseg,ibeta,0]) + ',' + str(proximity[iseg,ibeta,1])+','+str(proximity[iseg,ibeta,2]))\n\n            delta_L[...,iseg, :] = 10*np.log10(proximity[iseg,ibeta,2]*10**(field.deltaLInterpolated[..., proximity[iseg,ibeta,0]]/10) + \n                                        (1-proximity[iseg,ibeta,2])*10**(field.deltaLInterpolated[..., proximity[iseg,ibeta,1]]/10))\n        t0 = time.time()\n\n        #   sum Spp and Delta L\n        #--------------------------------------------------------------------------------------------------\n        SPL_seg_freq = SPL_tot_ff + delta_L \n        final_SPL_seg_freq_time[...,ibeta] = SPL_seg_freq\n        t_combine = time.time()\n        pp_seg_freq = 10 ** (SPL_seg_freq / 10) * 4e-10\n        print('combine in : ' + str(t_combine - t0) + 's.')\n\n        # Compute third octave band\n        #------------------------------------------------------------------------------------------------\n        SPL_seg_freq_third = np.zeros(np.shape(src.Spp[...,0,0]) + (len(fc),))\n        for ifreq in range(len(Nfc)):\n            temp_array = 10*np.log10(fc[ifreq]*0.232/Nfc[ifreq]* np.sum(10 ** (SPL_seg_freq[..., int(np.sum(Nfc[0:ifreq])):int(np.sum(Nfc[0:ifreq+1]))]/10), axis=len(SPL_seg_freq.shape)-1))\n            # temp_array[temp_array == -inf] = 0\n            SPL_seg_freq_third[..., ifreq] = temp_array\n        pp_seg_freq_third = 10 ** (SPL_seg_freq_third / 10) * 4e-10\n\n        # compute sum over segments\n        #--------------------------------------------------------------------------------------------------\n        pp_freq = np.sum(pp_seg_freq.reshape(nx*nz,src.Nseg*src.Nblade,src.Nfreq), axis = 1)\n        SPL_freq = np.squeeze(10 * np.log10(pp_freq / 4e-10).reshape(nx,nz,src.Nfreq))\n\n        pp_freq_third = np.sum(pp_seg_freq_third.reshape(nx*nz,src.Nseg*src.Nblade,len(Nfc)), axis = 1)\n        SPL_freq_third = np.squeeze(10 * np.log10(pp_freq_third/ 4e-10))\n        t_sseg = time.time()\n        print('sum over segments in ' + str(t_sseg - t_combine) + 's.')\n\n        # absorpiton atmospherique \n        #-----------------------------------------------------------------------------------------------\n        R = np.sqrt((np.squeeze(field.x_grid))**2 + (np.squeeze(field.z_grid)- src.wt.href)**2)\n        c0 =343 \n        rGP = 287.06;\n        rho0 = 1.2# masse volumique de l'air au sol\n        gamma = 1.4# constante adiabatique\n\n        rh = 80# humidite relative (%)\n        p0 = rho0*c0**2/gamma# pression atmospherique\n        T0 = c0**2/(gamma*rGP)# t\n        alpha = atm_absorption(T0,p0,rh,fc).reshape(1,-1)*R.reshape(nx*nz,-1)\n        SPL_freq_third = SPL_freq_third - alpha \n\n\n        # compute OASPL and OASPL_A\n        #----------------------------------------------------------------------------------------------\n        freq = computeThirdOctaveFrequencies(fc,Nfc)\n        aweight = Aweight(fc).reshape(1,-1)\n\n        OASPL_A = 10*np.log10(np.squeeze(np.sum(10**((SPL_freq_third+aweight)/10),axis = 1)))\n        OASPL = 10*np.log10(np.squeeze(np.sum(10**(SPL_freq_third/10),axis = 1)))\n        # if adDim == 0 : \n        OASPL_A = np.squeeze(OASPL_A.reshape(nx,nz))\n        OASPL = np.squeeze(OASPL.reshape(nx,nz))\n        SPL_freq_third = np.squeeze(SPL_freq_third.reshape(nx,nz,len(fc)))\n        SPL_freq = np.squeeze(SPL_freq.reshape(nx,nz,len(freq)))\n\n        t_sfreq = time.time()\n        print('sum over frequency in ' + str(t_sfreq - t_sseg) + 's.')\n\n        # save value \n        #-------------------------------------------------------------------------------------------------\n        final_OASPL_time[..., ibeta] = OASPL\n        final_OASPL_A_time[..., ibeta] = OASPL_A\n        final_SPL_freq_time[..., ibeta] = SPL_freq\n        final_SPL_freq_third_time[...,ibeta] = SPL_freq_third\n        t_copy = time.time()\n        print('copying in  ' + str(t_copy - t_sfreq) + 's.')\n    final_SPL_seg_freq_time = final_SPL_seg_freq_time.reshape(nx,nz,src.Nseg,src.Nblade,len(freq),src.Nbeta)\n    return final_SPL_freq_time, final_OASPL_time, final_OASPL_A_time\n</code></pre>"},{"location":"reference/combine.html#src.prepost.combine.combine_linear_broadband","title":"<code>combine_linear_broadband(src, field, freq)</code>","text":"Source code in <code>src/prepost/combine.py</code> <pre><code>def combine_linear_broadband(src,field,freq):\n    # 2D OASPL computation\n    #---------------------------------------------------------------------------\n    print('combining ...')\n    proximity = src.wt.proximityLinear(field.height)\n    # src.wt.plotProximity(proximity)\n    # print(proximity[:,6])\n    shape_Spp = src.SppInterpolated[...,0,0,0].shape\n    shape_deltaL = field.deltaLInterpolated[...,0,0].shape\n    if shape_deltaL != shape_Spp :\n        print('Spp and delta L must be of same size')\n        print(shape_deltaL)\n        print(shape_Spp)\n        quit()\n    if len(shape_Spp)==2 :\n        (nx,nz) = shape_Spp\n        ny=1\n        adDim = 1\n    if len(shape_Spp)==3 :\n        print('test')\n        (nx,ny,nz) = shape_Spp\n        adDim = 1\n    elif len(shape_Spp)==1 :\n        (nx,) = shape_Spp\n        nz=1\n        ny=1\n        adDim = 0\n    else :\n        print('space dimension not handle bny the actual code ')\n        quit()\n\n    final_OASPL_time = np.zeros(np.shape(src.SppInterpolated[...,0,0,:]))\n    final_OASPL_A_time = np.zeros(np.shape(src.SppInterpolated[...,0,0,:]))\n    final_SPL_freq_time =  np.zeros(np.shape(src.SppInterpolated[...,0,:,:]))\n    final_SPL_seg_freq_time =  np.zeros(np.shape(src.SppInterpolated))\n    final_SPL_freq_third_time = np.zeros(np.shape(src.SppInterpolated[...,0,0,0]) + (14, src.wt.Nbeta))\n\n    for ibeta in np.arange(0,src.wt.Nbeta):\n        print('ibeta = ' + str(ibeta))\n        # create coresponding matrix for Spp and Delta L fo one angle \n        #---------------------------------------------------------------------------------------------------\n        SPL_tot_ff = src.SppInterpolated[..., ibeta]\n        delta_L = np.zeros_like(SPL_tot_ff)\n        for iseg in range(src.wt.Nblade*src.wt.Nseg):\n            print('iseg = ' + str(iseg) )\n            print('delta L index : ' + str(proximity[iseg,ibeta,0]) + ',' + str(proximity[iseg,ibeta,1])+','+str(proximity[iseg,ibeta,2]))\n\n            delta_L[...,iseg, :] = 10*np.log10(proximity[iseg,ibeta,2]*10**(field.deltaLInterpolated[..., proximity[iseg,ibeta,0]]/10) + \n                                        (1-proximity[iseg,ibeta,2])*10**(field.deltaLInterpolated[..., proximity[iseg,ibeta,1]]/10))\n        t0 = time.time()\n\n        #   sum Spp and Delta L\n        #--------------------------------------------------------------------------------------------------\n        SPL_seg_freq = SPL_tot_ff + delta_L \n        final_SPL_seg_freq_time[...,ibeta] = SPL_seg_freq\n        t_combine = time.time()\n        pp_seg_freq = 10 ** (SPL_seg_freq / 10) * 4e-10\n        print('combine in : ' + str(t_combine - t0) + 's.')\n\n        # Compute third octave band\n        #------------------------------------------------------------------------------------------------\n        # SPL_seg_freq_third = np.zeros(np.shape(src.Spp[...,0,0]) + (len(fc),))\n        fc,pp_seg_freq_third= integrateThirdOctave(freq,10**(SPL_seg_freq/10))\n        # SPL_seg_freq_third = 10*np.log10(pp_seg_freq_third)\n        pp_seg_freq_third = pp_seg_freq_third * 4e-10\n        # for ifreq in range(len(Nfc)):\n        #     temp_array = 10*np.log10(fc[ifreq]*0.232/Nfc[ifreq]* np.sum(10 ** (SPL_seg_freq[..., int(np.sum(Nfc[0:ifreq])):int(np.sum(Nfc[0:ifreq+1]))]/10), axis=len(SPL_seg_freq.shape)-1))\n        #     # temp_array[temp_array == -inf] = 0\n        #     SPL_seg_freq_third[..., ifreq] = temp_array\n        # pp_seg_freq_third = 10 ** (SPL_seg_freq_third / 10) * 4e-10\n\n        # compute sum over segments\n        #--------------------------------------------------------------------------------------------------\n        pp_freq = np.sum(pp_seg_freq.reshape(nx*nz*ny,src.Nseg,src.Nfreq), axis = 1)\n        SPL_freq = np.squeeze(10 * np.log10(pp_freq / 4e-10).reshape(nx,ny,nz,src.Nfreq))\n\n        pp_freq_third = np.sum(pp_seg_freq_third.reshape(nx*nz*ny,src.Nseg,len(fc)), axis = 1)\n        SPL_freq_third = np.squeeze(10 * np.log10(pp_freq_third/ 4e-10))\n        t_sseg = time.time()\n        print('sum over segments in ' + str(t_sseg - t_combine) + 's.')\n\n        # absorpiton atmospherique \n        #-----------------------------------------------------------------------------------------------\n        R = np.sqrt((np.squeeze(field.x_interpolate))**2 + (np.squeeze(field.z_interpolate)- src.wt.href)**2 + np.squeeze(field.y_interpolate)**2)\n        c0 =343 \n        rGP = 287.06;\n        rho0 = 1.2# masse volumique de l'air au sol\n        gamma = 1.4# constante adiabatique\n\n        rh = 80# humidite relative (%)\n        p0 = rho0*c0**2/gamma# pression atmospherique\n        T0 = c0**2/(gamma*rGP)# t\n        alpha = atm_absorption(T0,p0,rh,fc).reshape(1,-1)*R.reshape(nx*nz*ny,-1)\n        SPL_freq_third = SPL_freq_third - alpha \n\n\n        # compute OASPL and OASPL_A\n        #----------------------------------------------------------------------------------------------\n        aweight = Aweight(fc).reshape(1,-1)\n\n        OASPL_A = 10*np.log10(np.squeeze(np.sum(10**((SPL_freq_third+aweight)/10),axis = 1)))\n        OASPL = 10*np.log10(np.squeeze(np.sum(10**(SPL_freq_third/10),axis = 1)))\n        # if adDim == 0 : \n        OASPL_A = np.squeeze(OASPL_A.reshape(nx,ny,nz))\n        OASPL = np.squeeze(OASPL.reshape(nx,ny,nz))\n        SPL_freq_third = np.squeeze(SPL_freq_third.reshape(nx,ny,nz,len(fc)))\n        SPL_freq = np.squeeze(SPL_freq.reshape(nx,ny,nz,len(freq)))\n\n        t_sfreq = time.time()\n        print('sum over frequency in ' + str(t_sfreq - t_sseg) + 's.')\n\n        # save value \n        #-------------------------------------------------------------------------------------------------\n        final_OASPL_time[..., ibeta] = OASPL\n        final_OASPL_A_time[..., ibeta] = OASPL_A\n        final_SPL_freq_time[..., ibeta] = SPL_freq\n        final_SPL_freq_third_time[...,ibeta] = SPL_freq_third\n        t_copy = time.time()\n        print('copying in  ' + str(t_copy - t_sfreq) + 's.')\n    final_SPL_seg_freq_time = final_SPL_seg_freq_time.reshape(nx,ny,nz,src.wt.Nseg,src.wt.Nblade,len(freq),src.Nbeta)\n    return final_SPL_freq_time, final_SPL_freq_third_time, final_OASPL_time, final_OASPL_A_time\n</code></pre>"},{"location":"reference/deltaLfield.html","title":"Reference for <code>prepost/deltaLfield.py</code>","text":""},{"location":"reference/deltaLfield.html#src.prepost.deltaLfield.DeltaLField","title":"<code>DeltaLField(dirname=None, casename=None)</code>","text":"<p>The DeltaLField class is designed to handle and process 2D deltaL fields generated from PE (Parabolic Equation) simulation results.  This class provides functionalities to read, store, and manipulate deltaL data, which represents the sound level difference in decibels (dB) due to various factors such as turbine heights, propagation angles, and frequencies.</p> <p>Key features of the DeltaLField class include:</p> <ul> <li> <p>Data Loading and Saving: The class can load deltaL data from H5 files and save the processed data in a structured format.      It supports both polar and Cartesian coordinate systems.</p> </li> <li> <p>Data Concatenation: It can concatenate deltaL data from multiple simulation results, allowing for a comprehensive analysis      across different heights, angles, and frequencies.</p> </li> <li> <p>Interpolation: The class provides methods to interpolate deltaL data onto new grids, facilitating the analysis and visualization of the data in different coordinate systems.</p> </li> <li> <p>Data Refinement: It includes methods to refine the data grid, improving the resolution of the deltaL field for more detailed analysis.</p> </li> <li> <p>Visualization: The class offers various plotting functions to visualize the deltaL field from different perspectives, such as top views, side views, and directivity plots.</p> </li> </ul> <p>Initializes the DeltaLField class.</p> <p>Parameters:</p> <ul> <li> <code>dirname</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>Directory name. Defaults to None.</p> </li> <li> <code>casename</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>Case name. Defaults to None.</p> </li> </ul> Source code in <code>src/prepost/deltaLfield.py</code> <pre><code>def __init__(self, dirname: str = None, casename: str = None):\n    \"\"\"\n    Initializes the DeltaLField class.\n\n    Args:\n        dirname (str, optional): Directory name. Defaults to None.\n        casename (str, optional): Case name. Defaults to None.\n    \"\"\"\n    self.dirname = dirname\n    self.casename = casename\n    self.height = []\n\n    # variable for top view concatenation\n    self.tau = []\n    self.frequencies = []\n    self.deltaLlist = []\n    self.x_polar = None\n    self.y_polar = None\n    self.deltaL_polar = None\n\n    # variable for plane concatenation\n    self.slice_list = []\n    self.plane_list = []\n    self.plane_xlist = []\n    self.plane_ylist = []\n    self.plane_zlist = []\n\n    # variable for cartesian interpolation\n    self.x_cart = None\n    self.y_cart = None\n    self.z_cart = None\n    self.x_array = None\n    self.y_array = None\n    self.z_array = None\n    self.deltaL_cart = None\n\n    self.hindex = 0\n    self.tauindex = 0\n    if (dirname is not None) and (casename is not None):\n        self.simu = Simu(casename)\n        self.simu.load(dirname + casename + \".dat\")\n</code></pre>"},{"location":"reference/deltaLfield.html#src.prepost.deltaLfield.DeltaLField.save","title":"<code>save(fname)</code>","text":"<p>Saves data in a pickle .dat file. Big matrix are stored in h5 files in order to open only part of the data.</p> <p>Parameters:</p> <ul> <li> <code>fname</code>               (<code>str</code>)           \u2013            <p>File name to save the data.</p> </li> </ul> Source code in <code>src/prepost/deltaLfield.py</code> <pre><code>def save(self,fname: str):\n    \"\"\"\n    Saves data in a pickle .dat file. Big matrix are stored in h5 files in order to open only part of the data.\n\n    Args:\n        fname (str): File name to save the data.\n    \"\"\"\n    print('saving Delta L ...')\n    self.deltaLlist = None\n    self.simu = None\n    with  h5py.File(fname[:-3]+'h5', \"w\") as f:\n        if self.x_polar is not None:\n            f.create_dataset('x_polar', data=self.x_polar)\n            self.x_polar = None\n        if self.y_polar is not None:\n            f.create_dataset('y_polar', data=self.y_polar)\n            self.y_polar = None\n        if self.deltaL_polar is not None:\n            f.create_dataset('deltaL_polar', data=self.deltaL_polar)\n            self.deltaL_polar = None\n\n        if self.x_cart is not None:\n            f.create_dataset('x_cart', data=self.x_cart)\n            self.x_cart = None\n\n        if self.y_cart is not None:\n            f.create_dataset('y_cart', data=self.y_cart)\n            self.y_cart = None\n\n        if self.z_cart is not None:\n            f.create_dataset('z_cart', data=self.z_cart)\n            self.z_cart = None\n\n        if self.deltaL_cart is not None:\n            f.create_dataset('deltaL_cart', data=self.deltaL_cart)\n            self.deltaL_cart = None\n\n        if self.x_array is not None:\n            f.create_dataset('x_array', data=self.x_array)\n            self.x_array = None\n\n        if self.y_array is not None:\n            f.create_dataset('y_array', data=self.y_array)\n            self.y_array= None\n\n        if self.z_array is not None:\n            f.create_dataset('z_array', data=self.z_array)\n            self.z_array= None\n\n    \"\"\"save class as self.name.dat\"\"\"\n    with open(fname,'wb') as file:\n        pickle.dump(self.__dict__,file)\n    print('done.')\n</code></pre>"},{"location":"reference/deltaLfield.html#src.prepost.deltaLfield.DeltaLField.load","title":"<code>load(fname, polar=True, cart=True)</code>","text":"<p>Loads the class from a .dat file using pickle format.</p> <p>Parameters:</p> <ul> <li> <code>fname</code>               (<code>str</code>)           \u2013            <p>File name to load the class.</p> </li> <li> <code>polar</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to load polar data. Defaults to True.</p> </li> <li> <code>cart</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to load cartesian data. Defaults to True.</p> </li> </ul> Source code in <code>src/prepost/deltaLfield.py</code> <pre><code>def load(self, fname: str, polar: bool = True, cart: bool = True):\n    \"\"\"\n    Loads the class from a .dat file using pickle format.\n\n    Args:\n        fname (str): File name to load the class.\n        polar (bool, optional): Whether to load polar data. Defaults to True.\n        cart (bool, optional): Whether to load cartesian data. Defaults to True.\n    \"\"\"\n    print('loading delta L ...')\n    with open(fname,'rb') as file:\n        self.__dict__ = pickle.load(file)\n    print('done loading pickle')\n\n    with h5py.File(fname[:-3]+'h5', \"r\") as f:\n        if ('deltaL_polar' in f) and (polar):\n            self.deltaL_polar = np.array(f['deltaL_polar'])\n            self.x_polar = np.array(f['x_polar'])\n            self.y_polar = np.array(f['y_polar'])\n\n        if (('deltaL_cart' in f) and cart):\n            self.deltaL_cart = np.array(f['deltaL_cart'])\n\n            self.x_cart = np.array(f['x_cart'])\n            self.y_cart = np.array(f['y_cart'])\n            self.z_cart = np.array(f['z_cart'])\n\n            self.x_array = np.array(f['x_array'])\n            self.y_array = np.array(f['y_array'])\n            self.z_array = np.array(f['z_array'])\n    print('done.')\n</code></pre>"},{"location":"reference/deltaLfield.html#src.prepost.deltaLfield.DeltaLField.compute3octave","title":"<code>compute3octave(fc=None, Nfc=None)</code>","text":"<p>Computes the third-octave frequencies.</p> <p>Parameters:</p> <ul> <li> <code>fc</code>               (<code>list</code>, default:                   <code>None</code> )           \u2013            <p>List of center frequencies. Defaults to None.</p> </li> <li> <code>Nfc</code>               (<code>list</code>, default:                   <code>None</code> )           \u2013            <p>List of the number of frequencies per band. Defaults to None.</p> </li> </ul> Source code in <code>src/prepost/deltaLfield.py</code> <pre><code>def compute3octave(self, fc: list = None, Nfc: list = None):\n    \"\"\"\n    Computes the third-octave frequencies.\n\n    Args:\n        fc (list, optional): List of center frequencies. Defaults to None.\n        Nfc (list, optional): List of the number of frequencies per band. Defaults to None.\n    \"\"\"\n    if fc is None or Nfc is None:\n        fc = [50, 63, 80, 100, 125, 160, 200, 250, 315, 400, 500, 630, 800, 1000]\n        Nfc = [1,  1,  1,   1,   1,  1,   2,   2,   3,   4,   4,   4,   5,  5]\n    freq = computeThirdOctaveFrequencies(fc, Nfc)\n    if not np.all(freq == self.frequencies):\n        print(\"central frequencies are not the same\")\n        return\n    self.fc = np.array(fc)\n    self.Nfc = np.array(Nfc)\n    shape = self.deltaL_cart.shape\n    deltaL3octave = np.zeros((shape[0],shape[1], shape[2], len(fc), self.nheight))\n\n    for ifc in range(len(fc)):\n        if0 = int(np.sum(self.Nfc[0:ifc]))\n        if1 = int(np.sum(self.Nfc[0:ifc+1]))\n        dl = self.deltaL_cart[:, :, :, if0:if1, :]\n        deltaL3octave[:, :, :, ifc, :] = 10*np.log10(np.mean(10**(dl/10), 3))\n\n    self.THIRD = True\n    self.deltaL_cart = deltaL3octave\n    self.frequencies = np.array(fc)\n    self.Nfreq = len(fc)\n</code></pre>"},{"location":"reference/deltaLfield.html#src.prepost.deltaLfield.DeltaLField.save_old","title":"<code>save_old(fname)</code>","text":"<p>Saves the class as a .dat file using pickle format.</p> <p>Parameters:</p> <ul> <li> <code>fname</code>               (<code>str</code>)           \u2013            <p>File name to save the class.</p> </li> </ul> Source code in <code>src/prepost/deltaLfield.py</code> <pre><code>def save_old(self, fname: str):\n    \"\"\"\n    Saves the class as a .dat file using pickle format.\n\n    Args:\n        fname (str): File name to save the class.\n    \"\"\"\n    with open(fname, \"wb\") as file:\n        pickle.dump(self.__dict__, file)\n</code></pre>"},{"location":"reference/deltaLfield.html#src.prepost.deltaLfield.DeltaLField.load_old","title":"<code>load_old(fname)</code>","text":"<p>Loads the class from a .dat file using pickle format.</p> <p>Parameters:</p> <ul> <li> <code>fname</code>               (<code>str</code>)           \u2013            <p>File name to load the class.</p> </li> </ul> Source code in <code>src/prepost/deltaLfield.py</code> <pre><code>def load_old(self, fname: str):\n    \"\"\"\n    Loads the class from a .dat file using pickle format.\n\n    Args:\n        fname (str): File name to load the class.\n    \"\"\"\n    print(\"loading Delta L ... \")\n    with open(fname, \"rb\") as file:\n        self.__dict__ = pickle.load(file)\n    print(\"done.\")\n</code></pre>"},{"location":"reference/deltaLfield.html#src.prepost.deltaLfield.DeltaLField.fname","title":"<code>fname(iTurb, tau, height, distribute_tau)</code>","text":"<p>construct the name of th h5 file storing the pe results.     the data stucture is such that if tau is not distibuted:       /t//.h5     if tau is distributed       /t//tau/.h5 <p>Returns:</p> <ul> <li> <code>str</code> (              <code>str</code> )          \u2013            <p>return the string for the complete path to the h5 file</p> </li> </ul> Source code in <code>src/prepost/deltaLfield.py</code> <pre><code>def fname(self, iTurb: int, tau: float, height: float, distribute_tau: int) -&gt; str:\n    \"\"\"construct the name of th h5 file storing the pe results.\n        the data stucture is such that if tau is not distibuted:\n          &lt;self.dirname&gt;/t&lt;iTurb&gt;/&lt;height&gt;/&lt;self.casename&gt;_&lt;tau&gt;.h5\n        if tau is distributed\n          &lt;self.dirname&gt;/t&lt;iTurb&gt;/&lt;height&gt;/tau&lt;itau&gt;/&lt;self.casename&gt;_&lt;tau&gt;.h5\n\n    Returns:\n        str: return the string for the complete path to the h5 file\n    \"\"\"\n\n    # convert angle to str format\n    if int(tau) == tau:\n        tau_str = format(tau, \"04d\")\n    else:\n        tau_str = str(tau)\n\n    # if tau distributed find the right folder\n    if distribute_tau is not None:\n        for kk in range(distribute_tau):\n            path = (\n                self.dirname\n                + \"t\"\n                + str(iTurb)\n                + \"/\"\n                + str(height)\n                + \"/tau\"\n                + str(kk)\n                + \"/\"\n            )\n            if os.path.isfile(path + self.casename + \"_\" + tau_str + \".h5\"):\n                break\n    # define directly the folder\n    else:\n        path = self.dirname + \"t\" + str(iTurb) + \"/\" + str(height) + \"/\"\n    return path + self.casename + \"_\" + tau_str + \".h5\"\n</code></pre> <p></p>"},{"location":"reference/deltaLfield.html#src.prepost.deltaLfield.DeltaLField.read_carto","title":"<code>read_carto(iTurb, height, tau, distribute_tau)</code>","text":"<p>Reads the cartography data from the H5 file for a given Turbine index, source height and propagation angle. The simulation resulsts are read using the <code>PeResults</code> class. The results are stored in a list of dictionnary before concatenation of all the simu results in a single matrix.</p> <p>Parameters:</p> <ul> <li> <code>iTurb</code>               (<code>int</code>)           \u2013            <p>Index of the turbine.</p> </li> <li> <code>height</code>               (<code>float</code>)           \u2013            <p>Source height.</p> </li> <li> <code>tau</code>               (<code>float</code>)           \u2013            <p>Propagation angle.</p> </li> <li> <code>distribute_tau</code>               (<code>bool</code>)           \u2013            <p>Whether the simulation was distributed over tau (this changes the fname).</p> </li> </ul> Source code in <code>src/prepost/deltaLfield.py</code> <pre><code>def read_carto(self, iTurb: int, height: float, tau: float, distribute_tau: bool):\n    \"\"\"\n    Reads the cartography data from the H5 file for a given Turbine index, source height and propagation angle.\n    The simulation resulsts are read using the `PeResults` class.\n    The results are stored in a list of dictionnary before concatenation of all the simu results in a single matrix.\n\n    Args:\n        iTurb (int): Index of the turbine.\n        height (float): Source height.\n        tau (float): Propagation angle.\n        distribute_tau (bool): Whether the simulation was distributed over tau (this changes the fname).\n    \"\"\"\n    res = PeResults(\n        self.casename,\n        iTurb,\n        height,\n        tau,\n        dirname=self.dirname,\n        distribute_tau=distribute_tau,\n    )\n    fname = self.fname(iTurb, tau, height, distribute_tau)\n    res.read_carto(fname)\n    # find height and tau index of the simulation\n    [x_grid, z_grid] = np.meshgrid(res.x, res.z, indexing=\"ij\")\n\n    # add height and tau to list if not already read\n    if height not in self.height:\n        self.height.append(height)\n    if tau not in self.tau:\n        self.tau.append(tau)\n\n    deltaL = {}\n    deltaL[\"height\"] = height\n    deltaL[\"tau\"] = tau\n    deltaL[\"freq\"] = res.frequencies\n    deltaL[\"x\"] = res.x\n    deltaL[\"z\"] = res.z\n    deltaL[\"x_grid\"] = x_grid\n    deltaL[\"z_grid\"] = z_grid\n    deltaL[\"val\"] = res.deltaL\n    self.deltaLlist.append(deltaL)\n</code></pre>"},{"location":"reference/deltaLfield.html#src.prepost.deltaLfield.DeltaLField.read_receiver","title":"<code>read_receiver(iTurb, height, tau, distribute_tau)</code>","text":"<p>Reads the receiver data from the H5 file for a given Turbine index, source height and propagation angle. The simulation resulsts are read using the <code>PeResults</code> class.  The resulst are store in a list of dictionnary before concatenation of all the simu results in a single matrix.</p> <p>Parameters:</p> <ul> <li> <code>iTurb</code>               (<code>int</code>)           \u2013            <p>turbine index</p> </li> <li> <code>height</code>               (<code>float</code>)           \u2013            <p>source height</p> </li> <li> <code>tau</code>               (<code>float</code>)           \u2013            <p>propagation angle</p> </li> <li> <code>distribute_tau</code>               (<code>bool</code>)           \u2013            <p>wether simulation were parallized over tau</p> </li> </ul> Source code in <code>src/prepost/deltaLfield.py</code> <pre><code>def read_receiver(self, iTurb: int, height: float, tau: float, distribute_tau: bool):\n    \"\"\"\n    Reads the receiver data from the H5 file for a given Turbine index, source height and propagation angle.\n    The simulation resulsts are read using the `PeResults` class. \n    The resulst are store in a list of dictionnary before concatenation of all the simu results in a single matrix.\n\n    Args:\n        iTurb (int): turbine index\n        height (float): source height\n        tau (float): propagation angle\n        distribute_tau (bool): wether simulation were parallized over tau\n    \"\"\"\n    res = PeResults(\n        self.casename,\n        iTurb,\n        height,\n        tau,\n        dirname=self.dirname,\n        distribute_tau=distribute_tau,\n    )\n    fname = self.fname(iTurb, tau, height, distribute_tau)\n    res.read_receiver(fname)\n    # find height and tau index of the simulation\n    [x_grid, z_grid] = np.meshgrid(res.x, res.z, indexing=\"ij\")\n\n    # add height and tau to list if not already read\n    if height not in self.height:\n        self.height.append(height)\n    if tau not in self.tau:\n        self.tau.append(tau)\n\n    deltaL = {}\n    deltaL[\"height\"] = height\n    deltaL[\"tau\"] = tau\n    deltaL[\"freq\"] = res.frequencies\n    deltaL[\"x\"] = res.x\n    deltaL[\"z\"] = res.heights\n    deltaL[\"x_grid\"] = x_grid\n    deltaL[\"z_grid\"] = z_grid\n    deltaL[\"val\"] = res.receiver\n    self.deltaLlist.append(deltaL)\n</code></pre>"},{"location":"reference/deltaLfield.html#src.prepost.deltaLfield.DeltaLField.check_compatibility","title":"<code>check_compatibility()</code>","text":"<p>Check compatibility between all solution recorded in self.deltaLlist The function check if the \\(Delta L\\) are computed for the same frequency and receiver height accros all angle of propagation angles  and source heights.</p> Source code in <code>src/prepost/deltaLfield.py</code> <pre><code>def check_compatibility(self):\n    \"\"\"\n    Check compatibility between all solution recorded in self.deltaLlist\n    The function check if the $Delta L$ are computed for the same frequency and receiver height accros all angle of propagation angles \n    and source heights.\n    \"\"\"\n    if not self.deltaLlist:\n        logging.warning(\"you need to read some PE results first ...\")\n        return -1\n\n    # check frequencies\n    frequencies = [deltaL[\"freq\"] for deltaL in self.deltaLlist]\n    flag,error_index = chkList(frequencies)\n    if flag:\n        logging.info(\"frequencies OK\")\n        logging.info( frequencies[0] )\n    else:\n        logging.warning(\"frequency are not the same\")\n        logging.warning(\"error for (h,tau)=(%s,%s)\" % (self.deltaLlist[error_index][\"height\"], \n                                                       self.deltaLlist[error_index][\"tau\"]))\n        return -1\n\n    # check receievr Heights\n    heights = [deltaL[\"z\"] for deltaL in self.deltaLlist]\n    if chkList(heights)[0]:\n        logging.info(\"receiver heights OK\")\n        logging.info(heights[0])\n    else:\n        logging.warning(\"receiver heights are not the same\")\n        return -1\n</code></pre>"},{"location":"reference/deltaLfield.html#src.prepost.deltaLfield.DeltaLField.concatenate_angles","title":"<code>concatenate_angles()</code>","text":"<p>Concatenate all loaded angles and source heights in a same numpy array. Find minimum and maximum values for R. Create the array of shape (Nx,Nz, Ntau, Nfreq, Nheight) and fiel it with the resultst from deltaLlist. This is usually done after loading the receiver results in order to create a (R,tau) field.  It could also be used with the cartography to create a complete 3D field but this would take a lot of space and was not done during this project.</p> Source code in <code>src/prepost/deltaLfield.py</code> <pre><code>def concatenate_angles(self):\n    \"\"\"\n    Concatenate all loaded angles and source heights in a same numpy array.\n    Find minimum and maximum values for R.\n    Create the array of shape (Nx,Nz, Ntau, Nfreq, Nheight) and fiel it with the resultst from deltaLlist.\n    This is usually done after loading the receiver results in order to create a (R,tau) field. \n    It could also be used with the cartography to create a complete 3D field but this would take a lot of space and was not done during this project.\n    \"\"\"\n\n    # find xmin, xmax\n    # ---------------------------------------------------------------------------------------\n    # initialize min max values\n    xmin = self.deltaLlist[0][\"x\"][0]\n    xmax = self.deltaLlist[0][\"x\"][-1]\n\n    # browse all deltaL to find min max values\n    for ii in range(1, len(self.deltaLlist)):\n        if self.deltaLlist[ii][\"x\"][0] &lt; xmin:\n            xmin = self.deltaLlist[ii][\"x\"][0]\n        if self.deltaLlist[ii][\"x\"][-1] &gt; xmax:\n            xmax = self.deltaLlist[ii][\"x\"][-1]\n\n    # rearange height and tau\n    # ---------------------------------------------------------------------------------------\n    self.height.sort()\n    self.tau.sort()\n    self.height = np.array(self.height)\n    self.tau = np.array(self.tau)\n    self.frequencies = self.deltaLlist[0][\"freq\"]\n\n    self.ntau = len(self.tau)\n    self.nheight = len(self.height)\n\n    # reshaping\n    # ---------------------------------------------------------------------------------------\n    # assuming all dx are the same\n    dx = self.deltaLlist[-1][\"x\"][1] - self.deltaLlist[-1][\"x\"][0]\n    # creating grid for x\n    self.x = np.arange(xmin, xmax + dx, dx)\n    self.nx = len(self.x)\n    # creating grid for z\n    self.z = self.deltaLlist[-1][\"z\"]\n    self.nz = len(self.z)\n\n    # create the complete matrix of deltaL\n    self.Nfreq = len(self.deltaLlist[-1][\"freq\"])\n    self.deltaL_polar = np.zeros(\n        (self.nx, self.nz, self.ntau, self.Nfreq, self.nheight)\n    )\n    # [self.x_grid,self.z_grid] = np.meshgrid(self.x, self.z,indexing='ij')\n\n    for deltaL in self.deltaLlist:\n        iheight = np.argmin(abs(self.height - deltaL[\"height\"]))\n        itau = np.argmin(abs(self.tau - deltaL[\"tau\"]))\n        # find corresponding index\n        ixmin = np.argmin(abs(self.x - deltaL[\"x\"][0]))\n        ixmax = np.argmin(abs(self.x - deltaL[\"x\"][-1]))\n        logging.info(\"height = \" + str(deltaL[\"height\"]) + \", tau = \" + str(deltaL[\"tau\"]))\n        self.deltaL_polar[ixmin : ixmax + 1, :, itau, :, iheight] = deltaL[\"val\"][\n            :, :, :\n        ]\n\n    # create polar mesh\n    angles = np.reshape(self.tau * np.pi / 180, (1, -1))\n    r = np.reshape(self.x, (-1, 1))\n\n    self.x_polar = r * np.cos(angles)\n    self.y_polar = r * np.sin(angles)\n</code></pre>"},{"location":"reference/deltaLfield.html#src.prepost.deltaLfield.DeltaLField.create_side_view","title":"<code>create_side_view(iTurb, tau=[0, 180])</code>","text":"<p>Creates a side view of the deltaL fiel from two opposit angles (usually tau=0 and tau=180). This function reads the cartography and concatenate them in a cartesian grid. </p> <p>Parameters:</p> <ul> <li> <code>iTurb</code>               (<code>int</code>)           \u2013            <p>Index of the turbine.</p> </li> <li> <code>tau</code>               (<code>list</code>, default:                   <code>[0, 180]</code> )           \u2013            <p>List of propagation angles. Defaults to [0, 180].</p> </li> </ul> Source code in <code>src/prepost/deltaLfield.py</code> <pre><code>def create_side_view(self, iTurb: int, tau: list = [0, 180]):\n    \"\"\"\n    Creates a side view of the deltaL fiel from two opposit angles (usually tau=0 and tau=180).\n    This function reads the cartography and concatenate them in a cartesian grid. \n\n    Args:\n        iTurb (int): Index of the turbine.\n        tau (list, optional): List of propagation angles. Defaults to [0, 180].\n    \"\"\"\n    if len(self.deltaLlist) != 0:\n        print('WARNING simulations were already loaded')\n        return -1\n\n    for h in self.simu.heights:\n        for t in tau:\n            print(h, t)\n            self.read_carto(iTurb, h, t, self.simu.distribute_tau)\n            print(self.deltaLlist[-1]['val'].shape)\n\n    self.check_compatibility()\n    # rearange height and tau\n    # ---------------------------------------------------------------------\n    self.height.sort()\n    self.tau.sort()\n    self.height = np.array(self.height)\n    self.tau = np.array(self.tau)\n    self.frequencies = self.deltaLlist[0][\"freq\"]\n\n    self.ntau = len(self.tau)\n    self.nheight = len(self.height)\n    if self.ntau == 2:\n        # reshaping\n        # -----------------------------------------------------------------\n        # creating grid for x\n        x_0 = self.deltaLlist[0][\"x\"]\n        nx_0 = len(x_0)\n        x_180 = self.deltaLlist[1][\"x\"]\n        nx_180 = len(x_180)\n\n        self.x = np.concatenate([-x_180[-1:0:-1], x_0], axis=0)\n        self.nx = len(self.x)\n\n        # creating grid for z\n        z_0 = self.deltaLlist[0][\"z\"]\n        z_180 = self.deltaLlist[1][\"z\"]\n\n        if (z_0 != z_180).any():\n            print(\"WARNING z array are not the same \")\n            return -1\n    else:\n        # if nx_180 = 0 put equal to 1 to avaoid negative nx\n        nx_180 = 1\n        self.x = self.deltaLlist[0][\"x\"]\n        self.nx = len(self.x)\n\n    self.z = self.deltaLlist[0][\"z\"]\n    self.nz = len(self.z)\n\n    # create the complete matrix of deltaL\n    self.Nfreq = len(self.deltaLlist[0][\"freq\"])\n    self.deltaL_cart = np.zeros(\n        (self.nx, 1, self.nz,\n            self.Nfreq, self.nheight)\n    )\n\n    print(self.deltaL_cart.shape)\n    for deltaL in self.deltaLlist:\n        iheight = np.argmin(abs(self.height - deltaL[\"height\"]))\n        # itau = np.argmin(abs(self.tau - deltaL[\"tau\"]))\n\n        if deltaL[\"tau\"] == 180:\n            print(\"height = \" +\n                  str(deltaL[\"height\"]) +\n                  \", tau = \" +\n                  str(deltaL[\"tau\"]))\n            self.deltaL_cart[:nx_180-1, 0,\n                             :, :, iheight] = deltaL[\"val\"][-1:0:-1, :, :]\n\n        if deltaL[\"tau\"] == 0:\n\n            print(\"height = \" +\n                  str(deltaL[\"height\"]) +\n                  \", tau = \" +\n                  str(deltaL[\"tau\"]))\n\n            print(nx_180)\n            print(deltaL[\"val\"].shape)\n\n            self.deltaL_cart[nx_180-1:, 0, :, :, iheight] = deltaL[\"val\"]\n            # change fi nc_180 = 0\n            #self.deltaL_cart[nx_180:, 0, :, :, iheight] = deltaL[\"val\"]\n\n    [self.x_cart, self.y_cart, self.z_cart] = np.meshgrid(\n        self.x, 0, self.z, indexing=\"ij\"\n    )\n    self.x_array = self.x\n    self.y_array = np.array([0])\n    self.z_array = self.z\n    self.ny = 1\n</code></pre>"},{"location":"reference/deltaLfield.html#src.prepost.deltaLfield.DeltaLField.interpolate_from_polar","title":"<code>interpolate_from_polar(x, y)</code>","text":"<p>Define a cartesian mesh from x and y. Interpolate from deltaL_polar.     create the deltaL_cartesian field.</p> <p>Parameters:</p> <ul> <li> <code>x</code>               (<code>ndarray</code>)           \u2013            <p>1D array of the x position on which to interpolate</p> </li> <li> <code>y</code>               (<code>ndarray</code>)           \u2013            <p>1D array of the y position on which to interpolate</p> </li> </ul> Source code in <code>src/prepost/deltaLfield.py</code> <pre><code>def interpolate_from_polar(self, x: np.ndarray, y: np.ndarray):\n    \"\"\"Define a cartesian mesh from x and y. Interpolate from deltaL_polar.\n        create the deltaL_cartesian field.\n\n    Args:\n        x (np.ndarray): 1D array of the x position on which to interpolate\n        y (np.ndarray): 1D array of the y position on which to interpolate\n    \"\"\"\n    # create vector of coordinates of the original grid\n    xy_polar = np.concatenate(\n        (self.x_polar.reshape((-1, 1)), self.y_polar.reshape((-1, 1))), 1\n    )\n\n    print(\"start interpolation ...\")\n    # create vector of coordinates of the new grid\n    self.x_cart, self.y_cart = np.meshgrid(x, y, indexing=\"ij\")\n    xy_cart = np.zeros([self.x_cart.shape[0] * self.x_cart.shape[1], 2])\n    xy_cart[:, 0] = self.x_cart.flatten()\n    xy_cart[:, 1] = self.y_cart.flatten()\n    # create knots for the interpolation\n    vtx, wts = interp_weights(xy_polar, xy_cart)\n    print(\"finished creating knot ...\")\n\n    self.deltaL_cart = np.zeros(\n        (\n            self.x_cart.shape[0],\n            self.x_cart.shape[1],\n            self.nz,\n            self.Nfreq,\n            self.nheight,\n        )\n    )\n    # loop of z, freq, heights and interpolate using the previously computes knots\n    print(\"starting loop on height and frequency band ...\")\n    for iz in range(self.nz):\n        for ifreq in range(self.Nfreq):\n            for iheight in range(self.nheight):\n                values = self.deltaL_polar[:, iz, :, ifreq, iheight].flatten()\n                valuesInterpolated = interpolate(values, vtx, wts)\n                self.deltaL_cart[\n                    :, :, iz, ifreq, iheight\n                ] = valuesInterpolated.reshape(\n                    self.x_cart.shape[0], self.x_cart.shape[1]\n                )\n    print(\"done\")\n    # save the interpolation grid\n    [self.x_cart, self.y_cart, self.z_cart] = np.meshgrid(\n        x, y, self.z, indexing=\"ij\"\n    )\n    self.x_array = x\n    self.y_array = y\n    self.z_array = self.z\n    self.nx = len(x)\n    self.ny = len(y)\n    self.nz = len(self.z)\n</code></pre>"},{"location":"reference/deltaLfield.html#src.prepost.deltaLfield.DeltaLField.read_all_slices","title":"<code>read_all_slices(iTurb, height_list, tau_list, distribute_tau, xplanes=[], yplanes=[])</code>","text":"<p>Reads all slices from the PE results.</p> <p>Parameters:</p> <ul> <li> <code>iTurb</code>               (<code>int</code>)           \u2013            <p>Index of the turbine.</p> </li> <li> <code>height_list</code>               (<code>list</code>)           \u2013            <p>List of source heights.</p> </li> <li> <code>tau_list</code>               (<code>list</code>)           \u2013            <p>List of propagation angles.</p> </li> <li> <code>distribute_tau</code>               (<code>bool</code>)           \u2013            <p>Whether the simulation was distributed over tau.</p> </li> <li> <code>xplanes</code>               (<code>list</code>, default:                   <code>[]</code> )           \u2013            <p>List of x-planes. Defaults to [].</p> </li> <li> <code>yplanes</code>               (<code>list</code>, default:                   <code>[]</code> )           \u2013            <p>List of y-planes. Defaults to [].</p> </li> </ul> Source code in <code>src/prepost/deltaLfield.py</code> <pre><code>def read_all_slices(self, iTurb: int, height_list: list, tau_list: list, distribute_tau: bool, xplanes: list = [], yplanes: list = []):\n    \"\"\"\n    Reads all slices from the PE results.\n\n    Args:\n        iTurb (int): Index of the turbine.\n        height_list (list): List of source heights.\n        tau_list (list): List of propagation angles.\n        distribute_tau (bool): Whether the simulation was distributed over tau.\n        xplanes (list, optional): List of x-planes. Defaults to [].\n        yplanes (list, optional): List of y-planes. Defaults to [].\n    \"\"\"\n\n    self.xslice_list = [[] for k in range(len(xplanes))]\n    self.yslice_list = [[] for k in range(len(yplanes))]\n    t_tot = 0 \n    t_read = 0\n    t_plane = 0 \n    t_save = 0 \n\n    t_init = time.time() \n    # loop over all angles and height solution \n    for height in height_list:\n        for tau in tau_list:\n            print(height,tau)\n            # read Pe results\n\n            # read slice results \n            res = PeResults(\n                self.casename,\n                iTurb,\n                height,\n                tau,\n                dirname=self.dirname,\n                distribute_tau=distribute_tau,\n            )\n            fname = self.fname(iTurb, tau, height, distribute_tau)\n            t0 = time.time()\n            res.read_planes(fname)\n            t_read += time.time() - t0\n            # add height to vector of heights\n            if height not in self.height:\n                self.height.append(height)\n\n\n            t0 = time.time()\n            # loop over the x constant planes \n            for ii,xplane in enumerate(xplanes):\n                # read from side output in case x==0 and angle coresponds\n                if xplane == 0:\n                    if tau == 90 or tau == -90 or tau == 270:\n                        res.read_carto(fname)\n                        if height not in self.height:\n                            self.height.append(height)\n                        # create a slice for each x position --&gt; this allow to kee the same post processing rootine for all planes\n                        for jj, y in enumerate(res.x):\n                            deltaL = {}\n                            deltaL[\"height\"] = height\n                            deltaL[\"tau\"] = tau\n                            deltaL[\"freq\"] = res.frequencies\n                            deltaL[\"z\"] = res.z\n                            deltaL[\"x\"] = 0\n                            deltaL[\"y\"] = y * np.sin(tau * np.pi / 180)\n                            deltaL[\"val\"] = res.deltaL[jj, :, :]\n                            self.xslice_list[ii].append(deltaL)\n\n                # get the coresponding slice         \n                else:\n                     # compar recorded slice with coresponding plane\n                    for jj, x in enumerate(res.xxcoord):\n                        if x == xplane:\n                            # check if a slice was recorded\n                            if res.xcount[jj] == 1:\n                                deltaL = {}\n                                deltaL[\"height\"] = height\n                                deltaL[\"tau\"] = tau\n                                deltaL[\"freq\"] = res.frequencies\n                                deltaL[\"z\"] = res.z\n                                deltaL[\"x\"] = x\n                                deltaL[\"y\"] = res.xycoord[jj]\n                                deltaL[\"val\"] = res.xplanes[jj, :]\n                                self.xslice_list[ii].append(deltaL)\n            t_save += time.time() - t0 \n\n            # loop over the y constant planes \n            for ii,yplane in enumerate(yplanes):\n                # read from side output in case y==0\n                if yplane == 0:\n                    if tau == 0 or tau == 180 or tau == -180:\n                        res.read_carto(fname)\n                        for jj, x in enumerate(res.x):\n                            deltaL = {}\n                            deltaL[\"height\"] = height\n                            deltaL[\"tau\"] = tau\n                            deltaL[\"freq\"] = res.frequencies\n                            deltaL[\"z\"] = res.z\n                            deltaL[\"x\"] = x * np.cos(tau * np.pi / 180)\n                            deltaL[\"y\"] = 0\n                            deltaL[\"val\"] = res.deltaL[jj, :, :]\n                            self.yslice_list[ii].append(deltaL)\n                else : \n                    for jj, y in enumerate(res.yycoord):\n                        if y == yplane:\n                            # check if slice was recorded\n                            if res.ycount[jj] == 1:\n                                deltaL = {}\n                                deltaL[\"height\"] = height\n                                deltaL[\"tau\"] = tau\n                                deltaL[\"freq\"] = res.frequencies\n                                deltaL[\"z\"] = res.z\n                                deltaL[\"x\"] = res.yxcoord[jj]\n                                deltaL[\"y\"] = y\n                                deltaL[\"val\"] = res.yplanes[jj, :]\n                                self.yslice_list[ii].append(deltaL)\n        t_tot = time.time() - t_init\n        print('t_read = ' + str (t_read/t_tot * 100))\n        print('t_save = ' + str(t_save/t_tot * 100))\n</code></pre>"},{"location":"reference/deltaLfield.html#src.prepost.deltaLfield.DeltaLField.concatenate_xslices","title":"<code>concatenate_xslices()</code>","text":"<p>Concatenates all x-slices.</p> Source code in <code>src/prepost/deltaLfield.py</code> <pre><code>def concatenate_xslices(self):\n    \"\"\"\n    Concatenates all x-slices.\n    \"\"\"\n    # test\n    ####################################################################\n    if len(self.xslice_list) == 0:\n        print(\"no plane loaded\")\n        return -1\n\n    # loop over the planes (remember xslice_list = [[dict0,dict1,...], ... [dict0,dict1]])\n    for slice_list in self.xslice_list :\n        # concatenate all the position recorded at the first height\n        x = np.array([d[\"x\"] for d in slice_list if d[\"height\"] == self.height[0]])\n        y = np.array([d[\"y\"] for d in slice_list if d[\"height\"] == self.height[0]])\n        z = slice_list[0][\"z\"]\n        frequencies = slice_list[0][\"freq\"]\n\n        for ii, h in enumerate(self.height[1:]):\n            # take all the slice position recorded for iith height, check that all position are the same\n            x_new = np.array([d[\"x\"] for d in slice_list if d[\"height\"] == h])\n            y_new = np.array([d[\"y\"] for d in slice_list if d[\"height\"] == h])\n            z = slice_list[ii][\"z\"]\n            frequencies = slice_list[0][\"freq\"]\n            if np.any(x != x_new):\n                print(\"planes are not the same for all heights\")\n                return -1\n            if np.any(y != y_new):\n                print(\"plane are not the same  for all heights\")\n                return -1\n\n        # sort heights\n        self.height.sort()\n        self.height = np.array(self.height)\n        self.nheight = len(self.height)\n        # remove all duplicate of x position (coming from several hgeight sbeeing recorded )\n        x = np.unique(x)\n        x.sort()\n\n        # remove all duplicate of y position\n        y = np.unique(y)\n        y.sort()\n\n        # take the first recorded z position on the slice\n        # TODO add check on z for all slice and heigths\n        z = slice_list[0][\"z\"]\n\n        # take first frequency recorded\n        # TODO add check pn frequency\n        self.frequencies = slice_list[0][\"freq\"]\n        self.Nfreq = len(self.frequencies)\n\n        # create deltaL matrix for one plane\n        deltaL = np.zeros(\n            (len(x), len(y), len(z), len(self.frequencies), len(self.height))\n        )\n        for deltaL_slice in slice_list:\n            iheight = np.argmin(abs(self.height - deltaL_slice[\"height\"]))\n            ix = np.argmin(abs(x - deltaL_slice[\"x\"]))\n            iy = np.argmin(abs(y - deltaL_slice[\"y\"]))\n            deltaL[ix, iy, :, :, iheight] = deltaL_slice[\"val\"]\n\n        self.plane_list.append(deltaL)\n        self.plane_xlist.append(x)\n        self.plane_ylist.append(y)\n        self.plane_zlist.append(z)\n</code></pre>"},{"location":"reference/deltaLfield.html#src.prepost.deltaLfield.DeltaLField.concatenate_yslices","title":"<code>concatenate_yslices()</code>","text":"<p>Concatenates all y-slices.</p> Source code in <code>src/prepost/deltaLfield.py</code> <pre><code>def concatenate_yslices(self):\n    \"\"\"\n    Concatenates all y-slices.\n    \"\"\"\n    # test\n    ####################################################################\n    if len(self.yslice_list) == 0:\n        print(\"no plane loaded\")\n        return -1\n\n    # loop over the planes (remember xslice_list = [[dict0,dict1,...], ... [dict0,dict1]])\n    for slice_list in self.yslice_list :\n        # concatenate all the position recorded at the first height\n        x = np.array([d[\"x\"] for d in slice_list if d[\"height\"] == self.height[0]])\n        y = np.array([d[\"y\"] for d in slice_list if d[\"height\"] == self.height[0]])\n        z = slice_list[0][\"z\"]\n        frequencies = slice_list[0][\"freq\"]\n\n        for ii, h in enumerate(self.height[1:]):\n            # take all the slice position recorded for iith height, check that all position are the same\n            x_new = np.array([d[\"x\"] for d in slice_list if d[\"height\"] == h])\n            y_new = np.array([d[\"y\"] for d in slice_list if d[\"height\"] == h])\n            z = slice_list[ii][\"z\"]\n            frequencies = slice_list[0][\"freq\"]\n            if np.any(x != x_new):\n                print(\"planes are not the same for all heights\")\n                return -1\n            if np.any(y != y_new):\n                print(\"plane are not the same  for all heights\")\n                return -1\n\n        # sort heights\n        self.height.sort()\n        self.height = np.array(self.height)\n        self.nheight = len(self.height)\n        # remove all duplicate of x position (coming from several hgeight sbeeing recorded )\n        x = np.unique(x)\n        x.sort()\n\n        # remove all duplicate of y position\n        y = np.unique(y)\n        y.sort()\n\n        # take the first recorded z position on the slice\n        # TODO add check on z for all slice and heigths\n        z = slice_list[0][\"z\"]\n\n        # take first frequency recorded\n        # TODO add check pn frequency\n        self.frequencies = slice_list[0][\"freq\"]\n        self.Nfreq = len(self.frequencies)\n\n        # create deltaL matrix for one plane\n        deltaL = np.zeros(\n            (len(x), len(y), len(z), len(self.frequencies), len(self.height))\n        )\n        for deltaL_slice in slice_list:\n            iheight = np.argmin(abs(self.height - deltaL_slice[\"height\"]))\n            ix = np.argmin(abs(x - deltaL_slice[\"x\"]))\n            iy = np.argmin(abs(y - deltaL_slice[\"y\"]))\n            deltaL[ix, iy, :, :, iheight] = deltaL_slice[\"val\"]\n\n        self.plane_list.append(deltaL)\n        self.plane_xlist.append(x)\n        self.plane_ylist.append(y)\n        self.plane_zlist.append(z)\n</code></pre>"},{"location":"reference/deltaLfield.html#src.prepost.deltaLfield.DeltaLField.interpolate_planes","title":"<code>interpolate_planes(x=None, y=None)</code>","text":"<p>Interpolates from previously recorded slices.</p> <p>Parameters:</p> <ul> <li> <code>x</code>               (<code>ndarray</code>, default:                   <code>None</code> )           \u2013            <p>1D array of the x position on which to interpolate. Defaults to None.</p> </li> <li> <code>y</code>               (<code>ndarray</code>, default:                   <code>None</code> )           \u2013            <p>1D array of the y position on which to interpolate. Defaults to None.</p> </li> </ul> Source code in <code>src/prepost/deltaLfield.py</code> <pre><code>def interpolate_planes(self, x: np.ndarray = None, y: np.ndarray = None):\n    \"\"\"\n    Interpolates from previously recorded slices.\n\n    Args:\n        x (np.ndarray, optional): 1D array of the x position on which to interpolate. Defaults to None.\n        y (np.ndarray, optional): 1D array of the y position on which to interpolate. Defaults to None.\n    \"\"\"\n    if x is not None:\n        # check\n        if len(self.plane_list) == 0:\n            print(\"not planes loaded\")\n            return -1\n        if self.plane_list[0].shape[1] != 1:\n            print(\"probably loaded x constant planes and not y constant\")\n            return -1\n\n        z = self.plane_zlist[0]\n        self.deltaL_cart = np.zeros(\n            (len(x), len(self.plane_ylist), len(z), self.Nfreq, self.nheight)\n        )\n        y_coord = []\n        X, Z = np.meshgrid(x, z, indexing=\"ij\")\n        for ii in range(len(self.plane_list)):\n            x_grid, z_grid = np.meshgrid(\n                self.plane_xlist[ii], self.plane_zlist[ii], indexing=\"ij\"\n            )\n            y_coord.append(self.plane_ylist[ii][0])\n            for ifreq in range(self.Nfreq):\n                for iheight in range(self.nheight):\n                    # if not a lot of point spline interpolation\n                    # if x_grid.size&lt;200000 :\n                    if x_grid.size &lt; 2:\n                        tck = bisplrep(\n                            x_grid,\n                            z_grid,\n                            np.squeeze(\n                                self.plane_list[ii][:, :, :, ifreq, iheight]\n                            ),\n                        )\n                        self.deltaL_cart[:, ii, :, ifreq, iheight] = bisplev(\n                            x, z, tck\n                        )\n                    # else linear interpolation\n                    else:\n                        tck = RegularGridInterpolator(\n                            (self.plane_xlist[ii], self.plane_zlist[ii]),\n                            np.squeeze(\n                                self.plane_list[ii][:, :, :, ifreq, iheight]\n                            ),\n                            bounds_error=False,\n                            fill_value=None,\n                            method=\"linear\",\n                        )\n                        self.deltaL_cart[:, ii, :, ifreq, iheight] = tck((X, Z))\n\n        y_coord = np.array(y_coord)\n        [self.x_cart, self.y_cart, self.z_cart] = np.meshgrid(\n            x, y_coord, z, indexing=\"ij\"\n        )\n        self.x_array = x\n        self.y_array = y_coord\n        self.z_array = z\n        self.nx = len(x)\n        self.ny = len(y_coord)\n        self.nz = len(z)\n\n    if y is not None:\n        # check\n        if len(self.plane_list) == 0:\n            print(\"not planes loaded\")\n            return -1\n        if self.plane_list[0].shape[0] != 1:\n            print(\"probably loaded y constant planes and not x constant\")\n            return -1\n\n        z = self.plane_zlist[0]\n        self.deltaL_cart = np.zeros(\n            (len(self.plane_xlist), len(y), len(z), self.Nfreq, self.nheight)\n        )\n\n        x_coord = []\n        Y, Z = np.meshgrid(y, z, indexing=\"ij\")\n        for ii in range(len(self.plane_list)):\n            y_grid, z_grid = np.meshgrid(\n                self.plane_ylist[ii], self.plane_zlist[ii], indexing=\"ij\"\n            )\n            x_coord.append(self.plane_xlist[ii][0])\n            for ifreq in range(self.Nfreq):\n                for iheight in range(self.nheight):\n                    # if y_grid.size&lt;200000 :\n                    if y_grid.size &lt; 2:\n                        tck = bisplrep(\n                            y_grid,\n                            z_grid,\n                            np.squeeze(\n                                self.plane_list[ii][:, :, :, ifreq, iheight]\n                            ),\n                        )\n                        self.deltaL_cart[ii, :, :, ifreq, iheight] = bisplev(\n                            y, z, tck\n                        )\n                    else:\n                        tck = RegularGridInterpolator(\n                            (self.plane_ylist[ii], self.plane_zlist[ii]),\n                            np.squeeze(\n                                self.plane_list[ii][:, :, :, ifreq, iheight]\n                            ),\n                            bounds_error=False,\n                            fill_value=None,\n                            method=\"linear\",\n                        )\n                        self.deltaL_cart[ii, :, :, ifreq, iheight] = tck((Y, Z))\n        x_coord = np.array(x_coord)\n\n        [self.x_cart, self.y_cart, self.z_cart] = np.meshgrid(\n            x_coord, y, z, indexing=\"ij\"\n        )\n        self.x_array = x_coord\n        self.y_array = y\n        self.z_array = z\n        self.nx = len(x_coord)\n        self.ny = len(y)\n        self.nz = len(z)\n    return\n</code></pre>"},{"location":"reference/deltaLfield.html#src.prepost.deltaLfield.DeltaLField.refine","title":"<code>refine(alpha, axis)</code>","text":"<p>Duplicates matrix size and divides grid step by alpha.</p> <p>Parameters:</p> <ul> <li> <code>alpha</code>               (<code>float</code>)           \u2013            <p>Refinement factor.</p> </li> <li> <code>axis</code>               (<code>int</code>)           \u2013            <p>Axis to refine (0 for x, 1 for z, 2 for tau).</p> </li> </ul> Source code in <code>src/prepost/deltaLfield.py</code> <pre><code>def refine(self, alpha: float, axis: int):\n    \"\"\"\n    Duplicates matrix size and divides grid step by alpha.\n\n    Args:\n        alpha (float): Refinement factor.\n        axis (int): Axis to refine (0 for x, 1 for z, 2 for tau).\n    \"\"\"\n    # x axis\n    if axis == 0:\n        # temp value\n        deltaL = np.zeros(\n            (\n                (self.nx - 1) * alpha + 1,\n                self.nz,\n                self.ntau,\n                self.Nfreq,\n                self.nheight,\n            )\n        )\n        x_grid = np.zeros(((self.nx - 1) * alpha + 1, self.nz, self.ntau))\n        z_grid = np.zeros(((self.nx - 1) * alpha + 1, self.nz, self.ntau))\n        # tau_grid = np.zeros(((self.nx-1)*alpha +1,self.nz,self.ntau))\n\n        deltaL[::alpha, ...] = self.deltaL\n        x_grid[::alpha, ...] = self.x_grid\n        z_grid[::alpha, ...] = self.z_grid\n        # tau_grid[::alpha,...] = self.tau_grid\n        for ii in range(alpha - 1):\n            deltaL[ii + 1 :: alpha, ...] = self.deltaL[:-1, ...]\n            x_grid[ii + 1 :: alpha, ...] = self.x_grid[:-1, ...]\n            z_grid[ii + 1 :: alpha, ...] = self.z_grid[:-1, ...]\n            # tau_grid[ii+1::alpha,...] = self.tau_grid[:-1,...]\n\n        self.deltaL = deltaL\n        self.x_grid = x_grid\n        self.z_grid = z_grid\n        # self.tau_grid = tau_grid\n        self.nx = (self.nx - 1) * alpha + 1\n        self.x = np.linspace(self.x[0], self.x[-1], self.nx)\n    # z axis\n    if axis == 1:\n        deltaL = np.zeros(\n            (\n                self.nx,\n                (self.nz - 1) * alpha + 1,\n                self.ntau,\n                self.Nfreq,\n                self.nheight,\n            )\n        )\n        x_grid = np.zeros((self.nx, (self.nz - 1) * alpha + 1, self.ntau))\n        z_grid = np.zeros((self.nx, (self.nz - 1) * alpha + 1, self.ntau))\n        # tau_grid = np.zeros((self.nx,(self.nz-1)*alpha +1,self.ntau))\n\n        deltaL[:, ::alpha, ...] = self.deltaL\n        x_grid[:, ::alpha, ...] = self.x_grid\n        z_grid[:, ::alpha, ...] = self.z_grid\n        # tau_grid[:,::alpha,...] = self.tau_grid\n        for ii in range(alpha - 1):\n            deltaL[:, ii + 1 :: alpha, ...] = self.deltaL[:, :-1, ...]\n            x_grid[:, ii + 1 :: alpha, ...] = self.x_grid[:, :-1, ...]\n            z_grid[:, ii + 1 :: alpha, ...] = self.z_grid[:, :-1, ...]\n            # tau_grid[:,ii+1::alpha,...] = self.tau_grid[:,:-1,...]\n\n        self.nz = (self.nz - 1) * alpha + 1\n        self.z = np.linspace(self.z[0], self.z[-1], self.nz)\n        self.deltaL = deltaL\n        self.x_grid = x_grid\n        self.z_grid = z_grid\n        # self.tau_grid = tau_grid\n\n    # tau axis\n    # TODO finish modify grid for tau axis\n    if axis == 2:\n        deltaL = np.zeros(\n            (self.nx, self.nz, 2 * self.ntau - 1, self.Nfreq, self.nheight)\n        )\n        tau = np.zeros((2 * self.ntau - 1))\n\n        for ii in range(self.ntau - 1):\n            deltaL[:, :, 2 * ii, :] = self.deltaL[:, :, ii, :, :]\n            deltaL[:, :, 2 * ii + 1, :] = 0.5 * (\n                self.deltaL[:, :, ii, :, :] + self.deltaL[:, :, ii + 1, :, :]\n            )\n            tau[2 * ii] = self.tau[ii]\n            tau[2 * ii + 1] = 0.5 * (self.tau[ii] + self.tau[ii + 1])\n\n        deltaL[:, :, -1, :] = self.deltaL[:, :, -1, :]\n        tau[-1] = self.tau[-1]\n\n        self.deltaL = deltaL\n        self.tau = tau\n        self.ntau = len(self.tau)\n</code></pre>"},{"location":"reference/deltaLfield.html#src.prepost.deltaLfield.DeltaLField.refine_angle","title":"<code>refine_angle()</code>","text":"<p>Refines the angle by creating a new deltaL field with twice the number of angles.</p> Source code in <code>src/prepost/deltaLfield.py</code> <pre><code>def refine_angle(self):\n    \"\"\"\n    Refines the angle by creating a new deltaL field with twice the number of angles.\n    \"\"\"\n    deltaL = np.zeros(\n        (self.nx, self.nz, 2 * self.ntau - 1, self.Nfreq, self.nheight)\n    )\n    tau = np.zeros((2 * self.ntau - 1))\n\n    for ii in range(self.ntau - 1):\n        deltaL[:, :, 2 * ii, :] = self.deltaL_polar[:, :, ii, :, :]\n        deltaL[:, :, 2 * ii + 1, :] = 0.5 * (\n            self.deltaL_polar[:, :, ii, :, :]\n            + self.deltaL_polar[:, :, ii + 1, :, :]\n        )\n        tau[2 * ii] = self.tau[ii]\n        tau[2 * ii + 1] = 0.5 * (self.tau[ii] + self.tau[ii + 1])\n\n    deltaL[:, :, -1, :] = self.deltaL_polar[:, :, -1, :]\n    tau[-1] = self.tau[-1]\n\n    self.deltaL_polar = deltaL\n    self.tau = tau\n    self.ntau = len(self.tau)\n\n    # create polar mesh\n    angles = np.reshape(self.tau * np.pi / 180, (1, -1))\n    r = np.reshape(self.x, (-1, 1))\n\n    self.x_polar = r * np.cos(angles)\n    self.y_polar = r * np.sin(angles)\n</code></pre>"},{"location":"reference/deltaLfield.html#src.prepost.deltaLfield.DeltaLField.loop_angle","title":"<code>loop_angle()</code>","text":"<p>Creates tau = 360 from tau = 0. This is done before using self.interpolate_from_polar.</p> Source code in <code>src/prepost/deltaLfield.py</code> <pre><code>def loop_angle(self):\n    \"\"\"\n    Creates tau = 360 from tau = 0. This is done before using self.interpolate_from_polar.\n    \"\"\"\n    # check if the first angle is indeed 0 \n    if self.tau[0] != 0:\n        print(\"first angle is not 0\")\n        return -1\n\n    # create the new deltaL \n    deltaL = np.zeros((self.nx, self.nz, self.ntau + 1, self.Nfreq, self.nheight))\n    tau = np.zeros((self.ntau + 1,))\n    deltaL[:, :, 0:-1, :, :] = self.deltaL_polar\n    deltaL[:, :, -1, :, :] = self.deltaL_polar[:, :, 0, :, :]\n\n    tau[0:-1] = self.tau\n    tau[-1] = 360\n    self.tau = tau\n    self.deltaL_polar = deltaL\n    self.ntau = len(self.tau)\n</code></pre>"},{"location":"reference/deltaLfield.html#src.prepost.deltaLfield.DeltaLField.interpolate_xz","title":"<code>interpolate_xz(x, z)</code>","text":"<p>Interpolates the 3D deltaL field on a new \\(xz\\) grid.</p> <p>Parameters:</p> <ul> <li> <code>x</code>               (<code>ndarray</code>)           \u2013            <p>1D array of the x position on which to interpolate.</p> </li> <li> <code>z</code>               (<code>ndarray</code>)           \u2013            <p>1D array of the z position on which to interpolate.</p> </li> </ul> Source code in <code>src/prepost/deltaLfield.py</code> <pre><code>def interpolate_xz(self, x: np.ndarray, z: np.ndarray):\n    \"\"\"\n    Interpolates the 3D deltaL field on a new $xz$ grid.\n\n    Args:\n        x (np.ndarray): 1D array of the x position on which to interpolate.\n        z (np.ndarray): 1D array of the z position on which to interpolate.\n    \"\"\"\n    x_grid, z_grid = np.meshgrid(self.x_array, self.z_array, indexing=\"ij\")\n\n    xz_old = np.concatenate((x_grid.reshape((-1, 1)), z_grid.reshape((-1, 1))), 1)\n\n    print(\"start interpolation ...\")\n    self.x_new, self.z_new = np.meshgrid(x, z, indexing=\"ij\")\n    xz_new = np.zeros([self.x_new.shape[0] * self.z_new.shape[1], 2])\n    xz_new[:, 0] = self.x_new.flatten()\n    xz_new[:, 1] = self.z_new.flatten()\n    vtx, wts = interp_weights(xz_old, xz_new)\n    print(\"finished creating knot ...\")\n\n    deltaLInterpolatedNew = np.zeros(\n        (\n            self.x_new.shape[0],\n            self.ny,\n            self.x_new.shape[1],\n            self.Nfreq,\n            self.nheight,\n        )\n    )\n\n    print(\"starting loop on height and frequency band ...\")\n    for iy in range(self.ny):\n        for ifreq in range(self.Nfreq):\n            for iheight in range(self.nheight):\n                deltaLInterpolatedNew[:, iy, :, ifreq, iheight] = interpolate(\n                    self.deltaL_cart[:, iy, :, ifreq, iheight].flatten(),\n                    vtx,\n                    wts,\n                ).reshape(self.x_new.shape[0], self.x_new.shape[1])\n    print(\"done\")\n    self.deltaL_cart = deltaLInterpolatedNew\n    [self.x_cart, self.y_cart, self.z_cart] = np.meshgrid(\n        x, self.y_array, z, indexing=\"ij\"\n    )\n    self.x_array = x\n    self.z_array = z\n    self.nx = len(x)\n    self.nz = len(z)\n</code></pre>"},{"location":"reference/deltaLfield.html#src.prepost.deltaLfield.DeltaLField.interpolate_xy","title":"<code>interpolate_xy(x, y)</code>","text":"<p>Interpolates the  deltaL field on a new \\(xy\\) grid.</p> <p>Parameters:</p> <ul> <li> <code>x</code>               (<code>ndarray</code>)           \u2013            <p>1D array of the x position on which to interpolate.</p> </li> <li> <code>y</code>               (<code>ndarray</code>)           \u2013            <p>1D array of the y position on which to interpolate.</p> </li> </ul> Source code in <code>src/prepost/deltaLfield.py</code> <pre><code>def interpolate_xy(self, x: np.ndarray, y: np.ndarray):\n    \"\"\"\n    Interpolates the  deltaL field on a new $xy$ grid.\n\n    Args:\n        x (np.ndarray): 1D array of the x position on which to interpolate.\n        y (np.ndarray): 1D array of the y position on which to interpolate.\n    \"\"\"\n    x_grid, y_grid = np.meshgrid(self.x_array, self.y_array, indexing=\"ij\")\n\n    xy_old = np.concatenate((x_grid.reshape((-1, 1)), y_grid.reshape((-1, 1))), 1)\n\n    print(\"start interpolation ...\")\n    self.x_new, self.y_new = np.meshgrid(x, y, indexing=\"ij\")\n    xy_new = np.zeros([self.x_new.shape[0] * self.y_new.shape[1], 2])\n    xy_new[:, 0] = self.x_new.flatten()\n    xy_new[:, 1] = self.y_new.flatten()\n    vtx, wts = interp_weights(xy_old, xy_new)\n    print(\"finished creating knot ...\")\n\n    deltaLInterpolatedNew = np.zeros(\n        (\n            self.x_new.shape[0],\n            self.x_new.shape[1],\n            self.nz,\n            self.Nfreq,\n            self.nheight,\n        )\n    )\n\n    print(\"starting loop on height and frequency band ...\")\n    for iz in range(self.nz):\n        for ifreq in range(self.Nfreq):\n            for iheight in range(self.nheight):\n                deltaLInterpolatedNew[:, :, iz, ifreq, iheight] = interpolate(\n                    self.deltaL_cart[:, :, iz, ifreq, iheight].flatten(),\n                    vtx,\n                    wts,\n                ).reshape(self.x_new.shape[0], self.x_new.shape[1])\n    print(\"done\")\n    self.deltaL_cart = deltaLInterpolatedNew\n    [self.x_cart, self.y_cart, self.z_cart] = np.meshgrid(\n        x, y, self.z_array, indexing=\"ij\"\n    )\n    self.x_array = x\n    self.y_array = y\n    self.nx = len(x)\n    self.ny = len(y)\n</code></pre>"},{"location":"reference/deltaLfield.html#src.prepost.deltaLfield.DeltaLField.interpolate_yz","title":"<code>interpolate_yz(y, z)</code>","text":"<p>Interpolates the deltaL field on a new \\(yz\\) grid.</p> <p>Parameters:</p> <ul> <li> <code>y</code>               (<code>ndarray</code>)           \u2013            <p>1D array of the y position on which to interpolate.</p> </li> <li> <code>z</code>               (<code>ndarray</code>)           \u2013            <p>1D array of the z position on which to interpolate.</p> </li> </ul> Source code in <code>src/prepost/deltaLfield.py</code> <pre><code>def interpolate_yz(self, y: np.ndarray, z: np.ndarray):\n    \"\"\"\n    Interpolates the deltaL field on a new $yz$ grid.\n\n    Args:\n        y (np.ndarray): 1D array of the y position on which to interpolate.\n        z (np.ndarray): 1D array of the z position on which to interpolate.\n    \"\"\"\n    y_grid, z_grid = np.meshgrid(self.y_array, self.z_array, indexing=\"ij\")\n\n    yz_old = np.concatenate((y_grid.reshape((-1, 1)), z_grid.reshape((-1, 1))), 1)\n\n    print(\"start interpolation ...\")\n    self.y_new, self.z_new = np.meshgrid(y, z, indexing=\"ij\")\n    yz_new = np.zeros([self.y_new.shape[0] * self.z_new.shape[1], 2])\n    yz_new[:, 0] = self.y_new.flatten()\n    yz_new[:, 1] = self.z_new.flatten()\n    vtx, wts = interp_weights(yz_old, yz_new)\n    print(\"finished creating knot ...\")\n\n    deltaLInterpolatedNew = np.zeros(\n        (\n            self.nx,\n            self.y_new.shape[0],\n            self.x_new.shape[1],\n            self.Nfreq,\n            self.nheight,\n        )\n    )\n\n    print(\"starting loop on height and frequency band ...\")\n    for ix in range(self.nx):\n        for ifreq in range(self.Nfreq):\n            for iheight in range(self.nheight):\n                deltaLInterpolatedNew[ix, :, :, ifreq, iheight] = interpolate(\n                    self.deltaL_cart[ix, :, :, ifreq, iheight].flatten(),\n                    vtx,\n                    wts,\n                ).reshape(self.x_new.shape[0], self.x_new.shape[1])\n    print(\"done\")\n    self.deltaL_cart = deltaLInterpolatedNew\n    [self.x_cart, self.y_cart, self.z_cart] = np.meshgrid(\n        self.x_array, y, z, indexing=\"ij\"\n    )\n    self.y_array = y\n    self.z_array = z\n    self.ny = len(y)\n    self.nz = len(z)\n</code></pre>"},{"location":"reference/deltaLfield.html#src.prepost.deltaLfield.DeltaLField.shift_domain","title":"<code>shift_domain(xshift, yshift)</code>","text":"<p>Shifts the domain by xshift and yshift. This is usefull to replace the domain relative to the Flow field.</p> <p>Parameters:</p> <ul> <li> <code>xshift</code>               (<code>float</code>)           \u2013            <p>Shift in the x-direction.</p> </li> <li> <code>yshift</code>               (<code>float</code>)           \u2013            <p>Shift in the y-direction.</p> </li> </ul> Source code in <code>src/prepost/deltaLfield.py</code> <pre><code>def shift_domain(self, xshift:float, yshift:float):\n    \"\"\"\n    Shifts the domain by xshift and yshift.\n    This is usefull to replace the domain relative to the Flow field.\n\n    Args:\n        xshift (float): Shift in the x-direction.\n        yshift (float): Shift in the y-direction.\n    \"\"\"\n    if self.x_polar is not None:\n        self.x_polar = self.x_polar + xshift\n        self.y_polar = self.y_polar + yshift\n\n    if self.x_cart is not None:\n        self.x_cart = self.x_cart + xshift\n        self.y_cart = self.y_cart + yshift\n        self.x_array = self.x_array + xshift\n        self.y_array = self.y_array + yshift\n\n    if self.plane_xlist is not None:\n        for ii in range(len(self.plane_xlist)):\n            self.plane_xlist[ii] = self.plane_xlist[ii] + xshift  \n        # self.plane_xlist = np.array(self.plane_xlist, dtype=float)\n        # self.plane_xlist = self.plane_xlist + xshift\n\n    if self.plane_ylist is not None:\n        for ii in range(len(self.plane_ylist)):\n            self.plane_ylist[ii] = self.plane_ylist[ii] + yshift  \n</code></pre>"},{"location":"reference/deltaLfield.html#src.prepost.deltaLfield.DeltaLField.plot_top_polar","title":"<code>plot_top_polar(z, freq, height, cmap='RdBu_r', **kwargs)</code>","text":"<p>plot top view of deltaL field at a given \\(z\\), frequency, and for a given sourcei height. This is used to plot the \\(\\Delta L\\) when still in polar coordinates. </p> <p>Parameters:</p> <ul> <li> <code>z</code>               (<code>float</code>)           \u2013            <p>receiver height</p> </li> <li> <code>freq</code>               (<code>float</code>)           \u2013            <p>frequency</p> </li> <li> <code>height</code>               (<code>float</code>)           \u2013            <p>source height</p> </li> <li> <code>cmap</code>               (<code>str</code>, default:                   <code>'RdBu_r'</code> )           \u2013            <p>colormap. Defaults to 'RdBu_r'.</p> </li> </ul> Source code in <code>src/prepost/deltaLfield.py</code> <pre><code>def plot_top_polar(self, z: float, freq: float, height: float, cmap=\"RdBu_r\", **kwargs):\n    \"\"\"plot top view of deltaL field at a given $z$, frequency, and for a given sourcei height.\n    This is used to plot the $\\Delta L$ when still in polar coordinates. \n\n    Args:\n        z (float): receiver height\n        freq (float): frequency\n        height (float): source height\n        cmap (str, optional): colormap. Defaults to 'RdBu_r'.\n    \"\"\"\n    ifreq = np.nonzero(self.frequencies == freq)[0][0]\n    iz = np.nonzero(self.z == z)[0][0]\n    iheight = np.nonzero(self.height == height)[0][0]\n\n    cax = plt.pcolormesh(\n        self.x_polar,\n        self.y_polar,\n        self.deltaL_polar[:, iz, :, ifreq, iheight],\n        cmap=cmap,\n        shading=\"auto\",\n        **kwargs\n    )\n    plt.gca().set_aspect(\"equal\", adjustable=\"box\")\n    plt.xlabel(\"x (m)\")\n    plt.ylabel(\"y (m)\")\n    ax = plt.gca()\n    divider = make_axes_locatable(ax)\n    cb = divider.append_axes(\"right\", size=\"5%\", pad=0.05)\n    cb.set_title(\"$\\Delta L$ (dB)\")\n    plt.colorbar(cax, cax=cb)\n    plt.tight_layout()\n    return ax\n</code></pre>"},{"location":"reference/deltaLfield.html#src.prepost.deltaLfield.DeltaLField.plotLineRaw","title":"<code>plotLineRaw(tau, z, freq, height, **kwargs)</code>","text":"<p>Plots a line from the \\(\\Delta L\\) field still saved in polar coordinates (as <code>self.deltaL_polar</code>).</p> <p>Parameters:</p> <ul> <li> <code>tau</code>               (<code>float</code>)           \u2013            <p>Propagation angle.</p> </li> <li> <code>z</code>               (<code>float</code>)           \u2013            <p>Receiver height.</p> </li> <li> <code>freq</code>               (<code>float</code>)           \u2013            <p>Frequency.</p> </li> <li> <code>height</code>               (<code>float</code>)           \u2013            <p>Source height.</p> </li> </ul> Source code in <code>src/prepost/deltaLfield.py</code> <pre><code>def plotLineRaw(self, tau, z, freq, height, **kwargs):\n    \"\"\"\n    Plots a line from the $\\Delta L$ field still saved in polar coordinates (as `self.deltaL_polar`).\n\n    Args:\n        tau (float): Propagation angle.\n        z (float): Receiver height.\n        freq (float): Frequency.\n        height (float): Source height.\n    \"\"\"\n    itau = np.nonzero(self.tau == tau)[0][0]\n    ifreq = np.nonzero(self.frequencies == freq)[0][0]\n    iz = np.nonzero(self.z == z)[0][0]\n    iheight = np.nonzero(self.height == height)[0][0]\n    plt.plot(self.x_polar[:, itau], self.deltaL_polar[:, iz, itau, ifreq, iheight], **kwargs)\n</code></pre>"},{"location":"reference/deltaLfield.html#src.prepost.deltaLfield.DeltaLField.plotDirectivityRaw","title":"<code>plotDirectivityRaw(r, z, freq, height, **kwargs)</code>","text":"<p>Plots the directivity from the delta L field in polar coordinates at a given distance from the source.</p> <p>Parameters:</p> <ul> <li> <code>r</code>               (<code>float</code>)           \u2013            <p>Radius.</p> </li> <li> <code>z</code>               (<code>float</code>)           \u2013            <p>Receiver height.</p> </li> <li> <code>freq</code>               (<code>float</code>)           \u2013            <p>Frequency.</p> </li> <li> <code>height</code>               (<code>float</code>)           \u2013            <p>Source height.</p> </li> </ul> Source code in <code>src/prepost/deltaLfield.py</code> <pre><code>def plotDirectivityRaw(self, r: float, z: float, freq: float, height: float, **kwargs):\n    \"\"\"\n    Plots the directivity from the delta L field in polar coordinates at a given distance from the source.\n\n    Args:\n        r (float): Radius.\n        z (float): Receiver height.\n        freq (float): Frequency.\n        height (float): Source height.\n    \"\"\"\n    ir = np.nonzero(self.x == r)[0][0]\n    ifreq = np.nonzero(self.frequencies == freq)[0][0]\n    iz = np.nonzero(self.z == z)[0][0]\n    iheight = np.nonzero(self.height == height)[0][0]\n\n    # fig, ax = plt.subplots(subplot_kw={'projection': 'polar'})\n    # plt.axes(projection='polar')\n    # plt.gca().projection = 'polar'\n    plt.polar(\n        self.tau * np.pi / 180, self.deltaL[ir, iz, :, ifreq, iheight], **kwargs\n    )\n</code></pre>"},{"location":"reference/deltaLfield.html#src.prepost.deltaLfield.DeltaLField.plot_top_cart","title":"<code>plot_top_cart(z, freq, height, ax=None, **kwargs)</code>","text":"<p>Plots the top view of the deltaL field in Cartesian coordinates. This can be used after converting the \\(\\Delta L\\) field from polar to cartesian grid with the function <code>interpolate_from_polar</code>.</p> <p>Parameters:</p> <ul> <li> <code>z</code>               (<code>float</code>)           \u2013            <p>Receiver height.</p> </li> <li> <code>freq</code>               (<code>float</code>)           \u2013            <p>Frequency.</p> </li> <li> <code>height</code>               (<code>float</code>)           \u2013            <p>Source height.</p> </li> <li> <code>ax</code>               (<code>Axes</code>, default:                   <code>None</code> )           \u2013            <p>Axes to plot on. Defaults to None.</p> </li> </ul> Source code in <code>src/prepost/deltaLfield.py</code> <pre><code>def plot_top_cart(self, z: float, freq: float, height: float, ax=None, **kwargs):\n    \"\"\"\n    Plots the top view of the deltaL field in Cartesian coordinates.\n    This can be used after converting the $\\Delta L$ field from polar to cartesian grid with the function `interpolate_from_polar`.\n\n    Args:\n        z (float): Receiver height.\n        freq (float): Frequency.\n        height (float): Source height.\n        ax (matplotlib.axes.Axes, optional): Axes to plot on. Defaults to None.\n    \"\"\"\n\n    ifreq = np.nonzero(self.frequencies == freq)[0][0]\n    iz = np.nonzero(self.z == z)[0][0]\n    iheight = np.nonzero(self.height == height)[0][0]\n\n    if ax is not(None):\n        cax = ax.pcolormesh(\n            self.x_cart[:,:,iz],\n            self.y_cart[:,:,iz],\n            self.deltaL_cart[:, :, iz, ifreq, iheight],\n            **kwargs\n        )\n    else:\n        ax = plt.pcolormesh(\n            self.x_cart[:,:,iz],\n            self.y_cart[:,:,iz],\n            self.deltaL_cart[:, :, iz, ifreq, iheight],\n            **kwargs\n        )\n        cax = None\n    # plt.gca().set_aspect(\"equal\", adjustable=\"box\")\n    return cax\n</code></pre>"},{"location":"reference/deltaLfield.html#src.prepost.deltaLfield.DeltaLField.plot_yz","title":"<code>plot_yz(x, freq, height, **kwargs)</code>","text":"<p>Plots the yz view of the cartesian DeltaL field.</p> <p>Parameters:</p> <ul> <li> <code>x</code>               (<code>float</code>)           \u2013            <p>x-coordinate.</p> </li> <li> <code>freq</code>               (<code>float</code>)           \u2013            <p>Frequency.</p> </li> <li> <code>height</code>               (<code>float</code>)           \u2013            <p>Source height.</p> </li> </ul> Source code in <code>src/prepost/deltaLfield.py</code> <pre><code>def plot_yz(self, x: float, freq: float, height: float, **kwargs):\n    \"\"\"\n    Plots the yz view of the cartesian DeltaL field.\n\n    Args:\n        x (float): x-coordinate.\n        freq (float): Frequency.\n        height (float): Source height.\n    \"\"\"\n    ifreq = np.nonzero(self.frequencies == freq)[0][0]\n    ix = np.nonzero(self.x_cart[:,0,0] == x)[0][0]\n    iheight = np.nonzero(self.height == height)[0][0]\n\n    plt.pcolormesh(\n        self.y_cart[ix,:,:],\n        self.z_cart[ix,:,:],\n        self.deltaL_cart[ix, :, :, ifreq, iheight],\n        **kwargs\n    )\n    plt.gca().set_aspect(\"equal\", adjustable=\"box\")\n</code></pre>"},{"location":"reference/deltaLfield.html#src.prepost.deltaLfield.DeltaLField.plot_xz","title":"<code>plot_xz(y, freq, height, **kwargs)</code>","text":"<p>Plots the xz view of the cartesian deltaL field at a given \\(y\\) plane.</p> <p>Parameters:</p> <ul> <li> <code>y</code>               (<code>float</code>)           \u2013            <p>y-coordinate.</p> </li> <li> <code>freq</code>               (<code>float</code>)           \u2013            <p>Frequency.</p> </li> <li> <code>height</code>               (<code>float</code>)           \u2013            <p>Source height.</p> </li> </ul> Source code in <code>src/prepost/deltaLfield.py</code> <pre><code>def plot_xz(self, y: float, freq: float, height: float, **kwargs):\n    \"\"\"\n    Plots the xz view of the cartesian deltaL field at a given $y$ plane.\n\n    Args:\n        y (float): y-coordinate.\n        freq (float): Frequency.\n        height (float): Source height.\n    \"\"\"\n    ifreq = np.nonzero(self.frequencies == freq)[0][0]\n    iy = np.nonzero(self.y_cart[0,:,0] == y)[0][0]\n    iheight = np.nonzero(self.height == height)[0][0]\n\n    plt.pcolormesh(\n        self.x_cart[:,iy,:],\n        self.z_cart[:,iy,:],\n        self.deltaL_cart[:, iy, :, ifreq, iheight],\n        **kwargs\n    )\n</code></pre>"},{"location":"reference/deltaLfield.html#src.prepost.deltaLfield.DeltaLField.plot_x","title":"<code>plot_x(y, z, freq, height, **kwargs)</code>","text":"<p>Plots $\\Delta L $ field at a guven \\((y,z)\\) position (along \\(x\\)).</p> <p>Parameters:</p> <ul> <li> <code>y</code>               (<code>float</code>)           \u2013            <p>y-coordinate.</p> </li> <li> <code>z</code>               (<code>float</code>)           \u2013            <p>z-coordinate.</p> </li> <li> <code>freq</code>               (<code>float</code>)           \u2013            <p>Frequency.</p> </li> <li> <code>height</code>               (<code>float</code>)           \u2013            <p>Source height.</p> </li> </ul> Source code in <code>src/prepost/deltaLfield.py</code> <pre><code>def plot_x(self, y: float, z: float, freq: float, height: float, **kwargs):\n    \"\"\"\n    Plots $\\Delta L $ field at a guven $(y,z)$ position (along $x$).\n\n    Args:\n        y (float): y-coordinate.\n        z (float): z-coordinate.\n        freq (float): Frequency.\n        height (float): Source height.\n    \"\"\"\n    ifreq = np.nonzero(self.frequencies == freq)[0][0]\n    iy = np.nonzero(self.y_cart[0, :, 0] == y)[0][0]\n    iz = np.nonzero(self.z_cart[0, 0, :] == z)[0][0]\n    iheight = np.nonzero(self.height == height)[0][0]\n    plt.plot(self.x_cart[:, iy, iz],\n             self.deltaL_cart[:, iy, iz, ifreq, iheight],\n             **kwargs)\n</code></pre>"},{"location":"reference/deltaLfield.html#src.prepost.deltaLfield.DeltaLField.plot_tau","title":"<code>plot_tau(tau, z, freq, height, Nmax=None, **kwargs)</code>","text":"<p>Plots the Delta L for a given height and propagation angle.</p> <p>Parameters:</p> <ul> <li> <code>tau</code>               (<code>float</code>)           \u2013            <p>Propagation angle.</p> </li> <li> <code>z</code>               (<code>float</code>)           \u2013            <p>z-coordinate.</p> </li> <li> <code>freq</code>               (<code>float</code>)           \u2013            <p>Frequency.</p> </li> <li> <code>height</code>               (<code>float</code>)           \u2013            <p>Source height.</p> </li> <li> <code>Nmax</code>               (<code>int</code>, default:                   <code>None</code> )           \u2013            <p>Set the delta L value from 0 to Nmax to nan.</p> </li> </ul> Source code in <code>src/prepost/deltaLfield.py</code> <pre><code>def plot_tau(self, tau: float, z: float, freq: float, height: float, Nmax: int = None, **kwargs):\n    \"\"\"\n    Plots the Delta L for a given height and propagation angle.\n\n    Args:\n        tau (float): Propagation angle.\n        z (float): z-coordinate.\n        freq (float): Frequency.\n        height (float): Source height.\n        Nmax (int, optional): Set the delta L value from 0 to Nmax to nan.\n    \"\"\"\n    ifreq = np.nonzero(self.frequencies == freq)[0][0]\n    iheight = np.nonzero(self.height == height)[0][0]\n    iz = np.nonzero(self.z_cart[0, 0, :] == z)[0][0]\n    itau = np.nonzero(self.tau == tau)[0][0]\n    # this is used in order to not plot element that are\n    # outside the computational domain\n    if Nmax is not None:\n        self.deltaL_cart[Nmax:, itau, iz, ifreq, iheight] = np.nan\n    plt.plot(self.x_cart[:, itau, iz],\n             self.deltaL_cart[:, itau, iz, ifreq, iheight],\n             **kwargs)\n</code></pre>"},{"location":"reference/gtpe.html","title":"Reference for <code>prepost/gtpe.py</code>","text":""},{"location":"reference/gtpe.html#src.prepost.gtpe.GtpeResults","title":"<code>GtpeResults(fname, tau, height)</code>","text":"<p>Class to handle GTPE results from an H5 file.</p> <p>Parameters:</p> <ul> <li> <code>fname</code>               (<code>str</code>)           \u2013            <p>File name of the H5 file.</p> </li> <li> <code>tau</code>               (<code>float</code>)           \u2013            <p>Propagation angle.</p> </li> <li> <code>height</code>               (<code>float</code>)           \u2013            <p>Source height.</p> </li> </ul> Source code in <code>src/prepost/gtpe.py</code> <pre><code>def __init__(self, fname, tau, height):\n    self.fname = fname\n    self.tau = tau\n    self.height = height\n</code></pre>"},{"location":"reference/gtpe.html#src.prepost.gtpe.GtpeResults.read","title":"<code>read()</code>","text":"<p>Reads the solution from the H5 file, including mesh and receivers.</p> Source code in <code>src/prepost/gtpe.py</code> <pre><code>def read(self):\n    \"\"\"Reads the solution from the H5 file, including mesh and receivers.\n    \"\"\"\n    fname = self.fname\n    file = h5py.File(fname, \"r\")\n    solutions = file.get('solution')\n    # read mesh and create mesh grid\n    mesh = file.get('mesh')\n    frequencies = list(solutions.keys())\n    self.frequencies = np.array([float(i) for i in frequencies])\n    self.x = np.array(mesh['x'])\n    self.z = np.array(mesh['y'])\n    self.h = np.array(mesh['H'])\n    [self.X, self.Z] = np.meshgrid(self.x, self.z)\n    self.Z = self.Z*(self.z[len(self.z)-1]-self.h) / \\\n        self.z[len(self.z)-1] + self.h\n\n    # read carto of delta L\n    self.deltaL = np.zeros(\n        (len(self.x), len(self.z), len(self.frequencies)))\n    # solution matrix (Nz,Nx,Nf)\n    for ii in range(len(frequencies)):\n        sol = solutions.get(frequencies[ii])\n        self.deltaL[:, :, ii] = np.transpose(np.array(sol['deltaL']))\n    # read delta L saved at receivers\n    receivers_all = file.get('receiver')\n    self.heights = np.array(receivers_all.get('heights'))\n    self.receiver = np.zeros(\n        (len(self.x), len(self.heights), len(self.frequencies)))\n    for ii in range(len(self.frequencies)):\n        rec = receivers_all.get(frequencies[ii])\n        self.receiver[:, :, ii] = np.transpose(np.array(rec['deltaL']))\n</code></pre>"},{"location":"reference/gtpe.html#src.prepost.gtpe.GtpeResults.plotSide","title":"<code>plotSide(freq, cmap='RdYlBu_r')</code>","text":"<p>Plots the side view of the deltaL for a given frequency.</p> <p>Parameters:</p> <ul> <li> <code>freq</code>               (<code>float</code>)           \u2013            <p>Frequency to plot.</p> </li> <li> <code>cmap</code>               (<code>str</code>, default:                   <code>'RdYlBu_r'</code> )           \u2013            <p>Colormap to use. Defaults to 'RdYlBu_r'.</p> </li> </ul> Source code in <code>src/prepost/gtpe.py</code> <pre><code>def plotSide(self, freq: float, cmap: str = 'RdYlBu_r'):\n    \"\"\"Plots the side view of the deltaL for a given frequency.\n\n    Args:\n        freq (float): Frequency to plot.\n        cmap (str, optional): Colormap to use. Defaults to 'RdYlBu_r'.\n    \"\"\"\n    ifreq = np.nonzero(self.frequencies == freq)[0][0]\n    if ifreq is None:\n        print('frequence was not calculated.')\n        return\n    plt.pcolormesh(\n        self.X, self.Z, self.deltaL[:, :, ifreq].T, cmap=cmap, shading='gouraud')\n    plt.clim(-10, 10)\n    plt.gca().set_aspect('equal', adjustable='box')\n    plt.ylim(0, 300)\n</code></pre>"},{"location":"reference/gtpe.html#src.prepost.gtpe.GtpeResults.plotSide3octave","title":"<code>plotSide3octave(freq, cmap='RdYlBu_r')</code>","text":"<p>Plots the side view of the deltaL for a given third-octave frequency.</p> <p>Parameters:</p> <ul> <li> <code>freq</code>               (<code>float</code>)           \u2013            <p>Third-octave frequency to plot.</p> </li> <li> <code>cmap</code>               (<code>str</code>, default:                   <code>'RdYlBu_r'</code> )           \u2013            <p>Colormap to use. Defaults to 'RdYlBu_r'.</p> </li> </ul> Source code in <code>src/prepost/gtpe.py</code> <pre><code>def plotSide3octave(self, freq: float, cmap: str = 'RdYlBu_r'):\n    \"\"\"Plots the side view of the deltaL for a given third-octave frequency.\n\n    Args:\n        freq (float): Third-octave frequency to plot.\n        cmap (str, optional): Colormap to use. Defaults to 'RdYlBu_r'.\n    \"\"\"\n    ifreq = np.nonzero(self.fc == freq)[0][0]\n    if ifreq is None:\n        print('frequence was not calculated.')\n        return\n    plt.pcolormesh(\n        self.X, self.Z, self.deltaL3octave[:, :, ifreq].T, cmap=cmap, shading='gouraud')\n    plt.clim(-10, 10)\n    plt.gca().set_aspect('equal', adjustable='box')\n    plt.ylim(0, 300)\n</code></pre>"},{"location":"reference/gtpe.html#src.prepost.gtpe.GtpeResults.plotLine","title":"<code>plotLine(freq, height)</code>","text":"<p>Plots the deltaL along a line at a given frequency and height.</p> <p>Parameters:</p> <ul> <li> <code>freq</code>               (<code>float</code>)           \u2013            <p>Frequency to plot.</p> </li> <li> <code>height</code>               (<code>float</code>)           \u2013            <p>Height to plot.</p> </li> </ul> Source code in <code>src/prepost/gtpe.py</code> <pre><code>def plotLine(self, freq: float, height: float):\n    \"\"\"Plots the deltaL along a line at a given frequency and height.\n\n    Args:\n        freq (float): Frequency to plot.\n        height (float): Height to plot.\n    \"\"\"\n    ifreq = np.nonzero(self.frequencies == freq)[0][0]\n    iheight = np.nonzero(self.heights == height)[0][0]\n    print(self.heights[iheight])\n    if ifreq is None:\n        print('frequence was not calculated.')\n        return\n    plt.plot(self.x, self.receiver[:, iheight, ifreq])\n</code></pre>"},{"location":"reference/gtpe.html#src.prepost.gtpe.GtpeResults.plotLine3octave","title":"<code>plotLine3octave(freq, height)</code>","text":"<p>Plots the deltaL along a line at a given third-octave frequency and height.</p> <p>Parameters:</p> <ul> <li> <code>freq</code>               (<code>float</code>)           \u2013            <p>Third-octave frequency to plot.</p> </li> <li> <code>height</code>               (<code>float</code>)           \u2013            <p>Height to plot.</p> </li> </ul> Source code in <code>src/prepost/gtpe.py</code> <pre><code>def plotLine3octave(self, freq: float, height: float):\n    \"\"\"Plots the deltaL along a line at a given third-octave frequency and height.\n\n    Args:\n        freq (float): Third-octave frequency to plot.\n        height (float): Height to plot.\n    \"\"\"\n    ifreq = np.nonzero(self.fc == freq)[0][0]\n    iheight = np.nonzero(self.heights == height)[0][0]\n    if ifreq is None:\n        print('frequence was not calculated.')\n        return\n    plt.plot(self.x, self.receiver3octave[:, iheight, ifreq])\n</code></pre>"},{"location":"reference/gtpe.html#src.prepost.gtpe.GtpeResults.compute3octave","title":"<code>compute3octave(fc, Nfc)</code>","text":"<p>Computes the third-octave frequencies.</p> <p>Parameters:</p> <ul> <li> <code>fc</code>               (<code>list</code>)           \u2013            <p>List of center frequencies.</p> </li> <li> <code>Nfc</code>               (<code>list</code>)           \u2013            <p>List of the number of frequencies per band.</p> </li> </ul> Source code in <code>src/prepost/gtpe.py</code> <pre><code>def compute3octave(self, fc: list, Nfc: list):\n    \"\"\"Computes the third-octave frequencies.\n\n    Args:\n        fc (list): List of center frequencies.\n        Nfc (list): List of the number of frequencies per band.\n    \"\"\"\n    freq = computeThirdOctaveFrequencies(fc, Nfc)\n    if not np.all(freq == self.frequencies):\n        print('central frequencies are not the same')\n        print(freq)\n        print(self.frequencies)\n        return\n    self.fc = np.array(fc)\n    self.Nfc = np.array(Nfc)\n    self.deltaL3octave = np.zeros((len(self.x), len(self.z), len(fc)))\n    self.receiver3octave = np.zeros(\n        (len(self.x), len(self.heights), len(fc)))\n    for ifc in range(len(fc)):\n        self.deltaL3octave[:, :, ifc] = 10*np.log10(np.sum(10**(self.deltaL[:, :, int(\n            np.sum(self.Nfc[0:ifc])):np.sum(self.Nfc[0:ifc+1])]/10), 2)/Nfc[ifc])\n        self.receiver3octave[:, :, ifc] = 10*np.log10(np.sum(10**(self.receiver[:, :, int(\n            np.sum(self.Nfc[0:ifc])):np.sum(self.Nfc[0:ifc+1])]/10), 2)/Nfc[ifc])\n</code></pre>"},{"location":"reference/gtpe.html#src.prepost.gtpe.GtpeResults.plotLineOaspl","title":"<code>plotLineOaspl(height)</code>","text":"<p>Plots the OASPL along a line at a given height.</p> <p>Parameters:</p> <ul> <li> <code>height</code>               (<code>float</code>)           \u2013            <p>Height to plot.</p> </li> </ul> Source code in <code>src/prepost/gtpe.py</code> <pre><code>def plotLineOaspl(self, height: float):\n    \"\"\"Plots the OASPL along a line at a given height.\n\n    Args:\n        height (float): Height to plot.\n    \"\"\"\n    iheight = np.argmin(abs(self.heights - height))\n    SPL, SPL_A, OASPL, OASPL_A = computeSPLLine(np.squeeze(self.receiver3octave[iheight, :, :]), np.squeeze(self.x),\n                                                np.squeeze(self.heights[iheight]+self.h), self.fc, self.tau, self.height, c0=343)\n    plt.plot(self.x, OASPL_A)\n</code></pre>"},{"location":"reference/gtpe.html#src.prepost.gtpe.GtpeResults.plotFlowSide","title":"<code>plotFlowSide(fname, cmap='RdYlBu_r', xstep=1, zstep=1)</code>","text":"<p>Plots the side view of the flow field from a given H5 file.</p> <p>Parameters:</p> <ul> <li> <code>fname</code>               (<code>str</code>)           \u2013            <p>File name of the H5 file containing the flow data.</p> </li> <li> <code>cmap</code>               (<code>str</code>, default:                   <code>'RdYlBu_r'</code> )           \u2013            <p>Colormap to use. Defaults to 'RdYlBu_r'.</p> </li> <li> <code>xstep</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>Step size in the x-direction. Defaults to 1.</p> </li> <li> <code>zstep</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>Step size in the z-direction. Defaults to 1.</p> </li> </ul> Source code in <code>src/prepost/gtpe.py</code> <pre><code>def plotFlowSide(self, fname: str, cmap: str = 'RdYlBu_r', xstep: int = 1, zstep: int = 1):\n    \"\"\"Plots the side view of the flow field from a given H5 file.\n\n    Args:\n        fname (str): File name of the H5 file containing the flow data.\n        cmap (str, optional): Colormap to use. Defaults to 'RdYlBu_r'.\n        xstep (int, optional): Step size in the x-direction. Defaults to 1.\n        zstep (int, optional): Step size in the z-direction. Defaults to 1.\n    \"\"\"\n    f = h5py.File(fname, \"r\")\n\n    # read mesh\n    x = np.array(f['x'])\n    z = np.array(f['z'])\n\n    # read flow\n    u = np.array(f['u'])\n    v = np.array(f['v'])\n\n    print(x.shape)\n    print(z.shape)\n    fig, ax = plt.subplots(figsize=(10, 1.8))\n\n    cax = ax.pcolormesh(x[::xstep, ::zstep], z[::xstep, ::zstep],\n                        u[::xstep, ::zstep], cmap=cmap, shading='gouraud')\n    ax.set_aspect('equal', adjustable='box')\n    divider = make_axes_locatable(ax)\n    cbax = divider.append_axes(\"right\", size=\"2%\", pad=0.05)\n    ax.set_xlabel('$x$ (m)')\n    ax.set_ylabel('$z$ (m)')\n    fig.colorbar(cax, cax=cbax, label='$u$ (m/s)')\n    plt.tight_layout()\n</code></pre>"},{"location":"reference/les.html","title":"Reference for <code>prepost/les.py</code>","text":""},{"location":"reference/les.html#src.prepost.les.Les","title":"<code>Les(path)</code>","text":"<p>The Les class is designed to handle the processing and visualization of Large Eddy Simulation (LES) data  computed with Atmospheric LES code developped at the University of Twente by the PoF group.  LES is a computational fluid dynamics (CFD) technique used to simulate turbulent flows  by resolving large-scale eddies and modeling the effects of smaller-scale eddies.  This class provides a comprehensive set of tools to read, analyze, and plot various quantities derived from LES simulations.</p> <p>Key functionalities of the Les class include:</p> <ul> <li> <p>Data Reading: The class reads simulation data from HDF5 files, including velocity components, temperature, pressure, and turbulence statistics.  It also reads configuration parameters from an input file to initialize the simulation domain and grid.</p> </li> <li> <p>Grid Initialization: The class sets up the computational grid based on the simulation parameters,  defining the spatial coordinates and dimensions of the domain. </p> </li> </ul> <p>Note</p> <p>a specifity of the simulation results is that the spanwise and streamwise  component are not recorded at the same height than the vertical component (a half grid step higher) </p> <ul> <li> <p>Quantity Plotting: The class provides methods to plot various quantities in different planes (XZ, XY, YZ) and to plot profiles along specific coordinates.  This helps in visualizing the spatial distribution and variation of flow properties.</p> </li> <li> <p>Turbulence Analysis: The class calculates and plots turbulence-related quantities such as dissipation rate and turbulent intensity, which are usefull input parameters for the source model developed afterwards.</p> </li> <li> <p>Convergence Analysis: The class reads and plots convergence data, such as kinetic energy and friction velocity,  to monitor the stability and accuracy of the simulation over time.</p> </li> </ul> <p>Initializes the Les class with the given path.</p> <p>Parameters:</p> <ul> <li> <code>path</code>               (<code>str</code>)           \u2013            <p>The path to the directory containing the LES data files.</p> </li> </ul> Source code in <code>src/prepost/les.py</code> <pre><code>def __init__(self,path):\n    \"\"\"\n    Initializes the Les class with the given path.\n\n    Args:\n        path (str): The path to the directory containing the LES data files.\n    \"\"\"\n    self.path = path\n</code></pre>"},{"location":"reference/les.html#src.prepost.les.Les.read","title":"<code>read(dirname='output', ratio=None, adim=False)</code>","text":"<p>Reads LES data from files and initializes the grid and flow variables.</p> <p>Parameters:</p> <ul> <li> <code>dirname</code>               (<code>str</code>, default:                   <code>'output'</code> )           \u2013            <p>The directory name where the data files are located.</p> </li> <li> <code>ratio</code>               (<code>float</code>, default:                   <code>None</code> )           \u2013            <p>A scaling ratio for the velocity dimension.</p> </li> <li> <code>adim</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Flag to use adimensional values.</p> </li> </ul> Source code in <code>src/prepost/les.py</code> <pre><code>def read(self, dirname: str = \"output\", ratio: float = None, adim: bool = False):\n    \"\"\"\n    Reads LES data from files and initializes the grid and flow variables.\n\n    Args:\n        dirname (str): The directory name where the data files are located.\n        ratio (float, optional): A scaling ratio for the velocity dimension.\n        adim (bool, optional): Flag to use adimensional values.\n    \"\"\"\n    fname = self.path + '/%s/gridz.h5'%(dirname)\n    vel = h5py.File(fname,\"r\")\n    z = np.array(vel['var'])\n    self.z = np.asarray(z)\n    fname =  self.path + '/%s/gridzw.h5'%(dirname)\n    vel = h5py.File(fname,\"r\")\n    zw = np.array(vel['var'])\n    self.zw = np.asarray(zw)\n    i = 0\n    tstart = 0\n    lines = []\n    in_file = open (self.path+'/input.conf', 'rt')\n    self.u_star = 1\n    for line in in_file:\n        lines.append(line)\n        dummy = lines[i].split()\n        if (len(dummy)&gt; 0):\n            if(dummy[0] == 'Nx'):\n                self.nx = int(dummy[2])\n            if(dummy[0] == 'Ny'):\n                self.ny = int(dummy[2])\n            if(dummy[0] == 'Nz'):\n                self.nz = int(dummy[2])\n            if(dummy[0] == 'z_i'):\n                self.z_i = float(dummy[2])\n            if(dummy[0] == 'grid_size'):\n                self.dz = float(dummy[2])\n            if(dummy[0] == 'Lx'):\n                self.lx = float(dummy[2])\n            if(dummy[0] == 'Ly'):\n                self.ly = float(dummy[2])\n            if(dummy[0] == 'Lz'):\n                self.lz = float(dummy[2])\n            if(dummy[0] == 'ug'):\n                self.ug = float(dummy[2])\n            if (dummy[0] == 'u_star'):\n                self.u_star = float(dummy[2])\n            if (dummy[0] == 'zo'):\n                self.z0 = float(dummy[2])\n                self.z0 = self.z0*self.z_i\n            if (dummy[0] == 'use_mean_p_force'):\n                if dummy[2] == '.false.':\n                    self.use_mean_p_force = False\n                else:\n                    self.use_mean_p_force = True\n            if(dummy[0] == 'T_scale'):\n                self.T_scale = float(dummy[2])\n            if(dummy[0] == 'T_init'):\n                self.T_init = float(dummy[2])\n            if(dummy[0] == 'nloc'):\n                self.nturb = int(dummy[2])\n\n        i = i + 1\n\n    self.dx  = (self.lx / np.double(self.nx)) * self.z_i\n    self.dy  = (self.ly / np.double(self.ny)) * self.z_i\n\n    self.L_x = self.lx * self.z_i\n    self.L_y = self.ly * self.z_i\n    self.L_z = self.lz * self.z_i\n\n\n    #Define the grid \n    self.dx = self.L_x/self.nx\n    self.dy = self.L_y/self.ny\n    self.x = np.linspace(0.000,self.L_x-self.dx,self.nx)\n    self.y = np.linspace(0.000,self.L_y-self.dy,self.ny)\n    self.z = self.z * self.z_i\n    self.zw = self.zw * self.z_i\n\n    if self.use_mean_p_force:\n        self.u_dim = 1\n        # print(\"ustar =%s\"%self.u_star)\n    else:\n        self.u_dim = self.ug\n        # print(\"ug =%s\"%self.ug)\n\n    self.adim = adim\n    # dimension of flow\n    if ratio is not None:\n        self.u_dim = ratio\n    if self.adim:\n        self.u_dim = 1/self.u_star\n\n    fullpath = self.path +'/' + dirname + '/'\n    if os.path.isfile(fullpath+'tavg_u.h5'):\n        vel = h5py.File(fullpath+'tavg_u.h5',\"r\")\n        u = self.u_dim*np.array(vel['var'])\n        self.u = np.asarray(u)\n    if os.path.isfile(fullpath+'tavg_u.h5'):  \n        vel = h5py.File(fullpath+'tavg_v.h5',\"r\")\n        v = self.u_dim*np.array(vel['var'])\n        self.v = np.asarray(v)\n    if os.path.isfile(fullpath+'tavg_w.h5'):\n        vel = h5py.File(fullpath+'tavg_w.h5',\"r\")\n        w = self.u_dim*np.array(vel['var'])\n        self.w = np.asarray(w)\n    if os.path.isfile(fullpath+'tavg_theta.h5'):\n        vel = h5py.File(fullpath+'tavg_theta.h5',\"r\")\n        theta = self.T_scale*np.array(vel['var'])\n        self.theta = np.asarray(theta)\n\n\n    if os.path.isfile(fullpath+'tavg_pres.h5'):\n        vel = h5py.File(fullpath+'tavg_pres.h5',\"r\")\n        self.pres = np.array(vel['var'])\n\n    else:\n        self.theta = None\n    if os.path.isfile(fullpath+'initial_theta.h5'):\n        vel = h5py.File(fullpath+'initial_theta.h5',\"r\")\n        theta = self.T_scale*np.array(vel['var'])\n        self.initial_theta = np.asarray(theta)\n\n\n\n    if self.theta is not None:\n        # print(np.max(self.pres))\n        # print(np.min(self.pres))\n        # convert potential temperature to absolute temperature \n        R_over_cp = 0.286\n        P0 = 1e5    # pression atmospherique de reference\n        P =  101325 # reference pressure\n        # Mass molar of air  \n        M = 29e-3 # Kg/mol\n        g = 9.81 # m/s2\n        # universal gaz constant \n        R = 8.314 # J/(mol;K)\n        T0 = 293 # reference temperature \n\n        p = P0 * np.exp(- self.z[:,None,None] * M*g/(R*T0))\n        self.T = self.theta*(p/P0)**(R_over_cp)\n\n\n        # self.T = self.theta*(P/P0)**(R_over_cp)\n\n        gamma = 1.4 \n        R = 286\n        self.c = np.sqrt(gamma*R*self.T) \n\n    turbines = []\n    if os.path.isfile(self.path + '/turbine_input.dat'):\n        with open(self.path + '/turbine_input.dat') as f:\n            for l in f :\n                sp = l.split(',')\n                turbines.append(sp)\n\n        turbines.pop(0)\n    self.turbines = np.array(turbines, dtype=float)\n    self.epsilon = None\n    self.ti = None\n</code></pre>"},{"location":"reference/les.html#src.prepost.les.Les.plotQuantityXZ","title":"<code>plotQuantityXZ(fname, y, **kwargs)</code>","text":"<p>Plots a quantity in the XZ plane at a specified y-coordinate.</p> <p>Parameters:</p> <ul> <li> <code>fname</code>               (<code>str</code>)           \u2013            <p>The name of the quantity to plot (e.g., 'u', 'v', 'w', 'c', 'theta', 'T', 'epsilon').</p> </li> <li> <code>y</code>               (<code>float</code>)           \u2013            <p>The y-coordinate at which to plot the quantity.</p> </li> <li> <code>**kwargs</code>           \u2013            <p>Additional keyword arguments for plot customization.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Axes</code>           \u2013            <p>plt.Axes: The matplotlib Axes object containing the plot.</p> </li> </ul> Source code in <code>src/prepost/les.py</code> <pre><code>def plotQuantityXZ(self, fname: str, y: float, **kwargs) -&gt; plt.Axes:\n    \"\"\"\n    Plots a quantity in the XZ plane at a specified y-coordinate.\n\n    Args:\n        fname (str): The name of the quantity to plot (e.g., 'u', 'v', 'w', 'c', 'theta', 'T', 'epsilon').\n        y (float): The y-coordinate at which to plot the quantity.\n        **kwargs: Additional keyword arguments for plot customization.\n\n    Returns:\n        plt.Axes: The matplotlib Axes object containing the plot.\n    \"\"\"\n    iy = np.argmin(np.abs(self.y - y))\n    vel = self._get_quantity(fname)\n    cax = plt.pcolormesh(self.x, self.z, vel[:, iy, :], **kwargs)\n    return cax\n</code></pre>"},{"location":"reference/les.html#src.prepost.les.Les.plotQuantityXY","title":"<code>plotQuantityXY(fname, z, **kwargs)</code>","text":"<p>Plots a quantity in the XY plane at a specified z-coordinate.</p> <p>Parameters:</p> <ul> <li> <code>fname</code>               (<code>str</code>)           \u2013            <p>The name of the quantity to plot (e.g., 'u', 'v', 'w', 'c', 'theta', 'T', 'epsilon', 'ti').</p> </li> <li> <code>z</code>               (<code>float</code>)           \u2013            <p>The z-coordinate at which to plot the quantity.</p> </li> <li> <code>**kwargs</code>           \u2013            <p>Additional keyword arguments for plot customization.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Axes</code>           \u2013            <p>plt.Axes: The matplotlib Axes object containing the plot.</p> </li> </ul> Source code in <code>src/prepost/les.py</code> <pre><code>def plotQuantityXY(self, fname: str, z: float, **kwargs) -&gt; plt.Axes:\n    \"\"\"\n    Plots a quantity in the XY plane at a specified z-coordinate.\n\n    Args:\n        fname (str): The name of the quantity to plot (e.g., 'u', 'v', 'w', 'c', 'theta', 'T', 'epsilon', 'ti').\n        z (float): The z-coordinate at which to plot the quantity.\n        **kwargs: Additional keyword arguments for plot customization.\n\n    Returns:\n        plt.Axes: The matplotlib Axes object containing the plot.\n    \"\"\"\n    iz = np.argmin(np.abs(self.z - z))\n    vel = self._get_quantity(fname)\n    cax = plt.pcolormesh(self.x, self.y, vel[iz, :, :], **kwargs)\n    plt.xlabel('x (m)')\n    plt.ylabel('y (m)')\n    plt.tight_layout()\n    return cax\n</code></pre>"},{"location":"reference/les.html#src.prepost.les.Les.plotQuantityYZ","title":"<code>plotQuantityYZ(fname, x, **kwargs)</code>","text":"<p>Plots a quantity in the YZ plane at a specified x-coordinate.</p> <p>Parameters:</p> <ul> <li> <code>fname</code>               (<code>str</code>)           \u2013            <p>The name of the quantity to plot (e.g., 'u', 'v', 'w', 'c', 'theta', 'T', 'epsilon', 'ti').</p> </li> <li> <code>x</code>               (<code>float</code>)           \u2013            <p>The x-coordinate at which to plot the quantity.</p> </li> <li> <code>**kwargs</code>           \u2013            <p>Additional keyword arguments for plot customization.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Axes</code>           \u2013            <p>plt.Axes: The matplotlib Axes object containing the plot.</p> </li> </ul> Source code in <code>src/prepost/les.py</code> <pre><code>def plotQuantityYZ(self, fname: str, x: float, **kwargs) -&gt; plt.Axes:\n    \"\"\"\n    Plots a quantity in the YZ plane at a specified x-coordinate.\n\n    Args:\n        fname (str): The name of the quantity to plot (e.g., 'u', 'v', 'w', 'c', 'theta', 'T', 'epsilon', 'ti').\n        x (float): The x-coordinate at which to plot the quantity.\n        **kwargs: Additional keyword arguments for plot customization.\n\n    Returns:\n        plt.Axes: The matplotlib Axes object containing the plot.\n    \"\"\"\n    ix = np.argmin(np.abs(self.x - x))\n    vel = self._get_quantity(fname)\n    cax = plt.pcolormesh(self.y, self.z, vel[:, :, ix], **kwargs)\n    plt.xlabel('y (m)')\n    plt.ylabel('z (m)')\n    plt.tight_layout()\n    return cax\n</code></pre>"},{"location":"reference/les.html#src.prepost.les.Les._get_quantity","title":"<code>_get_quantity(fname)</code>","text":"<p>Retrieves the quantity array based on the given filename.</p> <p>Parameters:</p> <ul> <li> <code>fname</code>               (<code>str</code>)           \u2013            <p>The name of the quantity to retrieve (e.g., 'u', 'v', 'w', 'c', 'theta', 'T', 'epsilon', 'ti').</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ndarray</code>           \u2013            <p>np.ndarray: The array containing the quantity data.</p> </li> </ul> Source code in <code>src/prepost/les.py</code> <pre><code>def _get_quantity(self, fname: str) -&gt; np.ndarray:\n    \"\"\"\n    Retrieves the quantity array based on the given filename.\n\n    Args:\n        fname (str): The name of the quantity to retrieve (e.g., 'u', 'v', 'w', 'c', 'theta', 'T', 'epsilon', 'ti').\n\n    Returns:\n        np.ndarray: The array containing the quantity data.\n    \"\"\"\n    if fname == 'u':\n        return self.u\n    elif fname == 'v':\n        return self.v\n    elif fname == 'w':\n        return self.w\n    elif fname == 'c':\n        return self.c\n    elif fname == 'theta':\n        return self.theta\n    elif fname == 'T':\n        return self.T\n    elif fname == 'epsilon':\n        if self.epsilon is None:\n            self.dissipation()\n        return self.epsilon\n    elif fname == 'ti':\n        if self.ti is None:\n            self.turbulent_intensity()\n        return self.ti\n    else:\n        with h5py.File(f\"{self.path}/{fname}\", \"r\") as vel:\n            return np.array(vel['var'])\n</code></pre>"},{"location":"reference/les.html#src.prepost.les.Les.plotProfile","title":"<code>plotProfile(fname, x=None, y=None, scaling=1, **kwargs)</code>","text":"<p>Plots a profile of a quantity along the the z-axis. If x or y are given the profile is plotted at this location, other wise it is averaged along this axis.</p> <p>Parameters:</p> <ul> <li> <code>fname</code>               (<code>str</code>)           \u2013            <p>The name of the quantity to plot (e.g., 'u', 'v', 'w', 'c', 'theta', 'T', 'epsilon', 'ti').</p> </li> <li> <code>x</code>               (<code>float</code>, default:                   <code>None</code> )           \u2013            <p>The x-coordinate at which to plot the profile.</p> </li> <li> <code>y</code>               (<code>float</code>, default:                   <code>None</code> )           \u2013            <p>The y-coordinate at which to plot the profile.</p> </li> <li> <code>scaling</code>               (<code>float</code>, default:                   <code>1</code> )           \u2013            <p>A scaling factor for the quantity.</p> </li> <li> <code>**kwargs</code>           \u2013            <p>Additional keyword arguments for plot customization.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ndarray</code>           \u2013            <p>np.ndarray: The profile of the quantity.</p> </li> </ul> Source code in <code>src/prepost/les.py</code> <pre><code>def plotProfile(self, fname: str, x: float = None, y: float = None, scaling: float = 1, **kwargs) -&gt; np.ndarray:\n    \"\"\"\n    Plots a profile of a quantity along the the z-axis.\n    If x or y are given the profile is plotted at this location, other wise it is averaged along this axis.\n\n    Args:\n        fname (str): The name of the quantity to plot (e.g., 'u', 'v', 'w', 'c', 'theta', 'T', 'epsilon', 'ti').\n        x (float, optional): The x-coordinate at which to plot the profile.\n        y (float, optional): The y-coordinate at which to plot the profile.\n        scaling (float, optional): A scaling factor for the quantity.\n        **kwargs: Additional keyword arguments for plot customization.\n\n    Returns:\n        np.ndarray: The profile of the quantity.\n    \"\"\"\n    if fname == 'u':\n        vel = self.u\n        unit = \"ms\"\n    elif fname == 'v':\n        vel = self.v\n        unit = \"ms\"\n    elif fname == \"wind_angle\":\n        vel = np.arctan(self.v, self.u)*180/np.pi\n    elif fname == 'w':\n        vel = self.w\n        unit = \"ms\"\n    elif fname == 'c':\n        vel = self.c\n        unit = \"ms\"\n    elif fname == 'theta':\n        vel = self.theta\n        unit = \"K\"\n    elif fname == 'T':\n        vel = self.T\n        unit = \"K\"\n    elif fname == 'epsilon':\n        if self.epsilon is None:\n            self.dissipation()\n        vel = self.epsilon\n        unit = \"m2/s3\"\n    elif fname == 'ti':\n        if self.ti is None:\n            self.turbulent_intensity()\n        vel = self.ti\n        unit = \"(-)\"\n    elif fname == 'initial_theta':\n        vel = self.initial_theta\n    else:\n        vel = h5py.File(self.path + fname, \"r\")\n        if ('_u' in fname) or ('_v' in fname) or ('_w' in fname):\n            vel = self.u_dim * np.array(vel['var'])\n            unit = 'm/s'\n        elif 'theta' in fname:\n            vel = self.T_scale * np.array(vel['var'])\n            unit = 'K'\n        else:\n            vel = np.array(vel['var'])\n            unit = 'm/s'\n\n    if len(vel.shape) == 3:\n        if x is not None:\n            ix = np.argmin(np.abs(x - self.x))\n            vel_profile = vel[:, :, ix]\n        else:\n            vel_profile = np.mean(vel, 2)\n\n        if y is not None:\n            iy = np.argmin(np.abs(y - self.y))\n            vel_profile = vel_profile[:, iy]\n        else:\n            vel_profile = np.mean(vel_profile, 1)\n    else:\n        vel_profile = vel\n    vel_profile = vel_profile[0:self.z.size]\n\n    if fname == \"epsilon\" or fname == \"ti\":\n        plt.plot(scaling * vel_profile[1:], self.zw[1:], **kwargs)\n    else:\n        plt.plot(scaling * vel_profile, self.z, **kwargs)\n    return vel_profile\n</code></pre>"},{"location":"reference/les.html#src.prepost.les.Les.readConvergence","title":"<code>readConvergence()</code>","text":"<p>Reads convergence data from a file and initializes the time, kinetic energy, friction, and temperature arrays.</p> Source code in <code>src/prepost/les.py</code> <pre><code>def readConvergence(self):\n    \"\"\"\n    Reads convergence data from a file and initializes the time, kinetic energy, friction, and temperature arrays.\n    \"\"\"\n    self.t = []\n    self.ke = []\n    self.friction = []\n    self.temp = []\n\n    in_file = open(self.path+'/output/check_ke.dat', 'rt')\n    for line in in_file:\n        dummy = line.split()\n        self.t.append(float(dummy[0]))\n        self.ke.append(float(dummy[1]))\n        self.friction.append(float(dummy[2]))\n        if len(dummy) == 4:\n            self.temp.append(float(dummy[3]))\n    self.t = np.array(self.t)\n    self.ke = np.array(self.ke)\n\n    if self.adim:\n        self.friction = np.array(self.friction)*self.u_dim\n    else:\n        self.friction = np.array(self.friction)\n\n    self.temp = np.array(self.temp)\n</code></pre>"},{"location":"reference/les.html#src.prepost.les.Les.plotConvergence","title":"<code>plotConvergence()</code>","text":"<p>Plots the convergence of kinetic energy, friction, and temperature over time.</p> Source code in <code>src/prepost/les.py</code> <pre><code>def plotConvergence(self):\n    \"\"\"\n    Plots the convergence of kinetic energy, friction, and temperature over time.\n    \"\"\"\n    t = []\n    ke = []\n    friction = []\n    temp = []\n\n    in_file = open (self.path+'/output/check_ke.dat', 'rt')\n    for line in in_file:\n        dummy = line.split()\n        t.append(float(dummy[0]))\n        ke.append(float(dummy[1]))\n        friction.append(float(dummy[2]))\n        if len(dummy)==4:\n            temp.append(float(dummy[3]))\n    plt.figure(figsize=(10,4))\n    plt.subplot(131)\n    plt.plot(t,ke)\n    plt.ylabel('ke')\n    plt.xlabel('t')\n    plt.subplot(132)\n    plt.plot(t,friction)\n    plt.ylabel('u*')\n    plt.xlabel('t')\n    plt.subplot(133)\n    if len(dummy)==4:\n        plt.plot(t,temp)\n    plt.ylabel('Tsurf')\n    plt.xlabel('t')\n    plt.tight_layout()\n\n    files_in_directory = os.listdir(self.path +'/output/')\n    file_name_prefix = \"angle_\"\n    matching_files = [file for file in files_in_directory if file.startswith(file_name_prefix)]\n    if matching_files:\n        iter = []\n        angles = []\n        for file in matching_files :\n            iter.append(int(file[6:-3]))\n            angles.append(list(h5py.File(self.path + '/output/' + file,'r')['var']))\n\n        plt.figure()\n        plt.plot(angles[-1])\n\n        angles_array = np.array(angles)\n        print(angles_array.shape)\n\n        plt.figure()\n        plt.plot(iter,angles_array[:,7])\n\n        plt.figure()\n        plt.plot(angles_array[-1,:])\n</code></pre>"},{"location":"reference/les.html#src.prepost.les.Les.takeProfile","title":"<code>takeProfile(x, y, ratio=1, epsilon=0.01)</code>","text":"<p>Takes velocity and dissipation profiles at specified x and y coordinates. This was previously used to give a 2D profile as input for the source model.  Now the interpolation at the segment position is directly performed during the source computation.</p> <p>Parameters:</p> <ul> <li> <code>x</code>               (<code>float</code>)           \u2013            <p>The x-coordinate at which to take the profile.</p> </li> <li> <code>y</code>               (<code>float</code>)           \u2013            <p>The y-coordinate at which to take the profile.</p> </li> <li> <code>ratio</code>               (<code>float</code>, default:                   <code>1</code> )           \u2013            <p>A scaling ratio for the velocity profile.</p> </li> <li> <code>epsilon</code>               (<code>float</code>, default:                   <code>0.01</code> )           \u2013            <p>The dissipation value to set.</p> </li> </ul> Source code in <code>src/prepost/les.py</code> <pre><code>def takeProfile(self, x: float, y: float, ratio: float = 1, epsilon: float = 0.01):\n    \"\"\"\n    Takes velocity and dissipation profiles at specified x and y coordinates.\n    This was previously used to give a 2D profile as input for the source model. \n    Now the interpolation at the segment position is directly performed during the source computation.\n\n    Args:\n        x (float): The x-coordinate at which to take the profile.\n        y (float): The y-coordinate at which to take the profile.\n        ratio (float, optional): A scaling ratio for the velocity profile.\n        epsilon (float, optional): The dissipation value to set.\n    \"\"\"\n    ix = np.argmin(np.abs(self.x-x))\n    iy = np.argmin(np.abs(self.y-y))\n\n    print('x=' + str(self.x[ix]) + ' instead of x_target=' + str(x))\n    print('y=' + str(self.y[iy]) + ' instead of y_target=' + str(y))\n\n    self.U_inf = self.u[:,iy,ix]*ratio\n    self.z_coord = self.z\n\n    if epsilon is None:\n        print(\"took real eps  profile\")\n        self.epsilon_Kol = self.epsilon[:,iy,ix]\n    else:\n        print(\"set eps to 0.01\")\n        self.epsilon_Kol = epsilon*np.ones((len(self.z_coord)))\n</code></pre>"},{"location":"reference/les.html#src.prepost.les.Les.constant_epsilon","title":"<code>constant_epsilon(epsilon)</code>","text":"<p>Sets a constant dissipation value.</p> <p>Parameters:</p> <ul> <li> <code>epsilon</code>               (<code>float</code>)           \u2013            <p>The dissipation value to set.</p> </li> </ul> Source code in <code>src/prepost/les.py</code> <pre><code>def constant_epsilon(self,epsilon):\n    \"\"\"\n    Sets a constant dissipation value.\n\n    Args:\n        epsilon (float): The dissipation value to set.\n    \"\"\"\n    self.epsilon_Kol = epsilon*np.ones((len(self.z_coord)))\n</code></pre>"},{"location":"reference/les.html#src.prepost.les.Les.dissipation","title":"<code>dissipation()</code>","text":"<p>Calculates the turbulence dissipation rate from the velocity gradient and shear tensor components.</p> Source code in <code>src/prepost/les.py</code> <pre><code>def dissipation(self):\n    \"\"\"\n    Calculates the turbulence dissipation rate from the velocity gradient and shear tensor components.\n    \"\"\"\n    # Read all the velocities and temperature\n    filnam = self.path + '/output/tavg_txxs11.h5'\n    if not os.path.isfile(filnam):\n        print('no epsilon computed')\n        return\n    vel = h5py.File(filnam,\"r\")\n    txxs11 = np.array(vel['var'])\n    txxs11 = txxs11[0:self.nz,:,:]\n    txxs11 = np.asarray(txxs11)\n\n    filnam = self.path + '/output/tavg_txys12.h5'\n    vel = h5py.File(filnam,\"r\")\n    txys12 = np.array(vel['var'])\n    txys12 = txys12[0:self.nz, :, :]\n    txys12 = np.asarray(txys12)\n\n    filnam = self.path + '/output/tavg_txzs13.h5'\n    vel = h5py.File(filnam, \"r\")\n    txzs13 = np.array(vel['var'])\n    txzs13 = txzs13[0:self.nz, :, :]\n    txzs13 = np.asarray(txzs13)\n    txzs13[0:self.nz-1,:,:] = 0.5 * (txzs13[0:self.nz-1,:,:] + txzs13[1:self.nz,:,:])\n\n    filnam = self.path + '/output/tavg_tyys22.h5'\n    vel = h5py.File(filnam,\"r\")\n    tyys22  = np.array(vel['var'])\n    tyys22  = tyys22[0:self.nz,:,:]\n    tyys22  = np.asarray(tyys22)\n\n    filnam = self.path + '/output/tavg_tyzs23.h5'\n    vel = h5py.File(filnam,\"r\")\n    dummy = np.array(vel['var'])\n    dummy = dummy[0:self.nz,:,:]\n    tyzs23 = np.asarray(dummy)\n    tyzs23[0:self.nz-1,:,:] = 0.5 * (tyzs23[0:self.nz-1,:,:] + tyzs23[1:self.nz,:,:])\n\n    filnam = self.path + '/output/tavg_tzzs33.h5'\n    vel = h5py.File(filnam,\"r\")\n    tzzs33 = np.array(vel['var'])\n    tzzs33 = tzzs33[0:self.nz,:,:]\n    tzzs33[0:self.nz-1,:,:] = 0.5 * (tzzs33[0:self.nz-1,:,:] + tzzs33[1:self.nz,:,:])\n    tzzs33 = np.asarray(tzzs33)\n\n    self.epsilon = - self.u_dim**3 / self.z_i * (txxs11 + tyys22 +  tzzs33 + 2.0 * txzs13 + 2.0 * tyzs23 + 2.0 * txys12)\n</code></pre>"},{"location":"reference/les.html#src.prepost.les.Les.turbulent_intensity","title":"<code>turbulent_intensity()</code>","text":"<p>Calculates the turbulent intensity from the velocity fluctuations.</p> Source code in <code>src/prepost/les.py</code> <pre><code>def turbulent_intensity(self):\n    \"\"\"\n    Calculates the turbulent intensity from the velocity fluctuations.\n    \"\"\"\n    filnam = self.path + '/output/tavg_u2.h5'\n    vel = h5py.File(filnam, \"r\")\n    u2 = np.array(vel['var'])\n\n    filnam = self.path + '/output/tavg_v2.h5'\n    vel = h5py.File(filnam, \"r\")\n    v2 = np.array(vel['var'])\n\n    filnam = self.path + '/output/tavg_w2.h5'\n    vel = h5py.File(filnam, \"r\")\n    w2 = np.array(vel['var'])\n    w2[0:self.nz-1,:,:] = 0.5 * (w2[0:self.nz-1,:,:] + w2[1:self.nz,:,:])\n\n    filnam = self.path + '/output/tavg_u.h5'\n    vel = h5py.File(filnam, \"r\")\n    u = np.array(vel['var'])\n\n    filnam = self.path + '/output/tavg_v.h5'\n    vel = h5py.File(filnam, \"r\")\n    v = np.array(vel['var'])\n\n    filnam = self.path + '/output/tavg_w.h5'\n    vel = h5py.File(filnam, \"r\")\n    w = np.array(vel['var'])\n    w[0:self.nz-1,:,:] = 0.5 * (self.w[0:self.nz-1,:,:] + self.w[1:self.nz,:,:])\n\n    TKE = 0.5*(u2 + v2 + w2 - (u**2 + v**2 + w**2))\n    self.ti =  np.sqrt(2.*TKE/3) / np.sqrt(u**2 + v**2 + w**2)\n</code></pre>"},{"location":"reference/les.html#src.prepost.les.Les.plotTurbineAngle","title":"<code>plotTurbineAngle()</code>","text":"<p>Plots the turbine angles from a data file.</p> Source code in <code>src/prepost/les.py</code> <pre><code>def plotTurbineAngle(self):\n    \"\"\"\n    Plots the turbine angles from a data file.\n    \"\"\"\n    i = 0\n    lines = []\n    data = []\n    in_file = open (self.path+'turbine/turbine0001.dat', 'rt')\n    for line in in_file:\n        lines.append(line)\n        dummy = lines[i].split()\n        data.append(dummy)\n        i+=1\n    self.data = np.array(data).astype(np.float)\n</code></pre>"},{"location":"reference/les.html#src.prepost.les.Les.plotXZ","title":"<code>plotXZ(y, u=True, eps=False, **kwargs)</code>","text":"<p>Warning</p> <p>The plotQuantityXZ() method should be preferred to this one (legacy).</p> <p>Plots a quantity in the XZ plane at a specified y-coordinate.</p> <p>Parameters:</p> <ul> <li> <code>y</code>               (<code>float</code>)           \u2013            <p>The y-coordinate at which to plot the quantity.</p> </li> <li> <code>u</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Flag to plot the u-component of velocity.</p> </li> <li> <code>eps</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Flag to plot the dissipation rate.</p> </li> <li> <code>**kwargs</code>           \u2013            <p>Additional keyword arguments for plot customization.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Axes</code>           \u2013            <p>plt.Axes: The matplotlib Axes object containing the plot.</p> </li> </ul> Source code in <code>src/prepost/les.py</code> <pre><code>def plotXZ(self, y: float, u: bool = True, eps: bool = False, **kwargs) -&gt; plt.Axes:\n    \"\"\"\n    !!! warning \n        The plotQuantityXZ() method should be preferred to this one (legacy).\n    Plots a quantity in the XZ plane at a specified y-coordinate.\n\n    Args:\n        y (float): The y-coordinate at which to plot the quantity.\n        u (bool, optional): Flag to plot the u-component of velocity.\n        eps (bool, optional): Flag to plot the dissipation rate.\n        **kwargs: Additional keyword arguments for plot customization.\n\n    Returns:\n        plt.Axes: The matplotlib Axes object containing the plot.\n    \"\"\"\n    iy = np.argmin(np.abs(self.y-y))\n    if u:\n        cax = plt.pcolormesh(self.x,self.z,self.u[:,iy,:],shading='gouraud',**kwargs)\n        plt.gca().set_aspect('equal', adjustable='box')\n        plt.xlabel('x (m)')\n        plt.ylabel('z (m)')\n        ax=plt.gca()\n        plt.rcParams[\"contour.negative_linestyle\"] = \"solid\"\n        contours = ax.contour(self.x,self.z,self.u[:,iy,:], [0,2,4,6,8,10,12,14,16],colors=\"b\",\n    linewidths=0.8,\n    alpha=0.3,)\n        ax.clabel(contours, contours.levels, inline=True, fontsize=10, colors=\"black\")\n        divider = make_axes_locatable(ax)\n        cb = divider.append_axes(\"right\", size=\"5%\", pad=0.05)\n        cb.set_title('u (m/s)')\n        plt.colorbar(cax, cax=cb)\n        plt.tight_layout()\n    if eps:\n        cax = plt.pcolormesh(self.x,self.z,self.epsilon[:,iy,:],shading='gouraud',**kwargs)\n        plt.gca().set_aspect('equal', adjustable='box')\n        plt.xlabel('x (m)')\n        plt.ylabel('z (m)')\n        ax=plt.gca()\n        divider = make_axes_locatable(ax)\n        cb = divider.append_axes(\"right\", size=\"5%\", pad=0.05)\n        cb.set_title('eps (m2/s3)')\n        plt.colorbar(cax, cax=cb)\n        plt.tight_layout()\n    return cax,ax\n</code></pre>"},{"location":"reference/les.html#src.prepost.les.Les.plotXY","title":"<code>plotXY(z, u=True, eps=False, **kwargs)</code>","text":"<p>Warning</p> <p>The plotQuantityXY() method should be preferred to this one (legacy).</p> <p>Plots a quantity in the XY plane at a specified z-coordinate.</p> <p>Parameters:</p> <ul> <li> <code>z</code>               (<code>float</code>)           \u2013            <p>The z-coordinate at which to plot the quantity.</p> </li> <li> <code>u</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Flag to plot the u-component of velocity.</p> </li> <li> <code>eps</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Flag to plot the dissipation rate.</p> </li> <li> <code>**kwargs</code>           \u2013            <p>Additional keyword arguments for plot customization.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Axes</code>           \u2013            <p>plt.Axes: The matplotlib Axes object containing the plot.</p> </li> </ul> Source code in <code>src/prepost/les.py</code> <pre><code>def plotXY(self, z: float, u: bool = True, eps: bool = False, **kwargs) -&gt; plt.Axes:\n    \"\"\"\n    !!! warning \n        The plotQuantityXY() method should be preferred to this one (legacy).\n    Plots a quantity in the XY plane at a specified z-coordinate.\n\n    Args:\n        z (float): The z-coordinate at which to plot the quantity.\n        u (bool, optional): Flag to plot the u-component of velocity.\n        eps (bool, optional): Flag to plot the dissipation rate.\n        **kwargs: Additional keyword arguments for plot customization.\n\n    Returns:\n        plt.Axes: The matplotlib Axes object containing the plot.\n    \"\"\"\n    iz = np.argmin(np.abs(self.z-z))\n\n    if u:\n        cax = plt.pcolormesh(self.x,self.y,self.u[iz,:,:],shading='gouraud',**kwargs)\n        plt.gca().set_aspect('equal', adjustable='box')\n        plt.xlabel('x (m)')\n        plt.ylabel('y (m)')\n        ax=plt.gca()\n        plt.rcParams[\"contour.negative_linestyle\"] = \"solid\"\n        ax.contour(self.x,self.y,self.u[iz,:,:], [0,2,4,6,8,10,12,14,16],colors=\"b\",\n    linewidths=0.8,\n    alpha=0.3,)\n        divider = make_axes_locatable(ax)\n        cb = divider.append_axes(\"right\", size=\"5%\", pad=0.05)\n        cb.set_title('u (m/s)')\n        plt.colorbar(cax, cax=cb)\n        plt.tight_layout()\n    if eps:\n        cax = plt.pcolormesh(self.x,self.y,self.epsilon[iz,:,:],shading='gouraud',**kwargs)\n        plt.gca().set_aspect('equal', adjustable='box')\n        plt.xlabel('x (m)')\n        plt.ylabel('y (m)')\n        ax=plt.gca()\n        divider = make_axes_locatable(ax)\n        cb = divider.append_axes(\"right\", size=\"5%\", pad=0.05)\n        cb.set_title('$\\\\epsilon$ (m2/s3)')\n        plt.colorbar(cax, cax=cb)\n        plt.tight_layout()\n    return cax,ax\n</code></pre>"},{"location":"reference/les.html#src.prepost.les.Les.plotYZ","title":"<code>plotYZ(x, **kwargs)</code>","text":"<p>Warning</p> <p>The plotQuantityYZ() method should be preferred to this one (legacy).</p> <p>Plots a quantity in the YZ plane at a specified x-coordinate.</p> <p>Parameters:</p> <ul> <li> <code>x</code>               (<code>float</code>)           \u2013            <p>The x-coordinate at which to plot the quantity.</p> </li> <li> <code>**kwargs</code>           \u2013            <p>Additional keyword arguments for plot customization.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Axes</code>           \u2013            <p>plt.Axes: The matplotlib Axes object containing the plot.</p> </li> </ul> Source code in <code>src/prepost/les.py</code> <pre><code>def plotYZ(self, x: float, **kwargs) -&gt; plt.Axes:\n    \"\"\"\n    !!! warning \n        The plotQuantityYZ() method should be preferred to this one (legacy).\n    Plots a quantity in the YZ plane at a specified x-coordinate.\n\n    Args:\n        x (float): The x-coordinate at which to plot the quantity.\n        **kwargs: Additional keyword arguments for plot customization.\n\n    Returns:\n        plt.Axes: The matplotlib Axes object containing the plot.\n    \"\"\"\n    ix = np.argmin(np.abs(self.x-x))\n    plt.pcolormesh(self.y,self.z,self.u[:,:,ix],cmap='RdBu_r',shading='gouraud',**kwargs)\n    plt.colorbar()\n    plt.gca().set_aspect('equal', adjustable='box')\n</code></pre>"},{"location":"reference/post.html","title":"Reference for <code>prepost/post.py</code>","text":""},{"location":"reference/post.html#src.prepost.post.PeResults","title":"<code>PeResults(casename, iTurb, height, tau, dirname='./', distribute_tau=None)</code>","text":"Source code in <code>src/prepost/post.py</code> <pre><code>def __init__(self, casename, iTurb, height, tau, dirname=\"./\", distribute_tau=None):\n    self.casename = casename\n    self.iTurb = iTurb\n    self.tau = tau\n    if int(tau) == tau:\n        self.tau_str = format(tau, \"04d\")\n    else:\n        self.tau_str = str(tau)\n\n    self.height = height\n    self.dirname = dirname\n    self.distribute_tau = distribute_tau\n    self.deltaL = None\n    self.receiver = None\n    self.THIRD = False\n</code></pre>"},{"location":"reference/post.html#src.prepost.post.DeltaLField","title":"<code>DeltaLField(dirname=None, casename=None)</code>","text":"<p>A class to read, and store a 2D deltaL field. created either from PE or LEE simulation results.</p> Source code in <code>src/prepost/post.py</code> <pre><code>def __init__(self, dirname: str = None, casename: str = None):\n    self.dirname = dirname\n    self.casename = casename\n    self.height = []\n\n    # variable for top view concatenation\n    self.tau = []\n    self.frequencies = []\n    self.deltaLlist = []\n    self.x_polar = None\n    self.y_polar = None\n    self.deltaL_polar = None\n\n    # variable for plane concatenation\n    self.slice_list = []\n    self.plane_list = []\n    self.plane_xlist = []\n    self.plane_ylist = []\n    self.plane_zlist = []\n\n    # variable for cartesian interpolation\n    self.x_cart = None\n    self.y_cart = None\n    self.z_cart = None\n    self.x_array = None\n    self.y_array = None\n    self.z_array = None\n    self.deltaL_cart = None\n\n    self.hindex = 0\n    self.tauindex = 0\n    if (dirname is not None) and (casename is not None):\n        self.simu = Simu(casename)\n        self.simu.load(dirname + casename + \".dat\")\n</code></pre>"},{"location":"reference/post.html#src.prepost.post.DeltaLField.save","title":"<code>save(fname)</code>","text":"<p>save data in a pick le .dat file. bif matrix are store in h5 files in order to open only part of the data</p> Source code in <code>src/prepost/post.py</code> <pre><code>def save(self,fname: str):\n    \"\"\"save data in a pick le .dat file. bif matrix are store in h5 files in order to open only part of the data\n    \"\"\"\n    print('saving Delta L ...')\n    self.deltaLlist = None\n    self.simu = None\n    with  h5py.File(fname[:-3]+'h5', \"w\") as f:\n        if self.x_polar is not None:\n            f.create_dataset('x_polar', data=self.x_polar)\n            self.x_polar = None\n        if self.y_polar is not None:\n            f.create_dataset('y_polar', data=self.y_polar)\n            self.y_polar = None\n        if self.deltaL_polar is not None:\n            f.create_dataset('deltaL_polar', data=self.deltaL_polar)\n            self.deltaL_polar = None\n\n        if self.x_cart is not None:\n            f.create_dataset('x_cart', data=self.x_cart)\n            self.x_cart = None\n\n        if self.y_cart is not None:\n            f.create_dataset('y_cart', data=self.y_cart)\n            self.y_cart = None\n\n        if self.z_cart is not None:\n            f.create_dataset('z_cart', data=self.z_cart)\n            self.z_cart = None\n\n        if self.deltaL_cart is not None:\n            f.create_dataset('deltaL_cart', data=self.deltaL_cart)\n            self.deltaL_cart = None\n\n        if self.x_array is not None:\n            f.create_dataset('x_array', data=self.x_array)\n            self.x_array = None\n\n        if self.y_array is not None:\n            f.create_dataset('y_array', data=self.y_array)\n            self.y_array= None\n\n        if self.z_array is not None:\n            f.create_dataset('z_array', data=self.z_array)\n            self.z_array= None\n\n    \"\"\"save class as self.name.dat\"\"\"\n    with open(fname,'wb') as file:\n        pickle.dump(self.__dict__,file)\n    print('done.')\n</code></pre>"},{"location":"reference/post.html#src.prepost.post.DeltaLField.load","title":"<code>load(fname, polar=True, cart=True)</code>","text":"<p>try load self.name.dat</p> Source code in <code>src/prepost/post.py</code> <pre><code>def load(self,fname: str,polar=True,cart=True):\n    \"\"\"try load self.name.dat\"\"\"\n    print('loading delta L ...')\n    with open(fname,'rb') as file:\n        self.__dict__ = pickle.load(file)\n    print('done loading pickle')\n\n    with h5py.File(fname[:-3]+'h5', \"r\") as f:\n        if ('deltaL_polar' in f) and (polar):\n            self.deltaL_polar = np.array(f['deltaL_polar'])\n            self.x_polar = np.array(f['x_polar'])\n            self.y_polar = np.array(f['y_polar'])\n\n        if (('deltaL_cart' in f) and cart):\n            self.deltaL_cart = np.array(f['deltaL_cart'])\n\n            self.x_cart = np.array(f['x_cart'])\n            self.y_cart = np.array(f['y_cart'])\n            self.z_cart = np.array(f['z_cart'])\n\n            self.x_array = np.array(f['x_array'])\n            self.y_array = np.array(f['y_array'])\n            self.z_array = np.array(f['z_array'])\n    print('done.')\n</code></pre>"},{"location":"reference/post.html#src.prepost.post.DeltaLField.save_old","title":"<code>save_old(fname)</code>","text":"<p>save class as self.name.dat</p> Source code in <code>src/prepost/post.py</code> <pre><code>def save_old(self, fname: str):\n    \"\"\"save class as self.name.dat\"\"\"\n    with open(fname, \"wb\") as file:\n        pickle.dump(self.__dict__, file)\n</code></pre>"},{"location":"reference/post.html#src.prepost.post.DeltaLField.fname","title":"<code>fname(iTurb, tau, height, distribute_tau)</code>","text":"<p>construct the name of th h5 file storing the pe results.     the data stucture is such that if tau is not distibuted:       /t//.h5     if tau is distributed       /t//tau/.h5 <p>Returns:</p> <ul> <li> <code>str</code> (              <code>str</code> )          \u2013            <p>return the string for the complete path to the h5 file</p> </li> </ul> Source code in <code>src/prepost/post.py</code> <pre><code>def fname(self, iTurb: int, tau: float, height: float, distribute_tau: int) -&gt; str:\n    \"\"\"construct the name of th h5 file storing the pe results.\n        the data stucture is such that if tau is not distibuted:\n          &lt;self.dirname&gt;/t&lt;iTurb&gt;/&lt;height&gt;/&lt;self.casename&gt;_&lt;tau&gt;.h5\n        if tau is distributed\n          &lt;self.dirname&gt;/t&lt;iTurb&gt;/&lt;height&gt;/tau&lt;itau&gt;/&lt;self.casename&gt;_&lt;tau&gt;.h5\n\n    Returns:\n        str: return the string for the complete path to the h5 file\n    \"\"\"\n\n    # convert angle to str format\n    if int(tau) == tau:\n        tau_str = format(tau, \"04d\")\n    else:\n        tau_str = str(tau)\n\n    # if tau distributed find the right folder\n    if distribute_tau is not None:\n        for kk in range(distribute_tau):\n            path = (\n                self.dirname\n                + \"t\"\n                + str(iTurb)\n                + \"/\"\n                + str(height)\n                + \"/tau\"\n                + str(kk)\n                + \"/\"\n            )\n            if os.path.isfile(path + self.casename + \"_\" + tau_str + \".h5\"):\n                break\n    # define directly the folder\n    else:\n        path = self.dirname + \"t\" + str(iTurb) + \"/\" + str(height) + \"/\"\n    return path + self.casename + \"_\" + tau_str + \".h5\"\n</code></pre> <p></p>"},{"location":"reference/post.html#src.prepost.post.DeltaLField.read_carto","title":"<code>read_carto(iTurb, height, tau, distribute_tau)</code>","text":"<p>Parameters:</p> <ul> <li> <code>iTurb</code>               (<code>int</code>)           \u2013            <p>description</p> </li> <li> <code>height</code>               (<code>float</code>)           \u2013            <p>description</p> </li> <li> <code>tau</code>               (<code>float</code>)           \u2013            <p>description</p> </li> <li> <code>distribute_tau</code>               (<code>bool</code>)           \u2013            <p>description</p> </li> </ul> Source code in <code>src/prepost/post.py</code> <pre><code>def read_carto(self, iTurb: int, height: float, tau: float, distribute_tau: bool):\n    \"\"\"\n\n    Args:\n        iTurb (int): _description_\n        height (float): _description_\n        tau (float): _description_\n        distribute_tau (bool): _description_\n    \"\"\"\n    res = PeResults(\n        self.casename,\n        iTurb,\n        height,\n        tau,\n        dirname=self.dirname,\n        distribute_tau=distribute_tau,\n    )\n    fname = self.fname(iTurb, tau, height, distribute_tau)\n    res.read_carto(fname)\n    # find height and tau index of the simulation\n    [x_grid, z_grid] = np.meshgrid(res.x, res.z, indexing=\"ij\")\n\n    # add height and tau to list if not already read\n    if height not in self.height:\n        self.height.append(height)\n    if tau not in self.tau:\n        self.tau.append(tau)\n\n    deltaL = {}\n    deltaL[\"height\"] = height\n    deltaL[\"tau\"] = tau\n    deltaL[\"freq\"] = res.frequencies\n    deltaL[\"x\"] = res.x\n    deltaL[\"z\"] = res.z\n    deltaL[\"x_grid\"] = x_grid\n    deltaL[\"z_grid\"] = z_grid\n    deltaL[\"val\"] = res.deltaL\n    self.deltaLlist.append(deltaL)\n</code></pre>"},{"location":"reference/post.html#src.prepost.post.DeltaLField.read_receiver","title":"<code>read_receiver(iTurb, height, tau, distribute_tau)</code>","text":"<p>read lines of receiver from PE results. stored in self.deltaL.list</p> <p>Parameters:</p> <ul> <li> <code>iTurb</code>               (<code>int</code>)           \u2013            <p>turbine index</p> </li> <li> <code>height</code>               (<code>float</code>)           \u2013            <p>source height</p> </li> <li> <code>tau</code>               (<code>float</code>)           \u2013            <p>propagation angle</p> </li> <li> <code>distribute_tau</code>               (<code>bool</code>)           \u2013            <p>wether simulation were parallized over tau</p> </li> </ul> Source code in <code>src/prepost/post.py</code> <pre><code>def read_receiver(\n    self, iTurb: int, height: float, tau: float, distribute_tau: bool\n):\n    \"\"\"read lines of receiver from PE results. stored in self.deltaL.list\n\n    Args:\n        iTurb (int): turbine index\n        height (float): source height\n        tau (float): propagation angle\n        distribute_tau (bool): wether simulation were parallized over tau\n    \"\"\"\n    res = PeResults(\n        self.casename,\n        iTurb,\n        height,\n        tau,\n        dirname=self.dirname,\n        distribute_tau=distribute_tau,\n    )\n    fname = self.fname(iTurb, tau, height, distribute_tau)\n    res.read_receiver(fname)\n    # find height and tau index of the simulation\n    [x_grid, z_grid] = np.meshgrid(res.x, res.z, indexing=\"ij\")\n\n    # add height and tau to list if not already read\n    if height not in self.height:\n        self.height.append(height)\n    if tau not in self.tau:\n        self.tau.append(tau)\n\n    deltaL = {}\n    deltaL[\"height\"] = height\n    deltaL[\"tau\"] = tau\n    deltaL[\"freq\"] = res.frequencies\n    deltaL[\"x\"] = res.x\n    deltaL[\"z\"] = res.heights\n    deltaL[\"x_grid\"] = x_grid\n    deltaL[\"z_grid\"] = z_grid\n    deltaL[\"val\"] = res.receiver\n    self.deltaLlist.append(deltaL)\n</code></pre>"},{"location":"reference/post.html#src.prepost.post.DeltaLField.check_compatibility","title":"<code>check_compatibility()</code>","text":"<p>check compatibility between all solution recorded in self.deltaLlist</p> Source code in <code>src/prepost/post.py</code> <pre><code>def check_compatibility(self):\n    \"\"\"check compatibility between all solution recorded in self.deltaLlist\"\"\"\n    if not self.deltaLlist:\n        logging.warning(\"you need to read some PE results first ...\")\n        return -1\n\n    # check frequencies\n    frequencies = [deltaL[\"freq\"] for deltaL in self.deltaLlist]\n    flag,error_index = chkList(frequencies)\n    if flag:\n        logging.info(\"frequencies OK\")\n        logging.info( frequencies[0] )\n    else:\n        logging.warning(\"frequency are not the same\")\n        logging.warning(\"error for (h,tau)=(%s,%s)\" % (self.deltaLlist[error_index][\"height\"], \n                                                       self.deltaLlist[error_index][\"tau\"]))\n        return -1\n\n    # check receievr Heights\n    heights = [deltaL[\"z\"] for deltaL in self.deltaLlist]\n    if chkList(heights)[0]:\n        logging.info(\"receiver heights OK\")\n        logging.info(heights[0])\n    else:\n        logging.warning(\"receiver heights are not the same\")\n        return -1\n</code></pre>"},{"location":"reference/post.html#src.prepost.post.DeltaLField.concatenate_angles","title":"<code>concatenate_angles()</code>","text":"<p>concatenate all loaded angles in a same array. Find minimum and maximum values for x. Create the array of shape (Nx,Nz, Ntau, Nfreq, Nheight) and fiel it with the resultst from deltaLlist.</p> Source code in <code>src/prepost/post.py</code> <pre><code>def concatenate_angles(self):\n    \"\"\"concatenate all loaded angles in a same array.\n    Find minimum and maximum values for x.\n    Create the array of shape (Nx,Nz, Ntau, Nfreq, Nheight) and fiel it with the resultst from deltaLlist.\n    \"\"\"\n\n    # find xmin, xmax\n    # ---------------------------------------------------------------------------------------\n    # initialize min max values\n    xmin = self.deltaLlist[0][\"x\"][0]\n    xmax = self.deltaLlist[0][\"x\"][-1]\n\n    # browse all deltaL to find min max values\n    for ii in range(1, len(self.deltaLlist)):\n        if self.deltaLlist[ii][\"x\"][0] &lt; xmin:\n            xmin = self.deltaLlist[ii][\"x\"][0]\n        if self.deltaLlist[ii][\"x\"][-1] &gt; xmax:\n            xmax = self.deltaLlist[ii][\"x\"][-1]\n\n    # rearange height and tau\n    # ---------------------------------------------------------------------------------------\n    self.height.sort()\n    self.tau.sort()\n    self.height = np.array(self.height)\n    self.tau = np.array(self.tau)\n    self.frequencies = self.deltaLlist[0][\"freq\"]\n\n    self.ntau = len(self.tau)\n    self.nheight = len(self.height)\n\n    # reshaping\n    # ---------------------------------------------------------------------------------------\n    # assuming all dx are the same\n    dx = self.deltaLlist[-1][\"x\"][1] - self.deltaLlist[-1][\"x\"][0]\n    # creating grid for x\n    self.x = np.arange(xmin, xmax + dx, dx)\n    self.nx = len(self.x)\n    # creating grid for z\n    self.z = self.deltaLlist[-1][\"z\"]\n    self.nz = len(self.z)\n\n    # create the complete matrix of deltaL\n    self.Nfreq = len(self.deltaLlist[-1][\"freq\"])\n    self.deltaL_polar = np.zeros(\n        (self.nx, self.nz, self.ntau, self.Nfreq, self.nheight)\n    )\n    # [self.x_grid,self.z_grid] = np.meshgrid(self.x, self.z,indexing='ij')\n\n    for deltaL in self.deltaLlist:\n        iheight = np.argmin(abs(self.height - deltaL[\"height\"]))\n        itau = np.argmin(abs(self.tau - deltaL[\"tau\"]))\n        # find corresponding index\n        ixmin = np.argmin(abs(self.x - deltaL[\"x\"][0]))\n        ixmax = np.argmin(abs(self.x - deltaL[\"x\"][-1]))\n        logging.info(\"height = \" + str(deltaL[\"height\"]) + \", tau = \" + str(deltaL[\"tau\"]))\n        self.deltaL_polar[ixmin : ixmax + 1, :, itau, :, iheight] = deltaL[\"val\"][\n            :, :, :\n        ]\n\n    # create polar mesh\n    angles = np.reshape(self.tau * np.pi / 180, (1, -1))\n    r = np.reshape(self.x, (-1, 1))\n\n    self.x_polar = r * np.cos(angles)\n    self.y_polar = r * np.sin(angles)\n</code></pre>"},{"location":"reference/post.html#src.prepost.post.DeltaLField.interpolate_from_polar","title":"<code>interpolate_from_polar(x, y)</code>","text":"<p>Define a cartesian mesh from x and y. Interpolate from deltaL_polar.     create the deltaL_cartesian field.</p> <p>Parameters:</p> <ul> <li> <code>x</code>               (<code>ndarray</code>)           \u2013            <p>1D array of the x position on which to interpolate</p> </li> <li> <code>y</code>               (<code>ndarray</code>)           \u2013            <p>1D array of the y position on which to interpolate</p> </li> </ul> Source code in <code>src/prepost/post.py</code> <pre><code>def interpolate_from_polar(self, x: np.ndarray, y: np.ndarray):\n    \"\"\"Define a cartesian mesh from x and y. Interpolate from deltaL_polar.\n        create the deltaL_cartesian field.\n\n    Args:\n        x (np.ndarray): 1D array of the x position on which to interpolate\n        y (np.ndarray): 1D array of the y position on which to interpolate\n    \"\"\"\n    # create vector of coordinates of the original grid\n    xy_polar = np.concatenate(\n        (self.x_polar.reshape((-1, 1)), self.y_polar.reshape((-1, 1))), 1\n    )\n\n    print(\"start interpolation ...\")\n    # create vector of coordinates of the new grid\n    self.x_cart, self.y_cart = np.meshgrid(x, y, indexing=\"ij\")\n    xy_cart = np.zeros([self.x_cart.shape[0] * self.x_cart.shape[1], 2])\n    xy_cart[:, 0] = self.x_cart.flatten()\n    xy_cart[:, 1] = self.y_cart.flatten()\n    # create knots for the interpolation\n    vtx, wts = interp_weights(xy_polar, xy_cart)\n    print(\"finished creating knot ...\")\n\n    self.deltaL_cart = np.zeros(\n        (\n            self.x_cart.shape[0],\n            self.x_cart.shape[1],\n            self.nz,\n            self.Nfreq,\n            self.nheight,\n        )\n    )\n    # loop of z, freq, heights and interpolate using the previously computes knots\n    print(\"starting loop on height and frequency band ...\")\n    for iz in range(self.nz):\n        for ifreq in range(self.Nfreq):\n            for iheight in range(self.nheight):\n                values = self.deltaL_polar[:, iz, :, ifreq, iheight].flatten()\n                valuesInterpolated = interpolate(values, vtx, wts)\n                self.deltaL_cart[\n                    :, :, iz, ifreq, iheight\n                ] = valuesInterpolated.reshape(\n                    self.x_cart.shape[0], self.x_cart.shape[1]\n                )\n    print(\"done\")\n    # save the interpolation grid\n    [self.x_cart, self.y_cart, self.z_cart] = np.meshgrid(\n        x, y, self.z, indexing=\"ij\"\n    )\n    self.x_array = x\n    self.y_array = y\n    self.z_array = self.z\n    self.nx = len(x)\n    self.ny = len(y)\n    self.nz = len(self.z)\n</code></pre>"},{"location":"reference/post.html#src.prepost.post.DeltaLField.interpolate_planes","title":"<code>interpolate_planes(x=None, y=None)</code>","text":"<p>Interpolate from previously recorded slice. </p> <p>Parameters:</p> <ul> <li> <code>x</code>               (<code>ndarray</code>, default:                   <code>None</code> )           \u2013            <p>description. Defaults to None.</p> </li> <li> <code>y</code>               (<code>ndarray</code>, default:                   <code>None</code> )           \u2013            <p>description. Defaults to None.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>_type_</code>          \u2013            <p>description</p> </li> </ul> Source code in <code>src/prepost/post.py</code> <pre><code>def interpolate_planes(self, x: np.ndarray = None, y: np.ndarray = None):\n    \"\"\"Interpolate from previously recorded slice. \n\n    Args:\n        x (np.ndarray, optional): _description_. Defaults to None.\n        y (np.ndarray, optional): _description_. Defaults to None.\n\n    Returns:\n        _type_: _description_\n    \"\"\"\n    if x is not None:\n        # check\n        if len(self.plane_list) == 0:\n            print(\"not planes loaded\")\n            return -1\n        if self.plane_list[0].shape[1] != 1:\n            print(\"probably loaded x constant planes and not y constant\")\n            return -1\n\n        z = self.plane_zlist[0]\n        self.deltaL_cart = np.zeros(\n            (len(x), len(self.plane_ylist), len(z), self.Nfreq, self.nheight)\n        )\n        y_coord = []\n        X, Z = np.meshgrid(x, z, indexing=\"ij\")\n        for ii in range(len(self.plane_list)):\n            x_grid, z_grid = np.meshgrid(\n                self.plane_xlist[ii], self.plane_zlist[ii], indexing=\"ij\"\n            )\n            y_coord.append(self.plane_ylist[ii][0])\n            for ifreq in range(self.Nfreq):\n                for iheight in range(self.nheight):\n                    # if not a lot of point spline interpolation\n                    # if x_grid.size&lt;200000 :\n                    if x_grid.size &lt; 2:\n                        tck = bisplrep(\n                            x_grid,\n                            z_grid,\n                            np.squeeze(\n                                self.plane_list[ii][:, :, :, ifreq, iheight]\n                            ),\n                        )\n                        self.deltaL_cart[:, ii, :, ifreq, iheight] = bisplev(\n                            x, z, tck\n                        )\n                    # else linear interpolation\n                    else:\n                        tck = RegularGridInterpolator(\n                            (self.plane_xlist[ii], self.plane_zlist[ii]),\n                            np.squeeze(\n                                self.plane_list[ii][:, :, :, ifreq, iheight]\n                            ),\n                            bounds_error=False,\n                            fill_value=None,\n                            method=\"linear\",\n                        )\n                        self.deltaL_cart[:, ii, :, ifreq, iheight] = tck((X, Z))\n\n        y_coord = np.array(y_coord)\n        [self.x_cart, self.y_cart, self.z_cart] = np.meshgrid(\n            x, y_coord, z, indexing=\"ij\"\n        )\n        self.x_array = x\n        self.y_array = y_coord\n        self.z_array = z\n        self.nx = len(x)\n        self.ny = len(y_coord)\n        self.nz = len(z)\n\n    if y is not None:\n        # check\n        if len(self.plane_list) == 0:\n            print(\"not planes loaded\")\n            return -1\n        if self.plane_list[0].shape[0] != 1:\n            print(\"probably loaded y constant planes and not x constant\")\n            return -1\n\n        z = self.plane_zlist[0]\n        self.deltaL_cart = np.zeros(\n            (len(self.plane_xlist), len(y), len(z), self.Nfreq, self.nheight)\n        )\n\n        x_coord = []\n        Y, Z = np.meshgrid(y, z, indexing=\"ij\")\n        for ii in range(len(self.plane_list)):\n            y_grid, z_grid = np.meshgrid(\n                self.plane_ylist[ii], self.plane_zlist[ii], indexing=\"ij\"\n            )\n            x_coord.append(self.plane_xlist[ii][0])\n            for ifreq in range(self.Nfreq):\n                for iheight in range(self.nheight):\n                    # if y_grid.size&lt;200000 :\n                    if y_grid.size &lt; 2:\n                        tck = bisplrep(\n                            y_grid,\n                            z_grid,\n                            np.squeeze(\n                                self.plane_list[ii][:, :, :, ifreq, iheight]\n                            ),\n                        )\n                        self.deltaL_cart[ii, :, :, ifreq, iheight] = bisplev(\n                            y, z, tck\n                        )\n                    else:\n                        tck = RegularGridInterpolator(\n                            (self.plane_ylist[ii], self.plane_zlist[ii]),\n                            np.squeeze(\n                                self.plane_list[ii][:, :, :, ifreq, iheight]\n                            ),\n                            bounds_error=False,\n                            fill_value=None,\n                            method=\"linear\",\n                        )\n                        self.deltaL_cart[ii, :, :, ifreq, iheight] = tck((Y, Z))\n        x_coord = np.array(x_coord)\n\n        [self.x_cart, self.y_cart, self.z_cart] = np.meshgrid(\n            x_coord, y, z, indexing=\"ij\"\n        )\n        self.x_array = x_coord\n        self.y_array = y\n        self.z_array = z\n        self.nx = len(x_coord)\n        self.ny = len(y)\n        self.nz = len(z)\n    return\n</code></pre>"},{"location":"reference/post.html#src.prepost.post.DeltaLField.loop_angle","title":"<code>loop_angle()</code>","text":"<p>used to create tau = 360 from tau =0. This is done before using self.interpolate_from_polar.</p> Source code in <code>src/prepost/post.py</code> <pre><code>def loop_angle(self):\n    \"\"\"used to create tau = 360 from tau =0. This is done before using self.interpolate_from_polar. \n\n    \"\"\"\n    # check if the first angle is indeed 0 \n    if self.tau[0] != 0:\n        print(\"first angle is not 0\")\n        return -1\n\n    # create the new deltaL \n    deltaL = np.zeros((self.nx, self.nz, self.ntau + 1, self.Nfreq, self.nheight))\n    tau = np.zeros((self.ntau + 1,))\n    deltaL[:, :, 0:-1, :, :] = self.deltaL_polar\n    deltaL[:, :, -1, :, :] = self.deltaL_polar[:, :, 0, :, :]\n\n    tau[0:-1] = self.tau\n    tau[-1] = 360\n    self.tau = tau\n    self.deltaL_polar = deltaL\n    self.ntau = len(self.tau)\n</code></pre>"},{"location":"reference/post.html#src.prepost.post.DeltaLField.plot_top_polar","title":"<code>plot_top_polar(z, freq, height, cmap='RdBu_r', **kwargs)</code>","text":"<p>plot top view of deltaL field at a given z, frequency, and for a given source</p> <p>Parameters:</p> <ul> <li> <code>z</code>               (<code>float</code>)           \u2013            <p>receiver height</p> </li> <li> <code>freq</code>               (<code>float</code>)           \u2013            <p>frequency</p> </li> <li> <code>height</code>               (<code>float</code>)           \u2013            <p>source height</p> </li> <li> <code>cmap</code>               (<code>str</code>, default:                   <code>'RdBu_r'</code> )           \u2013            <p>colormap. Defaults to 'RdBu_r'.</p> </li> </ul> Source code in <code>src/prepost/post.py</code> <pre><code>def plot_top_polar(self, z: float, freq: float, height: float, cmap=\"RdBu_r\", **kwargs):\n    \"\"\"plot top view of deltaL field at a given z, frequency, and for a given source\n\n    Args:\n        z (float): receiver height\n        freq (float): frequency\n        height (float): source height\n        cmap (str, optional): colormap. Defaults to 'RdBu_r'.\n    \"\"\"\n    ifreq = np.nonzero(self.frequencies == freq)[0][0]\n    iz = np.nonzero(self.z == z)[0][0]\n    iheight = np.nonzero(self.height == height)[0][0]\n\n    cax = plt.pcolormesh(\n        self.x_polar,\n        self.y_polar,\n        self.deltaL_polar[:, iz, :, ifreq, iheight],\n        cmap=cmap,\n        shading=\"auto\",\n        **kwargs\n    )\n    plt.gca().set_aspect(\"equal\", adjustable=\"box\")\n    plt.xlabel(\"x (m)\")\n    plt.ylabel(\"y (m)\")\n    ax = plt.gca()\n    divider = make_axes_locatable(ax)\n    cb = divider.append_axes(\"right\", size=\"5%\", pad=0.05)\n    cb.set_title(\"$\\Delta L$ (dB)\")\n    plt.colorbar(cax, cax=cb)\n    plt.tight_layout()\n    return ax\n</code></pre>"},{"location":"reference/pre.html","title":"Reference for <code>prepost/pre.py</code>","text":""},{"location":"reference/pre.html#src.prepost.pre.Simu","title":"<code>Simu(casename)</code>","text":"<p>Create an Instance Simu, with a dictionnary of input for a PE simulation. This class is used to define the complete simulation of a wind farm.  It allows to set the global input parameters for the PE simulations, to define a LES as input for the simulation.  This will set the number of turbine and ther position inside the flow.  The acoustic domain for the simulation can also be defines allong with the number of propagation angle and source height for each turbine. </p> <p>The global parameter for the PE simulation are saved in a dictionary self.inputs. Methods are also define to create the different input file the fortran PE simulation.  The source code used for the PE simulation can be found in <code>src/kernel/New_PE_c/</code>.</p> <p>Parameters:</p> <ul> <li> <code>casename</code>               (<code>str</code>)           \u2013            <p>name of the case</p> </li> </ul> Source code in <code>src/prepost/pre.py</code> <pre><code>def __init__(self, casename: str):\n    self.casename = casename\n    self.xplanes = None\n    self.yplanes = None\n    self.inputs = {\n        \"case_name\": str(casename),\n        \"var0%c\": 343,\n        \"var0%rho\": 1.2,\n        \"var0%gamma\": 1.4,\n\n        \"nb_freq\": 3,\n        \"frequencies(1)\": [100, 500, 1000],\n\n        \"nb_theta\": 1,\n        \"theta(1)\": 0,\n\n        \"Lx1\": 3000.,\n        \"Lx2\": 1000.,\n        \"Ly1\": 1000.,\n        \"Ly2\": 1000.,\n        \"Lz\": 300.,\n        \"dx\": 0.5,\n        \"cfl\": 0.1,\n\n        \"size\": 30,\n        \"param\": 5e4,\n        \"n\": 2.5,\n\n        \"imp%sigmae\": 50e3,\n        \"imp%alphae\": 100.,\n        \"imp%rigid\": False,\n\n        \"src%pos_x\": 0.,\n        \"src%pos_z\": 100.,\n\n        \"external_flow\": True,\n        \"uniform\": False,\n        \"logarithmic\": False,\n        \"u0\": 0,\n        \"arbitrary\": True,\n        \"arbitrary_new\": False,\n        \"interpolation\": True,\n\n        \"fdir\": '/2Dhill/caseA_flat/blue/output/',\n        \"fname\": 'tavg',\n\n        \"tinput%ratio\": 1,\n        \"tinput%z_i\": 625.,\n        \"tinput%delta\": 0.25,\n        \"tinput%T_scale_K\": 265,\n        \"tinput%Lx\": 10.,\n        \"tinput%Ly\": 1.,\n        \"tinput%Lz\": 1.,\n\n        \"tinput%posx\": 1.875,\n        \"tinput%posy\": 0.5,\n        \"tinput%posz\": 0.04,\n\n\n        \"dout\": 1,\n        \"nb_receiver\": 3,\n        \"heights(1)\": [2., 10, 100],\n        \"side\": True,\n        \"top\": False,\n        \"continuation\": False,\n\n    }\n</code></pre>"},{"location":"reference/pre.html#src.prepost.pre.Simu.readLes","title":"<code>readLes(path)</code>","text":"<p>Reads and adds a LES flow simulation and stores it as a <code>prepost.les.Les</code> object. The Path must lead to a folder containing the <code>input.conf</code> file and <code>output/</code> directory corresponding to a LES perfomed with Twente code. The <code>turbine_input.dat</code> is also used to determine the position of the turbines inside the flow.</p> <p>Parameters:</p> <ul> <li> <code>path</code>               (<code>str</code>)           \u2013            <p>Path to the LES data.</p> </li> </ul> Source code in <code>src/prepost/pre.py</code> <pre><code>def readLes(self, path: str):\n    \"\"\"Reads and adds a LES flow simulation and stores it as a `prepost.les.Les` object.\n    The Path must lead to a folder containing the `input.conf` file and `output/` directory corresponding to a LES perfomed with Twente code.\n    The `turbine_input.dat` is also used to determine the position of the turbines inside the flow.\n\n    Args:\n        path (str): Path to the LES data.\n    \"\"\"\n    self.les = Les(path)\n    self.les.read()\n    print('les domain dimension:')\n    print(self.les.L_x, self.les.L_y, self.les.L_z)\n    print(str(self.les.turbines.shape[0])+' wind turbines :')\n    print(self.les.turbines)\n</code></pre>"},{"location":"reference/pre.html#src.prepost.pre.Simu.createInputFile","title":"<code>createInputFile(directory='./')</code>","text":"<p>Creates an input.nml file for the WAPE simulations from the <code>self.inputs</code> dictionary.</p> <p>Parameters:</p> <ul> <li> <code>directory</code>               (<code>str</code>, default:                   <code>'./'</code> )           \u2013            <p>Directory to save the input file. Defaults to './'.</p> </li> </ul> Source code in <code>src/prepost/pre.py</code> <pre><code>def createInputFile(self, directory: str = './'):\n    \"\"\"Creates an input.nml file for the WAPE simulations from the `self.inputs` dictionary.\n\n    Args:\n        directory (str, optional): Directory to save the input file. Defaults to './'.\n    \"\"\"\n    f = open(directory + '/input.nml', 'w')\n    f.write(\"$input\\n\")\n    for key, value in self.inputs.items():\n        if type(value) == str:\n            f.write(\"%s='%s'\\n\" % (key, value))\n        elif type(value) == bool:\n            if value:\n                f.write(\"%s=%s\\n\" % (key, '.true.'))\n            else:\n                f.write(\"%s=%s\\n\" % (key, '.false.'))\n        elif isinstance(value, list):\n            f.write(\"%s=%s\\n\" % (key, str(value)[1:-1]))\n        else:\n            f.write(\"%s=%s\\n\" % (key, str(value)))\n    f.write('$end input')\n    f.close()\n    return\n</code></pre>"},{"location":"reference/pre.html#src.prepost.pre.Simu.set_input","title":"<code>set_input(key, value)</code>","text":"<p>Sets an input in the inputs dictionary. This is used to add or modified parameters for the WAPE simulations.  Be ware that there is no check that a given parameter is indeed needed for the simulations.  There is also no check that all the paramaters needed are presente in the <code>self.inputs</code> dictionnary.</p> <p>Parameters:</p> <ul> <li> <code>key</code>               (<code>str</code>)           \u2013            <p>Key of the input.</p> </li> <li> <code>value</code>               (<code>Any</code>)           \u2013            <p>Value of the input.</p> </li> </ul> Source code in <code>src/prepost/pre.py</code> <pre><code>def set_input(self, key: str, value: any):\n    \"\"\"Sets an input in the inputs dictionary.\n    This is used to add or modified parameters for the WAPE simulations. \n    Be ware that there is no check that a given parameter is indeed needed for the simulations. \n    There is also no check that all the paramaters needed are presente in the `self.inputs` dictionnary.\n\n    Args:\n        key (str): Key of the input.\n        value (Any): Value of the input.\n    \"\"\"\n    if isinstance(value, np.ndarray):\n        self.inputs[key] = value.tolist()\n    else:\n        self.inputs[key] = value\n</code></pre>"},{"location":"reference/pre.html#src.prepost.pre.Simu.set_frequencies","title":"<code>set_frequencies(fc, Nfc=None)</code>","text":"<p>Sets the frequencies for the simulation. If only fc is given only these frequencies are computed. If fc and Nfc are given  the set of frequencies are computed with the function computeThirdOctaveFrequencies.</p> <p>Parameters:</p> <ul> <li> <code>fc</code>               (<code>list</code>)           \u2013            <p>List of center frequencies.</p> </li> <li> <code>Nfc</code>               (<code>list</code>, default:                   <code>None</code> )           \u2013            <p>List of the number of frequencies per band. Defaults to None.</p> </li> </ul> Source code in <code>src/prepost/pre.py</code> <pre><code>def set_frequencies(self, fc: list, Nfc: list = None):\n    \"\"\"Sets the frequencies for the simulation. If only fc is given only these frequencies are computed.\n    If fc and Nfc are given  the set of frequencies are computed with the function computeThirdOctaveFrequencies.\n\n    Args:\n        fc (list): List of center frequencies.\n        Nfc (list, optional): List of the number of frequencies per band. Defaults to None.\n    \"\"\"\n    if Nfc is None:\n        self.set_input('nb_freq', len(fc))\n        self.set_input('frequencies(1)', fc)\n        self.frequencies = np.array(fc)\n    else:\n        self.set_input('nb_freq', sum(Nfc))\n        self.set_input('frequencies(1)',\n                       computeThirdOctaveFrequencies(fc, Nfc))\n        # self.inputs['frequencies(1)'] = list(computeThirdOctaveFrequencies(fc,Nfc))\n        self.frequencies = np.array(computeThirdOctaveFrequencies(fc, Nfc))\n</code></pre>"},{"location":"reference/pre.html#src.prepost.pre.Simu.defineCases","title":"<code>defineCases(heights, angles, src_path='/home/lmfa/jcolas/Documents/DEV/wf_phd/src/kernel/New_PE/PE_2D_WAPE', flow_path='/home/lmfa/jcolas/Documents/DEV/LES/', ratio=None)</code>","text":"<p>Defines the cases to be simulated with the number of source heights, angles, and flow data. The wind turbine are automatically defined from the <code>Les</code> data.</p> <p>Parameters:</p> <ul> <li> <code>heights</code>               (<code>list</code>)           \u2013            <p>List of source heights.</p> </li> <li> <code>angles</code>               (<code>list</code>)           \u2013            <p>List of propagation angles.</p> </li> <li> <code>src_path</code>               (<code>str</code>, default:                   <code>'/home/lmfa/jcolas/Documents/DEV/wf_phd/src/kernel/New_PE/PE_2D_WAPE'</code> )           \u2013            <p>Path to the source code. Defaults to '/home/lmfa/jcolas/Documents/DEV/wf_phd/src/kernel/New_PE/PE_2D_WAPE'.</p> </li> <li> <code>flow_path</code>               (<code>str</code>, default:                   <code>'/home/lmfa/jcolas/Documents/DEV/LES/'</code> )           \u2013            <p>Path to the flow data. Defaults to '/home/lmfa/jcolas/Documents/DEV/LES/'.</p> </li> <li> <code>ratio</code>               (<code>float</code>, default:                   <code>None</code> )           \u2013            <p>Scaling ratio for the LES flow. Defaults to None.</p> </li> </ul> Source code in <code>src/prepost/pre.py</code> <pre><code>def defineCases(self, heights: list, angles: np.ndarray,\n                src_path: str = '/home/lmfa/jcolas/Documents/DEV/wf_phd/src/kernel/New_PE/PE_2D_WAPE',\n                flow_path: str = '/home/lmfa/jcolas/Documents/DEV/LES/', ratio: float = None):\n    \"\"\"Defines the cases to be simulated with the number of source heights, angles, and flow data.\n    The wind turbine are automatically defined from the `Les` data.\n\n    Args:\n        heights (list): List of source heights.\n        angles (list): List of propagation angles.\n        src_path (str, optional): Path to the source code. Defaults to '/home/lmfa/jcolas/Documents/DEV/wf_phd/src/kernel/New_PE/PE_2D_WAPE'.\n        flow_path (str, optional): Path to the flow data. Defaults to '/home/lmfa/jcolas/Documents/DEV/LES/'.\n        ratio (float, optional): Scaling ratio for the LES flow. Defaults to None.\n    \"\"\"\n    self.heights = heights\n    self.tau = angles\n    self.src_path = src_path\n\n    self.inputs['fdir'] = flow_path+'output/'\n    print(self.inputs['fdir'])\n    self.les = Les(flow_path)\n\n    self.les.read(ratio=ratio)\n    self.tx = self.les.turbines[:, 1]\n    self.ty = self.les.turbines[:, 2]\n    if ratio is not None:\n        self.inputs['tinput%ratio'] = ratio\n    else:\n        self.inputs['tinput%ratio'] = self.les.ug\n        self.inputs['tinput%ratio'] = 1\n    self.inputs['tinput%z_i'] = self.les.z_i\n    self.inputs['tinput%T_scale_K'] = self.les.T_scale\n    self.inputs['tinput%Lx'] = self.les.lx\n    self.inputs['tinput%Ly'] = self.les.ly\n    self.inputs['tinput%Lz'] = self.les.lz\n</code></pre>"},{"location":"reference/pre.html#src.prepost.pre.Simu.defineDomain","title":"<code>defineDomain(x1, x2, y1, y2, h)</code>","text":"<p>Defines the total domain for the simulation.</p> <p>Parameters:</p> <ul> <li> <code>x1</code>               (<code>float</code>)           \u2013            <p>Start of the x-domain.</p> </li> <li> <code>x2</code>               (<code>float</code>)           \u2013            <p>End of the x-domain.</p> </li> <li> <code>y1</code>               (<code>float</code>)           \u2013            <p>Start of the y-domain.</p> </li> <li> <code>y2</code>               (<code>float</code>)           \u2013            <p>End of the y-domain.</p> </li> <li> <code>h</code>               (<code>float</code>)           \u2013            <p>Height of the domain.</p> </li> </ul> Source code in <code>src/prepost/pre.py</code> <pre><code>def defineDomain(self, x1: float, x2: float, y1: float, y2: float, h: float):\n    \"\"\"Defines the total domain for the simulation.\n\n    Args:\n        x1 (float): Start of the x-domain.\n        x2 (float): End of the x-domain.\n        y1 (float): Start of the y-domain.\n        y2 (float): End of the y-domain.\n        h (float): Height of the domain.\n    \"\"\"\n    self.x1 = x1\n    self.x2 = x2\n    self.y1 = y1\n    self.y2 = y2\n    self.h = h\n</code></pre>"},{"location":"reference/pre.html#src.prepost.pre.Simu.set_xplanes","title":"<code>set_xplanes(xplanes)</code>","text":"<p>Sets the x constant planes for the simulation.</p> <p>Parameters:</p> <ul> <li> <code>xplanes</code>               (<code>list</code>)           \u2013            <p>List of x-planes.</p> </li> </ul> Source code in <code>src/prepost/pre.py</code> <pre><code>def set_xplanes(self, xplanes: list):\n    \"\"\"Sets the x constant planes for the simulation.\n\n    Args:\n        xplanes (list): List of x-planes.\n    \"\"\"\n    # x constant planes\n    self.xplanes = np.array(xplanes)\n</code></pre>"},{"location":"reference/pre.html#src.prepost.pre.Simu.set_yplanes","title":"<code>set_yplanes(yplanes)</code>","text":"<p>Sets the y constant planes for the simulation.</p> <p>Parameters:</p> <ul> <li> <code>yplanes</code>               (<code>list</code>)           \u2013            <p>List of y-planes.</p> </li> </ul> Source code in <code>src/prepost/pre.py</code> <pre><code>def set_yplanes(self, yplanes: list):\n    \"\"\"Sets the y constant planes for the simulation.\n\n    Args:\n        yplanes (list): List of y-planes.\n    \"\"\"\n    # y constant planes\n    self.yplanes = np.array(yplanes)\n</code></pre>"},{"location":"reference/pre.html#src.prepost.pre.Simu.set_domain","title":"<code>set_domain(iturbine)</code>","text":"<p>Sets the specific domain for each turbine.</p> <p>Parameters:</p> <ul> <li> <code>iturbine</code>               (<code>int</code>)           \u2013            <p>Index of the turbine.</p> </li> </ul> Source code in <code>src/prepost/pre.py</code> <pre><code>def set_domain(self, iturbine: int):\n    \"\"\"Sets the specific domain for each turbine.\n\n    Args:\n        iturbine (int): Index of the turbine.\n    \"\"\"\n    Lx1 = self.x2-self.tx[iturbine]*self.les.z_i\n    Lx2 = self.tx[iturbine]*self.les.z_i - self.x1\n    Ly1 = self.y2 - self.ty[iturbine]*self.les.z_i\n    Ly2 = self.ty[iturbine]*self.les.z_i - self.y1\n    Ly = max(Ly1, Ly2)\n    Lz = self.h\n\n    self.set_input('Lx1', Lx1)\n    self.set_input('Lx2', Lx2)\n    self.set_input('Ly1', Ly1)\n    self.set_input('Ly2', Ly2)\n    self.set_input('Lz', Lz)\n\n    if self.xplanes is not None:\n        self.set_input('nb_xplane', len(self.xplanes))\n        self.set_input('xplane(1)', self.xplanes -\n                       self.tx[iturbine]*self.les.z_i)\n    else:\n        self.set_input('nb_xplane', 0)\n\n    if self.yplanes is not None:\n        self.set_input('nb_yplane', len(self.yplanes))\n        self.set_input('yplane(1)', self.yplanes -\n                       self.ty[iturbine]*self.les.z_i)\n    else:\n        self.set_input('nb_yplane', 0)\n</code></pre>"},{"location":"reference/pre.html#src.prepost.pre.Simu.computeSimulationTime","title":"<code>computeSimulationTime()</code>","text":"<p>Computes an estimation of the simulation time. This estimation is based on a calulation for 45 frequencies from 50hz to 1080hz up to 1km.  This took approximately 195s on one haswell core. </p> <p>Returns:</p> <ul> <li> <code>float</code> (              <code>float</code> )          \u2013            <p>Total simulation time.</p> </li> </ul> Source code in <code>src/prepost/pre.py</code> <pre><code>def computeSimulationTime(self) -&gt; float:\n    \"\"\"Computes an estimation of the simulation time.\n    This estimation is based on a calulation for 45 frequencies from 50hz to 1080hz up to 1km. \n    This took approximately 195s on one haswell core. \n\n    Returns:\n        float: Total simulation time.\n    \"\"\"\n    TIME_1km_45freq_s = 195\n\n    Lx1 = self.inputs['Lx1']\n    Lx2 = self.inputs['Lx2']\n    Ly1 = self.inputs['Ly1']\n    Ly2 = self.inputs['Ly2']\n    print(Lx1)\n    print(Lx2)\n\n    area_rectangle = (Lx1 + Lx2) * (Ly1 + Ly2)\n    area_circle = np.pi*1000**2\n    t_tot = TIME_1km_45freq_s * self.tau.size * area_rectangle / area_circle\n    return t_tot\n</code></pre>"},{"location":"reference/pre.html#src.prepost.pre.Simu.createLaunch","title":"<code>createLaunch(dirname, jname, mem=5000, time='2:00:00')</code>","text":"<p>Creates a launch file for SLURM. Set up for Newton calculator on ECL cluster</p> <p>Parameters:</p> <ul> <li> <code>dirname</code>               (<code>str</code>)           \u2013            <p>Directory name.</p> </li> <li> <code>jname</code>               (<code>str</code>)           \u2013            <p>Job name.</p> </li> <li> <code>mem</code>               (<code>int</code>, default:                   <code>5000</code> )           \u2013            <p>Memory allocation. Defaults to 5000.</p> </li> <li> <code>time</code>               (<code>str</code>, default:                   <code>'2:00:00'</code> )           \u2013            <p>Time limit. Defaults to \"2:00:00\".</p> </li> </ul> Source code in <code>src/prepost/pre.py</code> <pre><code>def createLaunch(self, dirname: str, jname: str, mem: int = 5000, time: str = \"2:00:00\"):\n    \"\"\"Creates a launch file for SLURM.\n    Set up for Newton calculator on ECL cluster\n\n    Args:\n        dirname (str): Directory name.\n        jname (str): Job name.\n        mem (int, optional): Memory allocation. Defaults to 5000.\n        time (str, optional): Time limit. Defaults to \"2:00:00\".\n    \"\"\"\n\n    f = open(dirname+'/launch.sh', 'w')\n    f.write(\"#!/bin/bash\\n\")\n    f.write(\"#SBATCH --job-name=\"+jname+\"\\n\")\n    f.write(\"#SBATCH --output=out.out # output messages go here\\n\")\n    f.write(\"#SBATCH --error=err.err    # error messages go here\\n\")\n    f.write(\"#SBATCH --mail-user=jules.colas@ecl17.ec-lyon.fr\\n\")\n    f.write(\"#SBATCH --mail-type=ALL\\n\")\n    f.write(\"#SBATCH --partition=haswell # partition name\\n\")\n    f.write(\"#SBATCH --nodes=1\\n\")\n    f.write(\"#SBATCH --cpus-per-task=1\\n\")\n    f.write(\"#SBATCH --mem=\" + str(mem) + \"\\n\")\n    f.write(\"#SBATCH --time=\" + str(time) + \"\\n\")\n\n    f.write(\"module purge\\n\")\n    f.write(\"module load  HDF5/1.10.1-intel-2018a\\n\")\n    f.write(\"export OMP_NUM_THREADS=$SLURM_CPUS_PER_TASK\\n\")\n    f.write(\"export KMP_AFFINITY=granularity=fine,compact,1,0\\n\")\n    f.write(\"export OMP_STACKSIZE=1g\\n\")\n    f.write(\"ulimit -s unlimited\\n\")\n\n    f.write(\"time ./PE_2D\\n\")\n</code></pre>"},{"location":"reference/pre.html#src.prepost.pre.Simu.createParallelLaunch","title":"<code>createParallelLaunch(dirname, jname, distribute_tau, mem=5000, time='2:00:00')</code>","text":"<p>Creates a parallel launch file for SLURM with distribution over propagation angles.</p> <p>Parameters:</p> <ul> <li> <code>dirname</code>               (<code>str</code>)           \u2013            <p>Directory name.</p> </li> <li> <code>jname</code>               (<code>str</code>)           \u2013            <p>Job name.</p> </li> <li> <code>distribute_tau</code>               (<code>int</code>)           \u2013            <p>Number of tau distributions.</p> </li> <li> <code>mem</code>               (<code>int</code>, default:                   <code>5000</code> )           \u2013            <p>Memory allocation. Defaults to 5000.</p> </li> <li> <code>time</code>               (<code>str</code>, default:                   <code>'2:00:00'</code> )           \u2013            <p>Time limit. Defaults to \"2:00:00\".</p> </li> </ul> Source code in <code>src/prepost/pre.py</code> <pre><code>def createParallelLaunch(self, dirname: str, jname: str, distribute_tau: int, mem: int = 5000, time: str = \"2:00:00\"):\n    \"\"\"Creates a parallel launch file for SLURM with distribution over propagation angles.\n\n    Args:\n        dirname (str): Directory name.\n        jname (str): Job name.\n        distribute_tau (int): Number of tau distributions.\n        mem (int, optional): Memory allocation. Defaults to 5000.\n        time (str, optional): Time limit. Defaults to \"2:00:00\".\n    \"\"\"\n    f = open(dirname+'/launch.sh', 'w')\n    f.write(\"#!/bin/bash\\n\")\n    f.write(\"#SBATCH --job-name=\"+jname+\"\\n\")\n    f.write(\"#SBATCH --output=out.out # output messages go here\\n\")\n    f.write(\"#SBATCH --error=err.err    # error messages go here\\n\")\n    f.write(\"#SBATCH --mail-type=ALL\\n\")\n    f.write(\"#SBATCH --partition=haswell # partition name\\n\")\n    f.write(\"#SBATCH --nodes=1\\n\")\n    f.write(\"#SBATCH --cpus-per-task=\"+str(distribute_tau)+\"\\n\")\n    f.write(\"#SBATCH --mem=\" + str(mem*distribute_tau) + \"\\n\")\n    f.write(\"#SBATCH --time=\" + str(time) + \"\\n\")\n\n    f.write(\"module purge\\n\")\n    f.write(\"module load  HDF5/1.10.1-intel-2018a\\n\")\n    f.write(\"export OMP_NUM_THREADS=$SLURM_CPUS_PER_TASK\\n\")\n    f.write(\"export KMP_AFFINITY=granularity=fine,compact,1,0\\n\")\n    f.write(\"export OMP_STACKSIZE=1g\\n\")\n    f.write(\"ulimit -s unlimited\\n\")\n    for kk in range(distribute_tau):\n        f.write(\"cd ./tau\" + str(kk)+\"\\n\")\n        f.write(\"time ./PE_2D &amp;\\n\")\n        f.write(\"cd .. \" + \"\\n\")\n    f.write(\"wait\")\n</code></pre>"},{"location":"reference/pre.html#src.prepost.pre.Simu.distributeCases","title":"<code>distributeCases(distribute_tau=None, mem=5000, time='2:00:00', turbine_index=None)</code>","text":"<p>Distributes cases for the simulation.  This function reates the directories, input.nml files, launch.sh files for running the complete simulation.  It does not launch the jobs.</p> <p>Parameters:</p> <ul> <li> <code>distribute_tau</code>               (<code>int</code>, default:                   <code>None</code> )           \u2013            <p>Number of tau distributions. Defaults to None.</p> </li> <li> <code>mem</code>               (<code>int</code>, default:                   <code>5000</code> )           \u2013            <p>Memory allocation. Defaults to 5000.</p> </li> <li> <code>time</code>               (<code>str</code>, default:                   <code>'2:00:00'</code> )           \u2013            <p>Time limit. Defaults to \"2:00:00\".</p> </li> <li> <code>turbine_index</code>               (<code>list</code>, default:                   <code>None</code> )           \u2013            <p>List of turbine indices. Defaults to None.</p> </li> </ul> Source code in <code>src/prepost/pre.py</code> <pre><code>def distributeCases(self, distribute_tau: int = None, mem: int = 5000,\n                    time: str = \"2:00:00\", turbine_index: list = None):\n    \"\"\"Distributes cases for the simulation. \n    This function reates the directories, input.nml files, launch.sh files for running the complete simulation. \n    It does not launch the jobs.\n\n    Args:\n        distribute_tau (int, optional): Number of tau distributions. Defaults to None.\n        mem (int, optional): Memory allocation. Defaults to 5000.\n        time (str, optional): Time limit. Defaults to \"2:00:00\".\n        turbine_index (list, optional): List of turbine indices. Defaults to None.\n    \"\"\"\n    dir = os.getcwd()\n    self.distribute_tau = distribute_tau\n    if distribute_tau == False:\n        self.inputs['nb_theta'] = len(self.tau)\n        self.inputs['theta(1)'] = list(self.tau)\n\n    if turbine_index is None:\n        turbine_index = np.arange(0, len(self.tx))\n\n    print(turbine_index)\n    # loop over the wind turbine\n    for ii in turbine_index:\n        print('t%s :' % (ii), self.tx[ii], self.ty[ii])\n        # set wind turbines location in input.nml\n        # the PE simulation wil always\n        # be perfomed with the source at (0,0,zS)\n        self.inputs[\"tinput%posx\"] = self.tx[ii]\n        self.inputs[\"tinput%posy\"] = self.ty[ii]\n        # set the PE domain according to source position and total domain\n        self.set_domain(ii)\n        # loop over the source heights\n        for jj in range(len(self.heights)):\n            # set source heights in input.nml\n            self.inputs['src%pos_z'] = self.heights[jj]\n            # loop over the propagation angles\n            if distribute_tau is not None:\n                # if tau distributed launch a job for each angle\n                ntau = self.tau.size//distribute_tau\n                rtau = self.tau.size % distribute_tau\n                for kk in range(distribute_tau-1):\n                    self.inputs['nb_theta'] = ntau\n                    self.inputs['theta(1)'] = list(\n                        self.tau[kk*ntau:(kk+1)*ntau])\n                    path = os.path.join(dir,\n                                        't' + str(ii) + '/' +\n                                        str(self.heights[jj]) +\n                                        '/tau' + str(kk) + '/')\n                    os.makedirs(path, exist_ok=True)\n                    self.createInputFile(directory=path)\n                    shutil.copy(self.src_path, path + '/PE_2D')\n\n                self.inputs['nb_theta'] = ntau + rtau\n                self.inputs['theta(1)'] = self.tau[(\n                    distribute_tau - 1) * ntau:].tolist()\n                path = os.path.join(dir, 't' + str(ii) + '/' + str(self.heights[jj])\n                                    + '/tau' + str(distribute_tau-1) + '/')\n                os.makedirs(path, exist_ok=True)\n                self.createInputFile(directory=path)\n                shutil.copy(self.src_path, path+'/PE_2D')\n\n                self.createParallelLaunch(os.path.join(dir, 't'+str(ii)+'/'+str(self.heights[jj])+'/'),\n                                          self.casename+'t' +\n                                          str(ii)+'h' +\n                                          str(self.heights[jj]),\n                                          distribute_tau,\n                                          mem=mem, time=time)\n            # if tau is not distributed one job is launched for all propagation\n            else:\n                self.inputs['nb_theta'] = self.tau.size\n                self.inputs['theta(1)'] = self.tau.tolist()\n                path = os.path.join(\n                    dir, 't'+str(ii)+'/'+str(self.heights[jj]))\n                os.makedirs(path, exist_ok=True)\n                self.createInputFile(directory=path)\n                self.createLaunch(\n                    path, self.casename+'t'+str(ii)+'h'+str(self.heights[jj]), mem=mem, time=time)\n                shutil.copy(self.src_path, path+'/PE_2D')\n</code></pre>"},{"location":"reference/pre.html#src.prepost.pre.Simu.createLaunchFiles","title":"<code>createLaunchFiles(mem, time, turbine_index=None)</code>","text":"<p>Creates launch files for the simulation.  This was coded specifically for haswell partition on Newton HPC. This done to launch several PE cases with the same job in order to avoid launching hundreds of jobs in the case of a wind farm.</p> <p>Parameters:</p> <ul> <li> <code>mem</code>               (<code>int</code>)           \u2013            <p>Memory allocation.</p> </li> <li> <code>time</code>               (<code>str</code>)           \u2013            <p>Time limit.</p> </li> <li> <code>turbine_index</code>               (<code>list</code>, default:                   <code>None</code> )           \u2013            <p>List of turbine indices. Defaults to None.</p> </li> </ul> Source code in <code>src/prepost/pre.py</code> <pre><code>def createLaunchFiles(self, mem: int, time: str, turbine_index: list = None):\n    \"\"\"Creates launch files for the simulation. \n    This was coded specifically for haswell partition on Newton HPC.\n    This done to launch several PE cases with the same job in order to avoid launching hundreds of jobs in the case of a wind farm.\n\n    Args:\n        mem (int): Memory allocation.\n        time (str): Time limit.\n        turbine_index (list, optional): List of turbine indices. Defaults to None.\n    \"\"\"\n    dirname = os.getcwd()\n    haswell_mem_size = 64000\n    haswell_nb_core = 16\n    count = 0\n    countjobs = 0\n    nlaunchPerJob = min(haswell_nb_core, int(haswell_mem_size / mem))\n\n    if turbine_index is None:\n        turbine_index = np.arange(0, len(self.tx))\n\n    self.nJob = int((len(turbine_index)*len(self.heights))\n                    // nlaunchPerJob)\n    self.rest_cases = int((len(turbine_index)*len(self.heights))\n                          % nlaunchPerJob)\n\n    for ii in turbine_index:\n        for jj in range(len(self.heights)):\n            if count % nlaunchPerJob == 0:\n                print(countjobs)\n\n                f = open(dirname + '/launch' +\n                         str(count//nlaunchPerJob) + '.sh', 'w')\n                f.write(\"#!/bin/bash\\n\")\n                f.write(\"#SBATCH --job-name=PE\" +\n                        str(count//nlaunchPerJob)+\"\\n\")\n                f.write(\"#SBATCH --output=out.out # output messages go here\\n\")\n                f.write(\"#SBATCH --error=err.err    # error messages go here\\n\")\n                f.write(\"#SBATCH --mail-type=ALL\\n\")\n                f.write(\"#SBATCH --partition=haswell # partition name\\n\")\n                f.write(\"#SBATCH --nodes=1\\n\")\n                if countjobs == (self.nJob):\n                    f.write(\"#SBATCH --ntasks=\"+str(self.rest_cases)+\"\\n\")\n                else:\n                    f.write(\"#SBATCH --ntasks=\"+str(nlaunchPerJob)+\"\\n\")\n                f.write(\"#SBATCH --cpus-per-task=1\\n\")\n                # f.write(\"#SBATCH --mem=\" + str(mem) + \"\\n\")\n                f.write(\"#SBATCH --mem=64000\\n\")\n                f.write(\"#SBATCH --time=\" + str(time) + \"\\n\")\n\n                f.write(\"module purge\\n\")\n                f.write(\"module load  HDF5/1.10.1-intel-2018a\\n\")\n                f.write(\"export OMP_NUM_THREADS=$SLURM_CPUS_PER_TASK\\n\")\n                f.write(\"export KMP_AFFINITY=granularity=fine,compact,1,0\\n\")\n                f.write(\"export OMP_STACKSIZE=1g\\n\")\n                f.write(\"ulimit -s unlimited\\n\")\n\n            f.write(\"cd t%s/%s/ \\n\" % (ii, self.heights[jj]))\n            f.write(\"time ./PE_2D &gt;out.out &amp; \\n\")\n            f.write(\"cd ../../ \\n\")\n            count += 1\n\n            if (count) % nlaunchPerJob == 0:\n                f.write(\"wait\")\n                f.close()\n                countjobs += 1\n    f.write(\"wait\")\n    f.close()\n</code></pre>"},{"location":"reference/pre.html#src.prepost.pre.Simu.createLocalLaunchFiles","title":"<code>createLocalLaunchFiles(mem, time, turbine_index=None)</code>","text":"<p>Creates local launch files for the simulation. This is used to launch the PE simulations directly on your PC.</p> <p>Parameters:</p> <ul> <li> <code>mem</code>               (<code>int</code>)           \u2013            <p>Memory allocation.</p> </li> <li> <code>time</code>               (<code>str</code>)           \u2013            <p>Time limit.</p> </li> <li> <code>turbine_index</code>               (<code>list</code>, default:                   <code>None</code> )           \u2013            <p>List of turbine indices. Defaults to None.</p> </li> </ul> Source code in <code>src/prepost/pre.py</code> <pre><code>def createLocalLaunchFiles(self, mem: int, time: str, turbine_index: list = None):\n    \"\"\"Creates local launch files for the simulation.\n    This is used to launch the PE simulations directly on your PC.\n\n    Args:\n        mem (int): Memory allocation.\n        time (str): Time limit.\n        turbine_index (list, optional): List of turbine indices. Defaults to None.\n    \"\"\"\n    dirname = os.getcwd()\n    haswell_mem_size = 64000\n    haswell_nb_core = 16\n    count = 0\n    countjobs = 0\n    nlaunchPerJob = min(haswell_nb_core, int(haswell_mem_size / mem))\n\n    if turbine_index is None:\n        turbine_index = np.arange(0, len(self.tx))\n\n    f = open(dirname + '/launch.sh', 'w')\n    for ii in turbine_index:\n        for jj in range(len(self.heights)):\n            print(jj)\n\n            f.write(\"#!/bin/bash\\n\")\n            f.write(\"cd t%s/%s/ \\n\" % (ii, self.heights[jj]))\n            f.write(\"time ./PE_2D &gt;out.out\\n\")\n            f.write(\"cd ../../ \\n\")\n\n    f.close()\n</code></pre>"},{"location":"reference/pre.html#src.prepost.pre.Simu.launchCases","title":"<code>launchCases(turbine_index=None)</code>","text":"<p>Launches the simulation cases. When one job corresponds to one Height and one turbine. This is used after running distribute cases. Warning this will launch one job for each (source height, anglen turbine).  Hence it is a not recommended in the case of wind farm case to avoid launching to much jobs. Prefer the createLaunchfile() and launchcCase2() procedure.</p> <p>Parameters:</p> <ul> <li> <code>turbine_index</code>               (<code>list</code>, default:                   <code>None</code> )           \u2013            <p>List of turbine indices. Defaults to None.</p> </li> </ul> Source code in <code>src/prepost/pre.py</code> <pre><code>def launchCases(self, turbine_index: list = None):\n    \"\"\"Launches the simulation cases. When one job corresponds to one Height and one turbine.\n    This is used after running distribute cases. Warning this will launch one job for each (source height, anglen turbine). \n    Hence it is a not recommended in the case of wind farm case to avoid launching to much jobs. Prefer the createLaunchfile() and launchcCase2() procedure.\n\n    Args:\n        turbine_index (list, optional): List of turbine indices. Defaults to None.\n    \"\"\"\n    dir = os.getcwd()\n    if turbine_index is None:\n        turbine_index = np.arange(0, len(self.tx))\n    for ii in turbine_index:\n        print('t%s' % (ii))\n        for jj in range(len(self.heights)):\n            path = os.path.join(dir, 't'+str(ii)+'/'+str(self.heights[jj]))\n            os.system(\"cd \"+path+\"; sbatch launch.sh\")\n</code></pre>"},{"location":"reference/pre.html#src.prepost.pre.Simu.launchCases2","title":"<code>launchCases2()</code>","text":"<p>Launches the simulation cases. When the function createLaunchFiles() has been used.</p> Source code in <code>src/prepost/pre.py</code> <pre><code>def launchCases2(self):\n    \"\"\"Launches the simulation cases. When the function createLaunchFiles() has been used.\"\"\"\n    dir = os.getcwd()\n    for ii in range(self.nJob):\n        os.system(\"sbatch launch%s.sh\" % (ii))\n</code></pre>"},{"location":"reference/pre.html#src.prepost.pre.Simu.fname","title":"<code>fname(iTurb, tau, height)</code>","text":"<p>Constructs the name of the h5 file storing the PE results. the data stucture is such that if tau is not distibuted: /t//.h5 if tau is distributed: /t//tau/.h5 <p>Parameters:</p> <ul> <li> <code>iTurb</code>               (<code>int</code>)           \u2013            <p>Index of the turbine.</p> </li> <li> <code>tau</code>               (<code>float</code>)           \u2013            <p>Propagation angle.</p> </li> <li> <code>height</code>               (<code>float</code>)           \u2013            <p>Source height.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code> (              <code>str</code> )          \u2013            <p>Complete path to the h5 file.</p> </li> </ul> Source code in <code>src/prepost/pre.py</code> <pre><code>def fname(self, iTurb: int,\n          tau: float, height: float) -&gt; str:\n    \"\"\"Constructs the name of the h5 file storing the PE results.\n    the data stucture is such that if tau is not distibuted: &lt;self.dirname&gt;/t&lt;iTurb&gt;/&lt;height&gt;/&lt;self.casename&gt;_&lt;tau&gt;.h5\n    if tau is distributed:\n    &lt;self.dirname&gt;/t&lt;iTurb&gt;/&lt;height&gt;/tau&lt;itau&gt;/&lt;self.casename&gt;_&lt;tau&gt;.h5\n\n    Args:\n        iTurb (int): Index of the turbine.\n        tau (float): Propagation angle.\n        height (float): Source height.\n\n    Returns:\n        str: Complete path to the h5 file.\n    \"\"\"\n    # convert angle to str format\n    if int(tau) == tau:\n        tau_str = format(tau, \"04d\")\n    else:\n        tau_str = str(tau)\n\n    dirname = os.getcwd()\n    # if tau distributed find the right folder\n    if self.distribute_tau is not None:\n        for kk in range(self.distribute_tau):\n            path = (\n                dirname\n                + \"/t\"\n                + str(iTurb)\n                + \"/\"\n                + str(height)\n                + \"/tau\"\n                + str(kk)\n                + \"/\"\n            )\n            if os.path.isfile(path + self.casename + \"_\" + tau_str + \".h5\"):\n                break\n    # define directly the folder\n    else:\n        path = dirname + \"/t\" + str(iTurb) + \"/\" + str(height) + \"/\"\n    return path + self.casename + \"_\" + tau_str + \".h5\"\n</code></pre> <p></p>"},{"location":"reference/pre.html#src.prepost.pre.Simu.check_run_cases","title":"<code>check_run_cases()</code>","text":"<p>Checks if the simulation cases have run. This only checks if the file has been created.</p> Source code in <code>src/prepost/pre.py</code> <pre><code>def check_run_cases(self):\n    \"\"\"Checks if the simulation cases have run. This only checks if the file has been created.\"\"\"\n    for ii in range(len(self.tx)):\n        for jj in range(len(self.heights)):\n            for tt in range(len(self.tau)):\n                fname = self.fname(ii, self.tau[tt], self.heights[jj])\n                if not os.path.isfile(fname):\n                    print(fname)\n</code></pre>"},{"location":"reference/pre.html#src.prepost.pre.Simu.makeSource","title":"<code>makeSource(wt, mesh, offset=100, U_inf=None, z_coord=None, fname=None, iTurb=None, Ncore=16, plot=False, ratio=1, epsilon=None, omega=None)</code>","text":"<p>Compute the Spp in free field for the sifferent wind turbines using the <code>Source</code> module. </p> <p>Parameters:</p> <ul> <li> <code>wt</code>               (<code>WindTurbine</code>)           \u2013            <p>Wind turbine object.</p> </li> <li> <code>mesh</code>               (<code>Mesh</code>)           \u2013            <p>Mesh object.</p> </li> <li> <code>offset</code>               (<code>float</code>, default:                   <code>100</code> )           \u2013            <p>Offset for the wind speed profile. Defaults to 100.</p> </li> <li> <code>U_inf</code>               (<code>list</code>, default:                   <code>None</code> )           \u2013            <p>Wind speed profile. if None self.les is used. Defaults to None.</p> </li> <li> <code>z_coord</code>               (<code>list</code>, default:                   <code>None</code> )           \u2013            <p>Vertical coordinates. Defaults to None.</p> </li> <li> <code>fname</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>File name to save the source. Defaults to None.</p> </li> <li> <code>iTurb</code>               (<code>list</code>, default:                   <code>None</code> )           \u2013            <p>List of turbine indices. Defaults to None.</p> </li> <li> <code>Ncore</code>               (<code>int</code>, default:                   <code>16</code> )           \u2013            <p>Number of cores. Defaults to 16.</p> </li> <li> <code>plot</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to plot the wind speed profile. Defaults to False.</p> </li> <li> <code>ratio</code>               (<code>float</code>, default:                   <code>1</code> )           \u2013            <p>Ratio for the LES data. Defaults to 1.</p> </li> <li> <code>epsilon</code>               (<code>float</code>, default:                   <code>None</code> )           \u2013            <p>To set a constant epsilon instead of the LES data. Defaults to None.</p> </li> <li> <code>omega</code>               (<code>float</code>, default:                   <code>None</code> )           \u2013            <p>To set a constant Omega for the wind turbine instead of using NREL table. Defaults to None.</p> </li> </ul> Source code in <code>src/prepost/pre.py</code> <pre><code>def makeSource(self, wt: WindTurbine, mesh: Mesh, offset: float = 100,\n               U_inf: np.ndarray = None, z_coord: np.ndarray = None,\n               fname: str = None, iTurb: list = None,\n               Ncore: int = 16, plot: bool = False, ratio: float = 1,\n               epsilon: float = None, omega: float = None):\n    \"\"\"Compute the Spp in free field for the sifferent wind turbines using the `Source` module. \n\n    Args:\n        wt (WindTurbine): Wind turbine object.\n        mesh (Mesh): Mesh object.\n        offset (float, optional): Offset for the wind speed profile. Defaults to 100.\n        U_inf (list, optional): Wind speed profile. if None self.les is used. Defaults to None.\n        z_coord (list, optional): Vertical coordinates. Defaults to None.\n        fname (str, optional): File name to save the source. Defaults to None.\n        iTurb (list, optional): List of turbine indices. Defaults to None.\n        Ncore (int, optional): Number of cores. Defaults to 16.\n        plot (bool, optional): Whether to plot the wind speed profile. Defaults to False.\n        ratio (float, optional): Ratio for the LES data. Defaults to 1.\n        epsilon (float, optional): To set a constant epsilon instead of the LES data. Defaults to None.\n        omega (float, optional): To set a constant Omega for the wind turbine instead of using NREL table. Defaults to None.\n    \"\"\"\n    # check\n    try:\n        self.tx\n    except:\n        print('turbine not define')\n        return\n\n    if mesh.polar:\n        print('mesh polar is not handled')\n        return\n    if iTurb is None:\n        iTurb = np.arange(0, len(self.tx))\n\n    for ii in iTurb:\n        print('start computation for Turbine ', ii)\n        mesh1 = deepcopy(mesh)\n        mesh1.shift(-self.tx[ii]*self.les.z_i,\n                    -self.ty[ii]*self.les.z_i)\n        mesh1.cartesian_2_polar()\n\n        # set wind speed profile according to les data or input\n        if (U_inf is not None) and (z_coord is not None):\n            self.les.U_inf = U_inf\n            self.les.z_coord = z_coord\n        else:\n            self.les.dissipation()\n            self.les.takeProfile(self.tx[ii]*self.les.z_i-offset,\n                                 self.ty[ii]*self.les.z_i,\n                                 ratio=ratio, epsilon=epsilon)\n\n        xnew = np.array([[self.tx[ii]*self.les.z_i-offset]])\n        ynew = np.array([[self.ty[ii]*self.les.z_i]])\n        znew = np.array([[wt.href]])\n        U_hub, epsilon_hub = interp_3D_atmos_data(\n            self.les, xnew, ynew, znew)\n\n        # U_hub = self.les.U_inf[np.argmin(np.abs(self.les.z_coord\n        #                                        - wt.href))]\n        # epsilon_hub = self.les.epsilon_Kol[np.argmin(np.abs(self.les.z_coord\n        #                                                    - wt.href))]\n        wt.controlRotSpeed(U_hub, omega=omega)\n        wt.setOptimalTwist(U_hub, 4)\n        wt.absolute_pos = (self.tx[ii]*self.les.z_i,\n                           self.ty[ii]*self.les.z_i)\n        self.U_hub = U_hub\n        print('U_hub', U_hub)\n        print('epsilon_hub', epsilon_hub)\n        print('Omega', wt.omega*60/(2*np.pi))\n        # self.les.constant_epsilon(0.01)\n\n        if plot:\n            plt.plot(self.les.U_inf, self.les.z_coord)\n            plt.figure()\n            plt.plot(self.les.epsilon_Kol, self.les.z_coord)\n            plt.show()\n\n        src = Source(wt, self.les, mesh1)\n        src.computeSpp(self.frequencies, Ncore)\n        src.mesh.polar_2_cartesian()\n        src.mesh.shift(self.tx[ii]*self.les.z_i,\n                       self.ty[ii]*self.les.z_i)\n\n        if fname is not None:\n            src.save(fname+str(ii)+'.dat')\n        else:\n            src.save('Spp'+str(ii)+'.dat')\n        src = None\n        mesh1 = None\n</code></pre>"},{"location":"reference/pre.html#src.prepost.pre.Simu.save","title":"<code>save(fname=None)</code>","text":"<p>Saves the class as a .dat file using pickle format.</p> <p>Parameters:</p> <ul> <li> <code>fname</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>File name to save the class. Defaults to None.</p> </li> </ul> Source code in <code>src/prepost/pre.py</code> <pre><code>def save(self, fname: str = None):\n    \"\"\"Saves the class as a .dat file using pickle format.\n\n    Args:\n        fname (str, optional): File name to save the class. Defaults to None.\n    \"\"\"\n    if fname is None:\n        fname = self.casename\n    with open(fname+'.dat', 'wb') as file:\n        pickle.dump(self.__dict__, file)\n</code></pre>"},{"location":"reference/pre.html#src.prepost.pre.Simu.load","title":"<code>load(fname)</code>","text":"<p>Loads the class from a .dat file using pickle format.</p> <p>Parameters:</p> <ul> <li> <code>fname</code>               (<code>str</code>)           \u2013            <p>File name to load the class.</p> </li> </ul> Source code in <code>src/prepost/pre.py</code> <pre><code>def load(self, fname: str):\n    \"\"\"Loads the class from a .dat file using pickle format.\n\n    Args:\n        fname (str): File name to load the class.\n    \"\"\"\n    print('loading simulation ...')\n    with open(fname, 'rb') as file:\n        self.__dict__ = pickle.load(file)\n    print('done.')\n</code></pre>"},{"location":"reference/spl.html","title":"Reference for <code>prepost/spl.py</code>","text":""},{"location":"reference/spl.html#src.prepost.spl.SplField","title":"<code>SplField(src=None, deltaL=None)</code>","text":"<p>A class to handle and process SPL (Sound Pressure Level) fields generated from PE (Parabolic Equation) simulation results. The SplField class is designed to handle and process SPL (Sound Pressure Level) fields generated from PE (Parabolic Equation)simulation results. It provides fonctionaly to read and combine deltaLField with source power levels.  It can also read, store, manipulate, and visualize SPL data.  Several post processing like atmospheric absorption, Aweighing, third octave band integration can be performed.  It can also compute the SPL in time domain, compute the time averaged over a rotation or the Amplitude modulation.  Finally functions for visualisation are provided. </p> <p>Attributes:</p> <ul> <li> <code>src</code>               (<code>Source</code>)           \u2013            <p>The source object containing the Sound power level data.</p> </li> <li> <code>deltaL</code>               (<code>DeltaLField</code>)           \u2013            <p>The deltaL field object containing the deltaL data.</p> </li> <li> <code>SPL_time</code>               (<code>ndarray</code>)           \u2013            <p>The SPL data in the time domain. Shape: (x, y, z, freq, t).</p> </li> <li> <code>SPL_seg</code>               (<code>ndarray</code>)           \u2013            <p>The SPL data in the angular domain. Shape: (x, y, z, seg, blade, freq, beta).</p> </li> <li> <code>OASPL_time</code>               (<code>ndarray</code>)           \u2013            <p>The overall SPL data in the time domain. Shape: (x, y, z, t).</p> </li> <li> <code>OASPL_seg</code>               (<code>ndarray</code>)           \u2013            <p>The overall SPL data in the angular domain. Shape: (x, y, z, seg, blade, beta).</p> </li> <li> <code>OASPL_seg_tot</code>               (<code>ndarray</code>)           \u2013            <p>The total overall SPL data in the angular domain. Shape: (x, y, z, beta).</p> </li> <li> <code>am_seg</code>               (<code>ndarray</code>)           \u2013            <p>The amplitude modulation (AM) data in the angular domain.</p> </li> <li> <code>am_time</code>               (<code>ndarray</code>)           \u2013            <p>The AM data in the time domain.</p> </li> <li> <code>OAam_seg</code>               (<code>ndarray</code>)           \u2013            <p>The overall AM data in the angular domain.</p> </li> <li> <code>OAam_time</code>               (<code>ndarray</code>)           \u2013            <p>The overall AM data in the time domain.</p> </li> <li> <code>mean_seg</code>               (<code>ndarray</code>)           \u2013            <p>The mean data in the angular domain.</p> </li> <li> <code>mean_time</code>               (<code>ndarray</code>)           \u2013            <p>The mean data in the time domain.</p> </li> <li> <code>OAmean_seg</code>               (<code>ndarray</code>)           \u2013            <p>The overall mean data in the angular domain.</p> </li> <li> <code>OAmean_time</code>               (<code>ndarray</code>)           \u2013            <p>The overall mean data in the time domain.</p> </li> <li> <code>Nx</code>               (<code>int</code>)           \u2013            <p>The number of points in the x-direction.</p> </li> <li> <code>Ny</code>               (<code>int</code>)           \u2013            <p>The number of points in the y-direction.</p> </li> <li> <code>Nz</code>               (<code>int</code>)           \u2013            <p>The number of points in the z-direction.</p> </li> <li> <code>Nfreq</code>               (<code>int</code>)           \u2013            <p>The number of frequency bands.</p> </li> <li> <code>Nbeta</code>               (<code>int</code>)           \u2013            <p>The number of beta angles.</p> </li> <li> <code>x</code>               (<code>ndarray</code>)           \u2013            <p>The x-coordinates.</p> </li> <li> <code>y</code>               (<code>ndarray</code>)           \u2013            <p>The y-coordinates.</p> </li> <li> <code>third</code>               (<code>bool</code>)           \u2013            <p>Flag indicating if the data is in third-octave bands. Default is False.</p> </li> <li> <code>oaspl</code>               (<code>bool</code>)           \u2013            <p>Flag indicating if the overall SPL data is computed. Default is False.</p> </li> <li> <code>FULL_ROTATION</code>               (<code>bool</code>)           \u2013            <p>Flag indicating if the full rotation is applied. Default is False.</p> </li> <li> <code>AWEIGHT</code>               (<code>bool</code>)           \u2013            <p>Flag indicating if A-weighting is applied. Default is False.</p> </li> <li> <code>ATM_ABS</code>               (<code>bool</code>)           \u2013            <p>Flag indicating if atmospheric absorption is applied. Default is False.</p> </li> <li> <code>POLAR</code>               (<code>bool</code>)           \u2013            <p>Flag indicating if the data is in polar coordinates. Default is False.</p> </li> </ul> <p>Initializes the SplField class.</p> <p>Parameters:</p> <ul> <li> <code>src</code>               (<code>Source</code>, default:                   <code>None</code> )           \u2013            <p>The source object containing the sound pressure level data. Default is None.</p> </li> <li> <code>deltaL</code>               (<code>DeltaLField</code>, default:                   <code>None</code> )           \u2013            <p>The deltaL field object containing the deltaL data. Default is None.</p> </li> </ul> Source code in <code>src/prepost/spl.py</code> <pre><code>def __init__(self, src: Source = None, deltaL: DeltaLField = None):\n    \"\"\"\n    Initializes the SplField class.\n\n    Args:\n        src (Source, optional): The source object containing the sound pressure level data. Default is None.\n        deltaL (DeltaLField, optional): The deltaL field object containing the deltaL data. Default is None.\n    \"\"\"\n    if src is not None:\n        self.src = src\n        self.wt = src.wt\n        self.Nbeta = self.wt.Nbeta\n\n    if deltaL is not None:\n        self.deltaL = deltaL\n        self.xS = deltaL.xS\n        self.yS = deltaL.yS\n</code></pre>"},{"location":"reference/spl.html#src.prepost.spl.SplField.info","title":"<code>info()</code>","text":"<p>Prints information about the SPL field. Show the different quantities loaded and the FLAG to assess what post processing were already run.</p> Source code in <code>src/prepost/spl.py</code> <pre><code>def info(self):\n    \"\"\"\n    Prints information about the SPL field.\n    Show the different quantities loaded and the FLAG to assess what post processing were already run.\n    \"\"\"\n    print('MESH:')\n\n    print('quantity loaded: ')\n    if self.SPL_seg is not None:\n        print('SPL_seg')\n    if self.OASPL_seg is not None:\n        print('OASPL_seg')\n\n    if self.SPL_time is not None:\n        print('SPL_time')\n    if self.OASPL_time is not None:\n        print('OASPL_time')\n\n    print('flags')\n\n    print('oaspl', self.oaspl)\n    print('third', self.third)\n    print('FULL_ROTATION', self.FULL_ROTATION)\n    print('AWEIGHT', self.AWEIGHT)\n    print('ATM_ABS', self.ATM_ABS)\n</code></pre>"},{"location":"reference/spl.html#src.prepost.spl.SplField.check_compatibility_polar","title":"<code>check_compatibility_polar()</code>","text":"<p>Checks the compatibility between the <code>Source</code> data and <code>DelteLField</code> data in polar coordinates. This is usually not used and we prefer to convert \\(Spp\\) and \\(\\Delta L\\) in cartesian coordinates and then  use check_compatibility_cartesian.</p> <p>Returns:</p> <ul> <li> <code>int</code>          \u2013            <p>Returns -1 if the data is not compatible.</p> </li> </ul> Source code in <code>src/prepost/spl.py</code> <pre><code>def check_compatibility_polar(self):\n    \"\"\"\n    Checks the compatibility between the `Source` data and `DelteLField` data in polar coordinates.\n    This is usually not used and we prefer to convert $Spp$ and $\\Delta L$ in cartesian coordinates and then \n    use check_compatibility_cartesian.\n\n    Returns:\n        int: Returns -1 if the data is not compatible.\n    \"\"\"\n    shape_Spp = self.src.SppInterpolated[..., 0, 0, 0].shape\n    if self.deltaL.deltaL_polar is None:\n        logging.warning(\" no deltaL polar in the data\")\n        return -1\n    shape_deltaL = self.deltaL.deltaL_polar[..., 0, 0].shape\n\n    # check space shape\n    if shape_deltaL != shape_Spp:\n        print('Spp and delta L must be of same size')\n        print(shape_deltaL)\n        print(shape_Spp)\n\n    if not np.all(self.src.x_interpolate[:, :, 0] == self.deltaL.x_polar):\n        print('x grids are not the same')\n        return -1\n    else:\n        print('x grid ok')\n    if not np.all(self.src.y_interpolate[:, :, 0] == self.deltaL.y_polar):\n        print('y grids are not the same')\n        # print(self.src.y_interpolate)\n        # print(self.deltaL.y_polar)\n        return -1\n    else:\n        print('y grid ok')\n\n    if not np.all(self.src.z_interpolate[0, 0, :] == self.deltaL.z_polar):\n        print('z grids are not the same')\n        return -1\n    else:\n        print('z grid ok')\n\n    # check frequency\n    # Nfreq_Spp = self.src.SppInterpolated.shape[-2]\n    # Nfreq_deltaL = self.deltaL.deltaLInterpolated.shape[-2]\n    if not np.all(self.src.frequencies == self.deltaL.frequencies):\n        print('frequencies are not the same')\n        print(self.src.frequencies)\n        print(self.deltaL.frequencies)\n        return -1\n    else:\n        self.frequencies = self.src.frequencies\n        print('frequencies ok')\n    self.Nx = self.src.x_interpolate.shape[0]\n    self.Ny = self.src.x_interpolate.shape[1]\n    self.Nz = self.src.x_interpolate.shape[2]\n    self.Nfreq = self.frequencies.size\n</code></pre>"},{"location":"reference/spl.html#src.prepost.spl.SplField.check_compatibility_cart","title":"<code>check_compatibility_cart()</code>","text":"<p>Checks the compatibility between the <code>Source</code> data and <code>DelteLField</code> data in cartesian coordinates.</p> <p>Returns:</p> <ul> <li> <code>int</code>          \u2013            <p>Returns -1 if the data is not compatible.</p> </li> </ul> Source code in <code>src/prepost/spl.py</code> <pre><code>def check_compatibility_cart(self):\n    \"\"\"\n    Checks the compatibility between the `Source` data and `DelteLField` data in cartesian coordinates.\n\n    Returns:\n        int: Returns -1 if the data is not compatible.\n    \"\"\"\n\n    shape_Spp = self.src.SppInterpolated[..., 0, 0, 0].shape\n    if self.deltaL.deltaL_cart is None:\n        logging.warning(\" no delta_L cart in the ddat\")\n        return -1\n    shape_deltaL = self.deltaL.deltaL_cart[..., 0, 0].shape\n\n    # check space shape\n    if shape_deltaL != shape_Spp:\n        print('Spp and delta L must be of same size')\n        print(shape_deltaL)\n        print(shape_Spp)\n\n    if not np.all(self.src.x_interpolate == self.deltaL.x_cart):\n        print('x grids are not the same')\n        return -1\n    else:\n        print('x grid ok')\n    if not np.all(self.src.y_interpolate == self.deltaL.y_cart):\n        print('y grids are not the same')\n        print(self.src.y_interpolate)\n        print(self.deltaL.y_cart)\n        return -1\n    else:\n        print('y grid ok')\n    if not np.all(self.src.z_interpolate == self.deltaL.z_cart):\n        print('z grids are not the same')\n        return -1\n    else:\n        print('z grid ok')\n\n    # check frequency\n    # Nfreq_Spp = self.src.SppInterpolated.shape[-2]\n    # Nfreq_deltaL = self.deltaL.deltaLInterpolated.shape[-2]\n    if not np.all(self.src.frequencies == self.deltaL.frequencies):\n        print('frequencies are not the same')\n        print(self.src.frequencies)\n        print(self.deltaL.frequencies)\n        return -1\n    else:\n        self.frequencies = self.src.frequencies\n        print('frequencies ok')\n    self.Nx = self.src.x_interpolate.shape[0]\n    self.Ny = self.src.x_interpolate.shape[1]\n    self.Nz = self.src.x_interpolate.shape[2]\n    self.Nfreq = self.frequencies.size\n</code></pre>"},{"location":"reference/spl.html#src.prepost.spl.SplField.interpolate","title":"<code>interpolate(x, y)</code>","text":"<p>Interpolates the source and deltaL on the same grid.</p> <p>Parameters:</p> <ul> <li> <code>x</code>               (<code>ndarray</code>)           \u2013            <p>The x-coordinates for interpolation.</p> </li> <li> <code>y</code>               (<code>ndarray</code>)           \u2013            <p>The y-coordinates for interpolation.</p> </li> </ul> Source code in <code>src/prepost/spl.py</code> <pre><code>def interpolate(self, x: np.array, y: np.array):\n    \"\"\"\n    Interpolates the source and deltaL on the same grid.\n\n    Args:\n        x (np.ndarray): The x-coordinates for interpolation.\n        y (np.ndarray): The y-coordinates for interpolation.\n    \"\"\"\n    self.src.interpolate_xy(x, y)\n    self.deltaL.interpolate_xy(x, y)\n    self.x = x\n    self.y = y\n</code></pre>"},{"location":"reference/spl.html#src.prepost.spl.SplField.combine_linear_broadband","title":"<code>combine_linear_broadband(free_field=False)</code>","text":"<p>Combines the \\(S_{pp}\\) and \\(\\Delta L\\) fields with linear interpolation between to source heights. First the function check if the two fields are compatible then the sum of \\(S_{pp}\\) and \\(\\Delta L\\) is done for each angular position, segment and frequency.</p> <p>Parameters:</p> <ul> <li> <code>free_field</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Flag indicating if only the free field result must be coomputed, disregarding the Delta L. Default is False.</p> </li> </ul> Source code in <code>src/prepost/spl.py</code> <pre><code>def combine_linear_broadband(self,free_field=False):\n    \"\"\"\n    Combines the $S_{pp}$ and $\\Delta L$ fields with linear interpolation between to source heights.\n    First the function check if the two fields are compatible then the sum of $S_{pp}$ and $\\Delta L$ is done for each angular position, segment and frequency.\n\n\n    Args:\n        free_field (bool): Flag indicating if only the free field result must be coomputed, disregarding the Delta L. Default is False.\n    \"\"\"\n\n    # 2D OASPL computation\n    # ---------------------------------------------------------------------\n    print('combining ...')\n    proximity = self.src.wt.proximityLinear(self.deltaL.height)\n    shape_Spp = self.src.SppInterpolated[..., 0, 0, 0].shape\n    shape_deltaL = self.deltaL.deltaL_cart[..., 0, 0].shape\n    if shape_deltaL != shape_Spp:\n        print('Spp and delta L must be of same size')\n        print(shape_deltaL)\n        print(shape_Spp)\n        quit()\n    if len(shape_Spp) == 2:\n        (nx, nz) = shape_Spp\n        ny = 1\n    if len(shape_Spp) == 3:\n        (nx, ny, nz) = shape_Spp\n    elif len(shape_Spp) == 1:\n        (nx,) = shape_Spp\n        nz = 1\n        ny = 1\n    else:\n        print('space dimension not handle by the actual code ')\n        quit()\n\n    final_SPL_seg_freq_time = np.zeros(np.shape(self.src.SppInterpolated))\n\n    for ibeta in np.arange(0, self.src.wt.Nbeta):\n        print('ibeta = ' + str(ibeta))\n        # create coresponding matrix for Spp and Delta L fo one angle \n        # ---------------------------------------------------------------\n        SPL_tot_ff = self.src.SppInterpolated[..., ibeta]\n        delta_L = np.zeros_like(SPL_tot_ff)\n        for iseg in range(self.src.wt.Nblade*self.src.wt.Nseg):\n\n            delta_L[..., iseg, :] = 10*np.log10(proximity[iseg, ibeta, 2] *\n                                    10**(self.deltaL.deltaL_cart[..., proximity[iseg, ibeta, 0]]/10) + \n                                        (1-proximity[iseg, ibeta, 2])*\n                                    10**(self.deltaL.deltaL_cart[..., proximity[iseg, ibeta, 1]]/10))\n\n        #   sum Spp and Delta L\n        #------------------------------------------------------------------\n        if free_field:\n            final_SPL_seg_freq_time[..., ibeta] = SPL_tot_ff\n        else:\n            final_SPL_seg_freq_time[..., ibeta] = SPL_tot_ff + delta_L\n\n    self.SPL_seg = final_SPL_seg_freq_time.reshape(nx, ny, nz,\n                                                   self.src.wt.Nseg,\n                                                   self.src.wt.Nblade,\n                                                   len(self.frequencies),\n                                                   self.src.Nbeta)\n    print('done combining')\n    self.x_grid = self.deltaL.x_cart\n    self.y_grid = self.deltaL.y_cart\n    self.z_grid = self.deltaL.z_cart\n</code></pre>"},{"location":"reference/spl.html#src.prepost.spl.SplField.interpolate_from_polar","title":"<code>interpolate_from_polar(x, y)</code>","text":"<p>Interpolates the SPL field from polar coordinates to Cartesian coordinates. This is done if the the Delta L and Spp where combined in polar coordinates in the first place.</p> <p>Parameters:</p> <ul> <li> <code>x</code>               (<code>ndarray</code>)           \u2013            <p>The x-coordinates for interpolation.</p> </li> <li> <code>y</code>               (<code>ndarray</code>)           \u2013            <p>The y-coordinates for interpolation.</p> </li> </ul> Source code in <code>src/prepost/spl.py</code> <pre><code>def interpolate_from_polar(self, x: np.ndarray, y: np.ndarray):\n    \"\"\"\n    Interpolates the SPL field from polar coordinates to Cartesian coordinates.\n    This is done if the the Delta L and Spp where combined in polar coordinates in the first place.\n\n    Args:\n        x (np.ndarray): The x-coordinates for interpolation.\n        y (np.ndarray): The y-coordinates for interpolation.\n    \"\"\" \n\n    xy_polar = np.concatenate(\n            (self.x_grid[:, :, 0].reshape((-1, 1)),\n             self.y_grid[:, :, 0].reshape((-1, 1))), 1)\n    print(\"start interpolation ...\")\n\n    x_cart, y_cart = np.meshgrid(x, y, indexing=\"ij\")\n    xy_cart = np.zeros([x_cart.shape[0] * x_cart.shape[1], 2])\n    xy_cart[:, 0] = x_cart.flatten()\n    xy_cart[:, 1] = y_cart.flatten()\n    # create knots for the interpolation\n\n    vtx, wts = interp_weights(xy_polar, xy_cart)\n    print(\"finished creating knot ...\")\n\n    # loop of z, freq, heights and interpolate\n    # using the previously computes knots\n    print(\"starting loop on height and frequency band ...\")\n    tag = False\n    # ---------------------------------------------------------------------\n    if self.OASPL_time is not None:\n        print(\"interpolate OASPL_time\")\n        OASPL_cart = np.zeros((x_cart.shape[0],\n                               x_cart.shape[1],\n                               1, self.Nt))\n\n        for it in range(self.Nt):\n            values = self.OASPL_time[:, :, 0, it].flatten()\n            valuesInterpolated = interpolate(values, vtx, wts)\n            OASPL_cart[:, :, 0, it] = valuesInterpolated.reshape(\n                    x_cart.shape[0], x_cart.shape[1])\n        self.OASPL_time = OASPL_cart\n        tag = True\n    # ---------------------------------------------------------------------\n    if self.OASPL_seg_tot is not None:\n        print(\"interpolate OASPL_seg_tot\")\n        OASPL_cart = np.zeros((x_cart.shape[0],\n                               x_cart.shape[1],\n                               1, self.Nbeta))\n        for it in range(self.Nbeta):\n            values = self.OASPL_seg_tot[:, :, 0, it].flatten()\n            valuesInterpolated = interpolate(values, vtx, wts)\n            OASPL_cart[:, :, 0, it] = valuesInterpolated.reshape(\n                    x_cart.shape[0], x_cart.shape[1])\n        self.OASPL_seg_tot = OASPL_cart\n        tag = True\n\n    # ---------------------------------------------------------------------\n    if self.OASPL_seg is not None:\n        print(self.OASPL_seg.shape)\n        print(\"interpolate OASPL_seg\")\n        OASPL_cart = np.zeros((x_cart.shape[0],\n                               x_cart.shape[1],\n                               1,\n                               self.wt.Nseg, self.wt.Nblade,\n                               self.wt.Nbeta))\n        for iseg in range(self.wt.Nseg):\n            for iblade in range(self.wt.Nblade):\n                for it in range(self.wt.Nbeta):\n                    values = self.OASPL_seg[:, :, 0, iseg,\n                                            iblade, it].flatten()\n                    valuesInterpolated = interpolate(values, vtx, wts)\n                    OASPL_cart[:, :, 0, iseg,\n                               iblade,\n                                it] = valuesInterpolated.reshape(\n                                       x_cart.shape[0], x_cart.shape[1])\n        self.OASPL_seg = OASPL_cart\n        tag = True\n\n    # ---------------------------------------------------------------------\n    if self.SPL_seg is not None:\n        print(\"interpolate SPL_seg\")\n        SPL_cart = np.zeros((x_cart.shape[0],\n                            x_cart.shape[1],\n                            1,\n                            self.wt.Nseg, self.wt.Nblade,\n                            self.Nfreq, self.wt.Nbeta))\n        print(SPL_cart.shape)\n\n        for iseg in range(self.wt.Nseg):\n            for iblade in range(self.wt.Nblade):\n                for ifreq in range(self.Nfreq):\n                    for it in range(self.wt.Nbeta):\n                        values = self.SPL_seg[:, :, 0, iseg,\n                                            iblade, ifreq, it].flatten()\n                        valuesInterpolated = interpolate(values, vtx, wts)\n                        SPL_cart[:, :, 0, iseg,\n                               iblade,\n                               ifreq, it] = valuesInterpolated.reshape(\n                                       x_cart.shape[0], x_cart.shape[1])\n        self.SPL_seg = SPL_cart\n        tag = True\n\n    if tag:\n        [self.x_grid, self.y_grid, self.z_grid] = np.meshgrid(\n                x, y, self.z_grid[0, 0, :], indexing=\"ij\")\n        self.Nx = x.size\n        self.Ny = y.size\n    print(\"done\")\n</code></pre>"},{"location":"reference/spl.html#src.prepost.spl.SplField.create_full_rotation","title":"<code>create_full_rotation()</code>","text":"<p>The computation are usual done for a third of rotation which is sufficient to have the complete rotation because there are 3 blades. This function loops the results three time over the Blade angle to obtain a complete rotation of the rotor.</p> Source code in <code>src/prepost/spl.py</code> <pre><code>def create_full_rotation(self):\n    \"\"\"\n    The computation are usual done for a third of rotation which is sufficient to have the complete rotation because there are 3 blades.\n    This function loops the results three time over the Blade angle to obtain a complete rotation of the rotor.\n    \"\"\"\n    if self.FULL_ROTATION:\n        logging.warning(\"solution is already convert to full rotation\")\n        return \n    if self.SPL_seg is not None:\n        self.SPL_seg = np.concatenate((self.SPL_seg,\n                                       self.SPL_seg[:, :, :, :,\n                                                    [1, 2, 0], :, :],\n                                       self.SPL_seg[:, :, :, :,\n                                                    [2, 0, 1], :, :]),\n                                      axis=6)\n    if self.OASPL_seg is not None:\n        self.OASPL_seg = np.concatenate((self.OASPL_seg,\n                                       self.OASPL_seg[:, :, :, :,\n                                                      [1, 2, 0], :],\n                                       self.OASPL_seg[:, :, :, :,\n                                                      [2, 0, 1], :]),\n                                        axis=5)\n    if self.OASPL_seg_tot is not None:\n        self.OASPL_seg_tot = np.concatenate((self.OASPL_seg_tot,\n                                       self.OASPL_seg_tot,\n                                       self.OASPL_seg_tot),\n                                        axis=3)\n    self.Nbeta = self.Nbeta*3\n    self.FULL_ROTATION = True\n    print('create full rotation')\n</code></pre>"},{"location":"reference/spl.html#src.prepost.spl.SplField.clean_full_rotation","title":"<code>clean_full_rotation()</code>","text":"<p>Cleans the full rotation of the SPL field. Check if full rotation was computed before removing the additional angle.</p> Source code in <code>src/prepost/spl.py</code> <pre><code>def clean_full_rotation(self):\n    \"\"\"\n    Cleans the full rotation of the SPL field.\n    Check if full rotation was computed before removing the additional angle.\n    \"\"\"\n\n    if not self.FULL_ROTATION:\n        logging.warning(\"solution was not convert to full rotation\")\n        return\n    if self.SPL_seg is not None:\n        self.SPL_seg = self.SPL_seg[:, :, :, :, :, :, 0:self.Nbeta//3]\n        logging.info('SPL_seg shape : ' + str(self.SPL_seg.shape))\n    self.Nbeta = self.Nbeta//3\n    self.FULL_ROTATION = False\n    print('cleaned full rotation')\n</code></pre>"},{"location":"reference/spl.html#src.prepost.spl.SplField.compute_receiver_time","title":"<code>compute_receiver_time()</code>","text":"<p>Computes the receiver time for each receiver/source pair. The distance between each blade segment and receiver at each angular position is computed. Then the propagation time is computed with a reference wind speed of c0=343ms. The modulo of the propagation time with respect to a complete rotation is then computed. </p> <p>Hence each receiver time is comprise between 0 and \\(2\\pi / \\Omega\\).</p> Source code in <code>src/prepost/spl.py</code> <pre><code>def compute_receiver_time(self):\n    \"\"\"\n    Computes the receiver time for each receiver/source pair.\n    The distance between each blade segment and receiver at each angular position is computed.\n    Then the propagation time is computed with a reference wind speed of c0=343ms.\n    The modulo of the propagation time with respect to a complete rotation is then computed. \n\n    Hence each receiver time is comprise between 0 and $2\\pi / \\Omega$.\n    \"\"\"\n\n    print('compute receiver time ...')\n    c0 = 343\n    # (nx,ny,nz,src.wt.Nseg,src.wt.Nblade,len(freq),src.Nbeta)\n    x = self.x_grid[:, 0, 0].reshape(-1, 1, 1, 1, 1, 1)\n    y = self.y_grid[0, :, 0].reshape(1, -1, 1, 1, 1, 1)\n    z = self.z_grid[0, 0, :].reshape(1, 1, -1, 1, 1, 1)\n\n    self.wt.computeBeta()\n    beta = self.wt.beta.reshape(1, 1, 1, 1, self.wt.Nblade, self.wt.Nbeta)\n    beta = np.concatenate((beta, beta+2*np.pi/3, beta+4*np.pi/3), axis=5)\n    seg = self.wt.seg.reshape(1, 1, 1, self.wt.Nseg, 1, 1)\n\n    # compute segment location\n    # modif source :\n    zS = (np.cos(beta) * seg + self.wt.href)\n    xS = -np.sin(beta) * seg * np.sin(self.wt.tau) + self.xS\n    yS = -np.sin(beta) * seg * np.cos(self.wt.tau) + self.yS\n\n    # test\n    # zS = (np.cos(beta) * seg *0. + self.wt.href)\n    # xS = -np.sin(beta) * seg * np.sin(self.wt.tau) * 0. + self.xS\n    # yS = -np.sin(beta) * seg * np.cos(self.wt.tau) * 0. + self.yS\n\n    # compute distance between source and receiver\n    R = np.sqrt((x - xS)**2 + (y - yS)**2 + (z - zS)**2)\n\n    # absolute time of signal reception\n    self.t = R/c0 + beta[:, :, :, :, 0, :].reshape(1, 1, 1,\n                                                   1, 1, -1)/self.wt.omega\n\n    # copy first angle at the end\n    self.t = np.concatenate((self.t, self.t[..., 0:1]), 5)\n\n    # modulo one rotation\n    self.t = (self.t) % (2*np.pi/(self.wt.omega))\n    print('done.')\n    print(self.t.shape)\n</code></pre>"},{"location":"reference/spl.html#src.prepost.spl.SplField.compute_real_receiver_time","title":"<code>compute_real_receiver_time(loop=True, last=True)</code>","text":"<p>Computes the receiver time for each receiver/source pair.  The distance between each blade segment and receiver at each angular position is computed.  Then the propagation time is computed with a reference wind speed of c0=343ms.</p> <p>Args: last (bool): Flag indicating if the last time is considered. Default is True. loop (bool): Flag indicating if the last time is set equal the first or not. Default is True.</p> Source code in <code>src/prepost/spl.py</code> <pre><code>def compute_real_receiver_time(self,loop=True,last=True):\n    \"\"\"\n    Computes the receiver time for each receiver/source pair.\n    The distance between each blade segment and receiver at each angular position is computed.\n    Then the propagation time is computed with a reference wind speed of c0=343ms.\n\n   Args:\n   last (bool): Flag indicating if the last time is considered. Default is True.\n   loop (bool): Flag indicating if the last time is set equal the first or not. Default is True.\n\n    \"\"\"\n    print('compute receiver time ...')\n    c0 = 343\n    # (nx,ny,nz,src.wt.Nseg,src.wt.Nblade,len(freq),src.Nbeta)\n    x = self.x_grid[:, 0, 0].reshape(-1, 1, 1, 1, 1, 1)\n    y = self.y_grid[0, :, 0].reshape(1, -1, 1, 1, 1, 1)\n    z = self.z_grid[0, 0, :].reshape(1, 1, -1, 1, 1, 1)\n\n    self.wt.computeBeta()\n    beta = self.wt.beta.reshape(1, 1, 1, 1, self.wt.Nblade, self.wt.Nbeta)\n    if self.FULL_ROTATION:\n        beta = np.concatenate((beta,\n                               beta+2*np.pi/3, beta+4*np.pi/3), axis=5)\n    seg = self.wt.seg.reshape(1, 1, 1, self.wt.Nseg, 1, 1)\n\n    # compute segment location\n    # modif source :\n    zS = (np.cos(beta) * seg + self.wt.href)\n    xS = -np.sin(beta) * seg * np.sin(self.wt.tau) + self.xS\n    yS = -np.sin(beta) * seg * np.cos(self.wt.tau) + self.yS\n\n    # compute distance between source and receiver\n    # zS = (np.cos(beta) * seg * 0 + self.wt.href)\n    # xS = -np.sin(beta) * seg * np.sin(self.wt.tau) + self.xS\n    # yS = -np.sin(beta) * seg * np.cos(self.wt.tau)  + self.yS\n\n    R = np.sqrt((x - xS)**2 + (y - yS)**2 + (z - zS)**2)\n\n    # absolute time of signal reception\n    self.t = R/c0 + beta[:, :, :, :, 0, :].reshape(1, 1, 1,\n                                                   1, 1, -1)/self.wt.omega\n\n    if last:\n        if loop:\n            # for freq to time \n            self.t = np.concatenate((self.t,\n                             self.t[..., 0:1]), 5)\n        else:\n            # for receiver to time\n            self.t = np.concatenate((self.t,\n                             self.t[..., 0:1]+2*np.pi/self.wt.omega), 5)\n    print('done.')\n</code></pre>"},{"location":"reference/spl.html#src.prepost.spl.SplField.angle_to_time_2","title":"<code>angle_to_time_2(dt)</code>","text":"<p>Converts the SPL as a function of the rotor angle (<code>SPL_seg</code>) to the SPL  as a function of receiver time (<code>SPL_time</code>). There is several method to do this transformation.  In this function a loop is done over all receiver positions.  For each ti a check is perfomed on each segment and angular position to check  if the receiver_time T computed satisfies ti&gt;T and ti+1 &gt; T and ti&gt;ti+1. then the contribution of all segement is added logarythmically.  This is not the prefered version anymore. </p> <p>Parameters:</p> <ul> <li> <code>dt</code>               (<code>float</code>)           \u2013            <p>The time step.</p> </li> </ul> Source code in <code>src/prepost/spl.py</code> <pre><code>def angle_to_time_2(self, dt):\n    \"\"\"\n    Converts the SPL as a function of the rotor angle (`SPL_seg`) to the SPL \n    as a function of receiver time (`SPL_time`).\n    There is several method to do this transformation. \n    In this function a loop is done over all receiver positions. \n    For each ti a check is perfomed on each segment and angular position to check \n    if the receiver_time T computed satisfies ti&gt;T and ti+1 &gt; T and ti&gt;ti+1.\n    then the contribution of all segement is added logarythmically. \n    This is not the prefered version anymore. \n\n    Args:\n        dt (float): The time step.\n    \"\"\"\n    print('start converting angle to time ...')\n    # define the time array according to max time and dt\n\n    tmin = dt\n    tmax = np.max(self.t)\n    t_array = np.arange(tmin, tmax+dt, dt)\n\n    t_array = np.arange(0, 2 * np.pi / (self.wt.omega), dt)\n\n    print(t_array[-1])\n    print(tmax)\n    print(2*np.pi/(self.wt.omega))\n\n    Nt = len(t_array)\n    (nx, ny, nz, Nseg, Nblade, Nfreq, Nbeta) = self.SPL_seg.shape\n    print('time array :' + str(Nt))\n\n    # intialize output matrix\n    self.SPL_time = np.zeros((nx, ny, nz, Nfreq, Nt))\n    pp_time = np.zeros((nx, ny, nz, Nfreq, Nt))\n    print('start loop over t ...')\n    time0 = time()\n    t_mask = 0\n    t_sum = 0\n    t_copy = 0\n    print('compute pp_seg ...')\n    ne.set_num_threads(8)\n    pp_seg = ne.evaluate('10**(spl/10)', local_dict={'spl': self.SPL_seg})\n    print('done.')\n    # loop over T\n    for ii, t in enumerate(t_array):\n        print(t)\n        t0 = time()\n        for ix in range(self.t.shape[0]):\n            for iy in range(self.t.shape[1]):\n                for iz in range(self.t.shape[2]):\n\n                    t_loop = time()\n                    # create masking array\n                    # all values where ti &gt;T and ti+1 &gt; T and ti&gt;ti+1\n                    # the last condition is important: because of the\n                    # modulo omega the t(beta) is not allways increasing\n                    ti_m = self.t[ix, iy, iz, :, :, 0:-1]\n                    ti_p = self.t[ix, iy, iz, :, :, 1:]\n\n                    m1 = np.asarray(((ti_m &lt;= t) &amp; (ti_p &gt;= t)\n                                     &amp; (ti_m &lt; ti_p)), dtype=bool)\n\n                    m2 = np.asarray(((\n                        (((ti_m - 2*np.pi/(self.wt.omega)) &lt;= t)\n                         &amp; (ti_p &gt;= t)) |\n                        ((ti_m &lt;= t)\n                         &amp; ((ti_p + 2*np.pi / (self.wt.omega)) &gt;= t)))\n                        &amp; (ti_m &gt; ti_p)), dtype=bool)\n\n                    mask = np.logical_or(m1, m2)\n                    t1 = time()\n                    t_mask += t1 - t_loop\n\n                    mm = np.any(mask, (0, 1, 2))\n                    if mm:\n                        pp_time[ix, iy, iz, :, ii] = np.sum(\n                                pp_seg[ix, iy, iz, :, :, :, :],\n                                axis=(0, 1, 3),\n                                where=mask[:, :, None, :])\n                    t2 = time()\n                    t_sum += t2 - t1\n\n        tend = time()\n        print('create mask time = ' + str((t_mask)/(tend-t0)*100)+'%')\n        print('sum time = ' + str((t_sum)/(tend-t0)*100)+'%')\n        print('total time =' + str(tend - t0) + 's.')\n        t_mask = 0\n        t_sum = 0\n\n    print('compute SPL ...')\n    self.SPL_time = ne.evaluate('10*log10(pp)', local_dict={'pp': pp_time})\n    # self.SPL_time = 10*np.log10(pp_time)\n    self.time = t_array\n    self.Nt = self.time.size\n    print(\"done.\")\n</code></pre>"},{"location":"reference/spl.html#src.prepost.spl.SplField.compute_one_position_to_time","title":"<code>compute_one_position_to_time(ix, iy, iz, pp_seg, pp_time)</code>","text":"<p>Converts the SPL as a function of the rotor angle (<code>SPL_seg</code>) to the SPL  as a function of receiver time (<code>SPL_time</code>). There is several method to do this transformation. In this function a time signal is created from <code>pp_seg</code> for each blade at each angular position.  Each of this grain is shifted in time according to the <code>compute_receiver_time</code> function.  All grain are then added together to create the final <code>pp_time</code> signal.  In this method there is no overlap between grain. </p> <p>Parameters:</p> <ul> <li> <code>ix</code>               (<code>int</code>)           \u2013            <p>The x-index.</p> </li> <li> <code>iy</code>               (<code>int</code>)           \u2013            <p>The y-index.</p> </li> <li> <code>iz</code>               (<code>int</code>)           \u2013            <p>The z-index.</p> </li> <li> <code>pp_seg</code>               (<code>ndarray</code>)           \u2013            <p>The SPL segment data.</p> </li> <li> <code>pp_time</code>               (<code>ndarray</code>)           \u2013            <p>The SPL time data.</p> </li> </ul> Source code in <code>src/prepost/spl.py</code> <pre><code>def compute_one_position_to_time(self, ix, iy, iz, pp_seg, pp_time):\n    \"\"\"\n    Converts the SPL as a function of the rotor angle (`SPL_seg`) to the SPL \n    as a function of receiver time (`SPL_time`).\n    There is several method to do this transformation.\n    In this function a time signal is created from `pp_seg` for each blade at each angular position. \n    Each of this grain is shifted in time according to the `compute_receiver_time` function. \n    All grain are then added together to create the final `pp_time` signal. \n    In this method there is no overlap between grain. \n\n    Args:\n        ix (int): The x-index.\n        iy (int): The y-index.\n        iz (int): The z-index.\n        pp_seg (np.ndarray): The SPL segment data.\n        pp_time (np.ndarray): The SPL time data.\n    \"\"\"\n    # for iblade in [2]:\n    for iblade in range(pp_seg.shape[1]):\n        # for iblade in range(1):\n        for iseg in range(pp_seg.shape[0]):\n            # for iseg in [pp_seg.shape[0]-1]:\n            t0 = self.t[ix, iy, iz, iseg, iblade, 0]\n            i_first = int((t0 % self.T) * self.sampling)\n            it = i_first\n            # without overlap\n            for ibeta in range(0, pp_seg.shape[3]):\n                tend = self.t[ix, iy, iz, iseg, iblade, ibeta+1]\n                iend = int((tend % self.T) * self.sampling)\n                if iend &gt; it:\n                    indices = np.arange(it, iend, 1)\n                else:\n                    # print('ibeta loop = %s'%(ibeta))\n                    indices = np.concatenate([np.arange(it, self.Nt, 1),\n                                              np.arange(0, iend, 1)],\n                                             axis=0)\n                # indices = np.arange(it,iend,1) % self.Nt\n                pp_time[:, indices] = pp_time[:, indices] + \\\n                        pp_seg[iseg, iblade, :, ibeta, None]\n                t0 = tend\n                it = iend\n</code></pre>"},{"location":"reference/spl.html#src.prepost.spl.SplField.compute_one_position_to_time_overlap","title":"<code>compute_one_position_to_time_overlap(ix, iy, iz, pp_seg, pp_time)</code>","text":"<p>Converts the SPL as a function of the rotor angle (<code>SPL_seg</code>) to the SPL  as a function of receiver time (<code>SPL_time</code>). There is several method to do this transformation. In this function a time signal is created from <code>pp_seg</code> for each blade at each angular position.  Each of this grain is shifted in time according to the <code>compute_receiver_time</code> function.  All grain are then added together to create the final <code>pp_time</code> signal.  In this method there is an overlap between grain.  The number of sample where the overlap occurs is set by <code>self.overlap</code>.</p> <p>Parameters:</p> <ul> <li> <code>ix</code>               (<code>int</code>)           \u2013            <p>The x-index.</p> </li> <li> <code>iy</code>               (<code>int</code>)           \u2013            <p>The y-index.</p> </li> <li> <code>iz</code>               (<code>int</code>)           \u2013            <p>The z-index.</p> </li> <li> <code>pp_seg</code>               (<code>ndarray</code>)           \u2013            <p>The SPL segment data.</p> </li> <li> <code>pp_time</code>               (<code>ndarray</code>)           \u2013            <p>The SPL time output data.</p> </li> </ul> Source code in <code>src/prepost/spl.py</code> <pre><code>def compute_one_position_to_time_overlap(self, ix, iy, iz, pp_seg, pp_time):\n    \"\"\"\n    Converts the SPL as a function of the rotor angle (`SPL_seg`) to the SPL \n    as a function of receiver time (`SPL_time`).\n    There is several method to do this transformation.\n    In this function a time signal is created from `pp_seg` for each blade at each angular position. \n    Each of this grain is shifted in time according to the `compute_receiver_time` function. \n    All grain are then added together to create the final `pp_time` signal. \n    In this method there is an overlap between grain. \n    The number of sample where the overlap occurs is set by `self.overlap`.\n\n    Args:\n        ix (int): The x-index.\n        iy (int): The y-index.\n        iz (int): The z-index.\n        pp_seg (np.ndarray): The SPL segment data.\n        pp_time (np.ndarray): The SPL time output data.\n    \"\"\"\n    for iblade in range(pp_seg.shape[1]):\n        for iseg in range(pp_seg.shape[0]):\n            t0 = self.t[ix, iy, iz, iseg, iblade, 0]\n            i_first = int((t0 % self.T) * self.sampling)\n            it = i_first\n            # overlap\n            for ibeta in range(0, pp_seg.shape[3]):\n                # deltaT = (self.t[ix, iy, iz, iseg, iblade, ibeta+1] - t0)\n                tend = self.t[ix, iy, iz, iseg, iblade, ibeta+1]\n                iend = int((tend % self.T) * self.sampling)\n                i0 = (it - self.overlap) % self.Nt\n                i1 = (iend + self.overlap) % self.Nt\n                # print(i0)\n                # print(i1)\n                if i1 &gt; i0:\n                    indices = np.arange(i0, i1, 1)\n                else:\n                    # print('ibeta loop = %s'%(ibeta))\n                    indices = np.concatenate([np.arange(i0, self.Nt, 1),\n                                              np.arange(0, i1, 1)],\n                                             axis=0)\n                # indices = np.arange(it,iend,1) % self.Nt\n\n                window = cos_window(len(indices), 2*self.overlap)\n\n                pp_time[:, indices] = pp_time[:, indices]\n                + window * pp_seg[iseg, iblade, :, ibeta, None]\n                t0 = tend\n                it = iend\n</code></pre>"},{"location":"reference/spl.html#src.prepost.spl.SplField.angle_to_time_3","title":"<code>angle_to_time_3(x, y, z, dt=0.1)</code>","text":"<p>Converts the SPL as a function of the rotor angle (<code>SPL_seg</code>) to the SPL  as a function of receiver time (<code>SPL_time</code>) for a given position without overlap. This uses the function <code>compute_one_position_to_time</code>.</p> <p>Parameters:</p> <ul> <li> <code>x</code>               (<code>float</code>)           \u2013            <p>The x-coordinate.</p> </li> <li> <code>y</code>               (<code>float</code>)           \u2013            <p>The y-coordinate.</p> </li> <li> <code>z</code>               (<code>float</code>)           \u2013            <p>The z-coordinate.</p> </li> <li> <code>dt</code>               (<code>float</code>, default:                   <code>0.1</code> )           \u2013            <p>The time step. Default is 0.1.</p> </li> </ul> Source code in <code>src/prepost/spl.py</code> <pre><code>def angle_to_time_3(self,x:float,y:float,z:float,dt:float=0.1):\n    \"\"\"\n    Converts the SPL as a function of the rotor angle (`SPL_seg`) to the SPL \n    as a function of receiver time (`SPL_time`) for a given position without overlap.\n    This uses the function `compute_one_position_to_time`.\n\n    Args:\n        x (float): The x-coordinate.\n        y (float): The y-coordinate.\n        z (float): The z-coordinate.\n        dt (float, optional): The time step. Default is 0.1.\n    \"\"\"\n    # convert SPL(theta) tp spl(t) for a fiven position\n    # this should be a better way than the one coded in angle_to_time_2\n    ix = np.argmin(np.abs(self.x_grid[:, 0, 0] - x))\n    iy = np.argmin(np.abs(self.y_grid[0, :, 0] - y))\n    iz = np.argmin(np.abs(self.z_grid[0, :, 0] - z))\n    # ix = 493\n    # ix = 503\n    # ix=504\n    # ix = 531\n    self.sampling = 1/dt\n    pp_seg = (10**(self.SPL_seg[ix, iy, iz, :, :, :, :]/10))\n    # t = self.t[ix, iy, iz, :, :, :]\n    self.T = 2*np.pi/(self.wt.omega)\n    self.Nt = int(self.T*self.sampling)\n\n    pp_time = np.zeros((1, 1, 1, self.Nfreq, self.Nt))\n    self.time = np.linspace(0, self.T, self.Nt)\n    start_time = time()\n\n    self.compute_one_position_to_time(ix, iy, iz, pp_seg,\n                                      pp_time[0, 0, 0, ...])\n\n    end_time = time()\n    print(end_time - start_time)\n    plt.plot(pp_time[0, 0, 0, 0, :])\n    plt.show()\n\n    # self.SPL_time = np.roll(10*np.log10(pp_time),offset,axis=4)\n    self.SPL_time = 10*np.log10(pp_time)\n</code></pre>"},{"location":"reference/spl.html#src.prepost.spl.SplField.angle_to_time_3_full","title":"<code>angle_to_time_3_full(dt=0.1, overlap=0)</code>","text":"<p>Converts the SPL as a function of the rotor angle (<code>SPL_seg</code>) to the SPL  as a function of receiver time (<code>SPL_time</code>) for the entire domain. This uses the function <code>compute_one_position_to_time</code> if <code>overlap</code> is set to 0 and <code>compute_one_position_to_time_overlap</code> if <code>overlap&gt;0</code>.</p> <p>Parameters:</p> <ul> <li> <code>dt</code>               (<code>float</code>, default:                   <code>0.1</code> )           \u2013            <p>The time step. Default is 0.1.</p> </li> <li> <code>overlap</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>The overlap. Default is 0.</p> </li> </ul> Source code in <code>src/prepost/spl.py</code> <pre><code>def angle_to_time_3_full(self, dt: float = 0.1, overlap=0):\n    \"\"\"\n    Converts the SPL as a function of the rotor angle (`SPL_seg`) to the SPL \n    as a function of receiver time (`SPL_time`) for the entire domain.\n    This uses the function `compute_one_position_to_time` if `overlap` is set to 0\n    and `compute_one_position_to_time_overlap` if `overlap&gt;0`.\n\n    Args:\n        dt (float, optional): The time step. Default is 0.1.\n        overlap (int, optional): The overlap. Default is 0.\n    \"\"\"\n    self.overlap = overlap\n    self.sampling = 1/dt\n\n    if self.SPL_seg is not None:\n        pp_seg = (10**(self.SPL_seg/10))\n        logging.info(\"converting spl(f) into time\")\n        nfreq_tmp = self.Nfreq\n    elif self.OASPL_seg is not None:\n        pp_seg = (10**(self.OASPL_seg/10))[:, :, :, :, :, None, :]\n        logging.info(\"converting oaspl into time\")\n        nfreq_tmp = 1\n    else:\n        print(\"Error: SPL_seg or OASPL_seg mus not None\")\n        return -1\n\n    t = self.t\n    self.T = 2 * np.pi / (self.wt.omega)\n    self.Nt = int(self.T * self.sampling)\n    self.time = np.arange(0, self.T, dt)\n    self.T = self.time[-1] + dt\n\n    print('Nt = ')\n    print(self.Nt)\n    # copy first angle at the end\n    self.t = np.concatenate((self.t, self.t[..., 0:1] + self.T), 5)\n    self.t = self.t - np.min(self.t)\n    pp_time = np.zeros((self.Nx, self.Ny, self.Nz, nfreq_tmp, self.Nt))\n\n    t0 = time()\n    logging.info(\"starting loop on receiver position...\")\n    for ix in tqdm(range(self.Nx)):\n        for iy in range(self.Ny):\n            for iz in range(self.Nz):\n                # print(ix,iy,iz)\n                if overlap == 0:\n                    self.compute_one_position_to_time(ix, iy, iz,\n                                                      pp_seg[ix, iy,\n                                                             iz, ...],\n                                                      pp_time[ix, iy,\n                                                              iz, ...])\n                else:\n                    self.compute_one_position_to_time_overlap(ix, iy, iz,\n                                                            pp_seg[ix, iy,\n                                                         iz, ...],\n                                                  pp_time[ix, iy,\n                                                          iz, ...])\n\n    t1 = time()\n    print(t1-t0)\n    # plt.plot(pp_time[0,0,0,0,:])\n    # plt.show()\n\n    self.time = np.arange(0, self.T-dt, dt)\n    # self.SPL_time = np.roll(10*np.log10(pp_time),offset,axis=4)\n    if self.SPL_seg is not None:\n        self.SPL_time = 10*np.log10(pp_time)\n    elif self.OASPL_seg is not None:\n        self.OASPL_time = 10*np.log10(pp_time)[:, :, :, 0, :]\n</code></pre>"},{"location":"reference/spl.html#src.prepost.spl.SplField.save","title":"<code>save(fname)</code>","text":"<p>Save data in a pickle .dat file. B Big matrix are store in h5 files in order to open only part of the data.</p> Source code in <code>src/prepost/spl.py</code> <pre><code>def save(self,fname: str):\n    \"\"\"\n    Save data in a pickle .dat file. B\n    Big matrix are store in h5 files in order to open only part of the data.\n    \"\"\"\n    print('saving SPL ...')\n    self.src = None\n    self.deltaL = None\n\n    with h5py.File(fname[:-3]+'h5', \"w\") as f:\n        if self.SPL_time is not None:\n            f.create_dataset('SPL_time', data=self.SPL_time)\n        if self.SPL_seg is not None:\n            f.create_dataset('SPL_seg', data=self.SPL_seg)\n        if self.OASPL_time is not None:\n            f.create_dataset('OASPL_time', data=self.OASPL_time)\n        if self.OASPL_seg is not None:\n            f.create_dataset('OASPL_seg', data=self.OASPL_seg)\n        if self.OASPL_seg_tot is not None:\n            f.create_dataset('OASPL_seg_tot', data=self.OASPL_seg_tot)\n\n        if self.am_seg is not None:\n            f.create_dataset('am_seg', data=self.am_seg)\n        if self.am_time is not None:\n            f.create_dataset('am_time', data=self.am_time)\n        if self.OAam_seg is not None:\n            f.create_dataset('OAam_seg', data=self.OAam_seg)\n        if self.OAam_time is not None:\n            f.create_dataset('OAam_time', data=self.OAam_time)\n\n        if self.mean_seg is not None:\n            f.create_dataset('mean_seg', data=self.mean_seg)\n        if self.mean_time is not None:\n            f.create_dataset('mean_time', data=self.mean_time)\n        if self.OAmean_seg is not None:\n            f.create_dataset('OAmean_seg', data=self.OAmean_seg)\n        if self.OAmean_time is not None:\n            f.create_dataset('OAmean_time', data=self.OAmean_time)\n\n    self.SPL_time = None\n    self.SPL_seg = None\n    self.OASPL_time = None\n    self.OASPL_seg = None\n    self.OASPL_seg_tot = None\n\n    self.am_seg = None\n    self.am_time = None\n    self.OAam_seg = None\n    self.OAam_time = None\n\n    self.mean_seg = None\n    self.mean_time = None\n    self.OAmean_seg = None\n    self.OAmean_time = None\n\n    \"\"\"save class as self.name.dat\"\"\"\n    with open(fname,'wb') as file:\n        pickle.dump(self.__dict__,file)\n    print('done.')\n</code></pre>"},{"location":"reference/spl.html#src.prepost.spl.SplField.load","title":"<code>load(fname, seg=True, time=True, oaspl=True, am=True, mean=True, x=None, y=None, z=None, freq=None, Nt=None)</code>","text":"<p>Loads the SPL field data from a file. Flag are used to chose which data to load. WARNING: the name of the flag is very poorly chosen. Should be change at some point</p> <p>Parameters:</p> <ul> <li> <code>fname</code>               (<code>str</code>)           \u2013            <p>The file name to load the data.</p> </li> <li> <code>seg</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Flag indicating if the frequency data is loaded. Default is True.</p> </li> <li> <code>time</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Flag indicating if the time data is loaded. If false the data as function of beta is loaded. Default is True.</p> </li> <li> <code>oaspl</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Flag indicating if the OASPL data is loaded. Default is True.</p> </li> <li> <code>am</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Flag indicating if the amplitude modulation data is loaded. Default is True.</p> </li> <li> <code>mean</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Flag indicating if the time (or beta) averaged data is loaded. Default is True.</p> </li> <li> <code>x</code>               (<code>float</code>, default:                   <code>None</code> )           \u2013            <p>The x-coordinate to load the data if None load all \\(x\\) positions are loaded. Default is None.</p> </li> <li> <code>y</code>               (<code>float</code>, default:                   <code>None</code> )           \u2013            <p>The y-coordinate to load the data if None load all \\(y\\) positions are loaded. Default is None.</p> </li> <li> <code>z</code>               (<code>float</code>, default:                   <code>None</code> )           \u2013            <p>The z-coordinate to load the data if None load all \\(z\\) positions are loaded. Default is None.</p> </li> <li> <code>freq</code>               (<code>float</code>, default:                   <code>None</code> )           \u2013            <p>The frequency to load the data if None load all frequencies are loaded. Default is None.</p> </li> <li> <code>Nt</code>               (<code>int</code>, default:                   <code>None</code> )           \u2013            <p>The number of time steps to load the data. Default is None.</p> </li> </ul> Source code in <code>src/prepost/spl.py</code> <pre><code>def load(self, fname: str, seg: bool = True, time: bool = True, oaspl: bool = True, am: bool = True,\n         mean: bool = True, x: float = None, y: float = None, z: float = None, freq: float = None, Nt: int = None):\n    \"\"\"\n    Loads the SPL field data from a file.\n    Flag are used to chose which data to load.\n    WARNING: the name of the flag is very poorly chosen. Should be change at some point\n\n    Args:\n        fname (str): The file name to load the data.\n        seg (bool, optional): Flag indicating if the frequency data is loaded. Default is True.\n        time (bool, optional): Flag indicating if the time data is loaded. If false the data as function of beta is loaded. Default is True.\n        oaspl (bool, optional): Flag indicating if the OASPL data is loaded. Default is True.\n        am (bool, optional): Flag indicating if the amplitude modulation data is loaded. Default is True.\n        mean (bool, optional): Flag indicating if the time (or beta) averaged data is loaded. Default is True.\n        x (float, optional): The x-coordinate to load the data if None load all $x$ positions are loaded. Default is None.\n        y (float, optional): The y-coordinate to load the data if None load all $y$ positions are loaded. Default is None.\n        z (float, optional): The z-coordinate to load the data if None load all $z$ positions are loaded. Default is None.\n        freq (float, optional): The frequency to load the data if None load all frequencies are loaded. Default is None.\n        Nt (int, optional): The number of time steps to load the data. Default is None.\n    \"\"\"\n    logging.info('loading SPL ...')\n    with open(fname,'rb') as file:\n        self.__dict__ = pickle.load(file)\n    logging.info('done loading pickle')\n\n    if x is None:\n        ix = slice(0,self.Nx,1)\n    else:\n        ix = np.argmin(np.abs(self.x_grid[:,0,0]-x))\n        self.Nx = 1\n        self.x_grid = self.x_grid[ix:ix+1,:,:]\n        self.y_grid = self.y_grid[ix:ix+1,:,:]\n        self.z_grid = self.z_grid[ix:ix+1,:,:]\n    if y is None:\n        iy = slice(0,self.Ny,1)\n    else:\n        iy= np.argmin(np.abs(self.y_grid[0,:,0]-y))\n        self.Ny = 1\n        self.x_grid = self.x_grid[:,iy:iy+1,:]\n        self.y_grid = self.y_grid[:,iy:iy+1,:]\n        self.z_grid = self.z_grid[:,iy:iy+1,:]\n    if z is None:\n        iz = slice(0,self.Nz,1)\n    else:\n        iz = np.argmin(np.abs(self.z_grid[0,0,:]-z))\n        self.Nz = 1\n        self.x_grid = self.x_grid[:,:,iz:iz+1]\n        self.y_grid = self.y_grid[:,:,iz:iz+1]\n        self.z_grid = self.z_grid[:,:,iz:iz+1]\n    if freq is None:\n        ifreq = slice(0,self.Nfreq,1)\n        nfreq = self.Nfreq\n    else:\n        ifreq = np.argmin(np.abs(self.frequencies-freq))\n        self.Nfreq = 1\n        self.frequencies = self.frequencies[ifreq:ifreq+1]\n\n    if Nt is not None:\n        if Nt&gt;self.Nt:\n            print('error new Nt to large')\n            return\n        self.Nt = Nt\n        self.time = self.time[:self.Nt]\n\n\n\n    with h5py.File(fname[:-3]+'h5', \"r\") as f:\n        if seg and not(time):\n            if 'SPL_seg' in f:\n                logging.info('loading SPL_seg')\n                self.SPL_seg = np.array(f[\"SPL_seg\"][ix,iy,iz,:,:,ifreq,:]).reshape((self.Nx,self.Ny,self.Nz,\n                                                                                        self.wt.Nseg,self.wt.Nblade,self.Nfreq,\n                                                                                        int(self.Nbeta)))\n        if seg and time:\n            if 'SPL_time' in f:\n                logging.info('loading SPL_time')\n                self.SPL_time = np.array(f.get('SPL_time')[ix,iy,iz,ifreq,:self.Nt]).reshape((self.Nx,self.Ny,self.Nz,\n                                                                                    self.Nfreq,self.Nt))\n\n        if oaspl and not(time):\n            if 'OASPL_seg' in f:\n                self.OASPL_seg = np.array(f.get('OASPL_seg')[ix,iy,iz,:,:,:self.Nbeta])\n                logging.info('loading OASPL_seg')\n\n                self.OASPL_seg = np.array(f.get('OASPL_seg')[ix,iy,iz,\n                                                             :,:,:self.Nbeta]).reshape((self.Nx,\n                                                            self.Ny,self.Nz,\n                                                            self.wt.Nseg,self.wt.Nblade,\n                                                            self.Nbeta))\n\n            if 'OASPL_seg_tot' in f:\n                logging.info('loading OASPL_seg_tot')\n                self.OASPL_seg_tot = np.array(f.get('OASPL_seg_tot')[ix,iy,iz,\n                                                             :self.Nbeta]).reshape((self.Nx,\n                                                            self.Ny,self.Nz,\n                                                         self.Nbeta))\n        if oaspl and time:\n            if 'OASPL_time' in f:\n                logging.info('loading SPL_time')\n                self.OASPL_time = np.array(f.get('OASPL_time')[ix,iy,iz,:self.Nt]).reshape((self.Nx,self.Ny,self.Nz,self.Nt))\n\n        if am:\n            if 'am_time' in f:\n                logging.info('loading am_tim')\n                self.am_time = np.array(f.get('am_time')[ix,iy,iz,ifreq]).reshape((self.Nx,self.Ny,self.Nz,self.Nfreq))\n            if 'am_seg' in f:\n                logging.info('loading am_seg')\n                self.am_seg = np.array(f.get('am_seg')[ix,iy,iz,ifreq]).reshape((self.Nx,self.Ny,self.Nz,self.Nfreq))\n            if 'OAam_time' in f:\n                logging.info('loading OAam_time')\n                self.OAam_time = np.array(f.get('OAam_time')[ix,iy,iz]).reshape((self.Nx,self.Ny,self.Nz))\n            if 'OAam_seg' in f:\n                logging.info('loading OAam_seg')\n                self.OAam_seg = np.array(f.get('OAam_seg')[ix,iy,iz]).reshape((self.Nx,self.Ny,self.Nz))\n\n        if mean:\n            if 'mean_time' in f:\n                self.mean_time = np.array(f.get('mean_time')[ix,iy,iz,ifreq]).reshape((self.Nx,self.Ny,self.Nz,self.Nfreq))\n            if 'mean_seg' in f:\n                self.mean_seg = np.array(f.get('mean_seg')[ix,iy,iz,ifreq]).reshape((self.Nx,self.Ny,self.Nz,self.Nfreq))\n            if 'OAmean_time' in f:\n                self.OAmean_time = np.array(f.get('OAmean_time')[ix,iy,iz]).reshape((self.Nx,self.Ny,self.Nz))\n            if 'OAmean_seg' in f:\n                self.OAmean_seg = np.array(f.get('OAmean_seg')[ix,iy,iz]).reshape((self.Nx,self.Ny,self.Nz))\n\n    print('done.')\n</code></pre>"},{"location":"reference/spl.html#src.prepost.spl.SplField.shift","title":"<code>shift(xshift, yshift)</code>","text":"<p>Shifts the \\(xy\\) grid by the given x and y shifts.</p> <p>Parameters:</p> <ul> <li> <code>xshift</code>               (<code>float</code>)           \u2013            <p>The x-shift.</p> </li> <li> <code>yshift</code>               (<code>float</code>)           \u2013            <p>The y-shift.</p> </li> </ul> Source code in <code>src/prepost/spl.py</code> <pre><code>def shift(self, xshift: float, yshift: float):\n    \"\"\"\n    Shifts the $xy$ grid by the given x and y shifts.\n\n    Args:\n        xshift (float): The x-shift.\n        yshift (float): The y-shift.\n    \"\"\"\n    self.x_grid = self.x_grid + xshift\n    self.y_grid = self.y_grid + yshift\n</code></pre>"},{"location":"reference/spl.html#src.prepost.spl.SplField.atm_absorption","title":"<code>atm_absorption(c0=343, rho0=1.2, rh=80)</code>","text":"<p>Applies atmospheric absorption due to the thermo-viscous effects and relaxation of oxygen and nitrogen to the SPL field.</p> <p>alpha - attenuation of sound for input parameters in dB/m</p> <p>T0 - temperature in K</p> <p>p0 - static pressure in pascal</p> <p>rh - relative humidity</p> <p>f - frequency of sound (may be a vector)</p> <p>The attenuation can only be applied to <code>SPL_time</code> or <code>SPL_seg</code> and not to frequency integrated data.</p> <p>References:   Salomons p.109-111 Args:     c0 (float, optional): The speed of sound. Default is 343.     rho0 (float, optional): The density of air. Default is 1.2.     rh (float, optional): The relative humidity. Default is 80.</p> Source code in <code>src/prepost/spl.py</code> <pre><code>def atm_absorption(self,c0: float = 343,rho0: float = 1.2,rh: float = 80):\n    \"\"\"\n    Applies atmospheric absorption due to the thermo-viscous effects\n    and relaxation of oxygen and nitrogen to the SPL field.\n\n    alpha - attenuation of sound for input parameters in dB/m\n\n    T0 - temperature in K\n\n    p0 - static pressure in pascal\n\n    rh - relative humidity\n\n    f - frequency of sound (may be a vector)\n\n    The attenuation can only be applied to `SPL_time` or `SPL_seg` and not to frequency integrated data.\n\n    References:   Salomons p.109-111\n    Args:\n        c0 (float, optional): The speed of sound. Default is 343.\n        rho0 (float, optional): The density of air. Default is 1.2.\n        rh (float, optional): The relative humidity. Default is 80.\n    \"\"\"\n    print('compute atmospheric absorption')\n    if self.ATM_ABS:\n        logging.warning(\"atmospheric absorption already applied\")\n        return\n    if not self.third:\n        logging.warning(\"results are not int third octave band\")\n\n    rGP = 287.06;\n    gamma = 1.4# constante adiabatique\n    T0 = c0**2/(gamma*rGP)# temperature\n    p0 = rho0*c0**2/gamma# pression atmospherique\n\n    p0_ref = 1.01325e+05 # reference static pressure (pa)\n\n    T0_tpw = 273.15 # triple point in K\n    T0_ref = 293.15 # ref temp in K\n\n    rho = p0/p0_ref\n    tau = T0/T0_ref\n\n    # calculate saturation pressure\n    Csat = -6.8346*(T0_tpw/T0)**1.261 + 4.6151\n    p0_sat = p0_ref*10**Csat\n    h = rh*p0_sat/p0 # absolute humidity\n\n    # Scaled relaxation frequency for Nitrogen\n    frN = rho*tau**(-1/2)*(9 + 280*h*np.exp(-4.17*(tau**(-1/3)-1)))\n\n    # scaled relaxation frequency for Oxygen\n    frO = rho*(24 + 40400*h*(0.02+h)/(0.391+h))\n\n    # attenuation coefficient in dB/m\n    b1 = 0.1068*np.exp(-3352/T0)/(frN + self.frequencies**2/frN)\n    b2 = 0.01275*np.exp(-2239.1/T0)/(frO + self.frequencies**2/frO)\n    alpha = 8.686*self.frequencies**2*tau**(1/2)*(1.84e-11/rho + tau**(-3)*(b1 + b2))\n\n    R = np.sqrt((self.x_grid - self.xS)**2 + (self.y_grid - self.yS)**2 + (self.z_grid - self.wt.href)**2)\n    if self.SPL_seg is not None:\n        self.SPL_seg = self.SPL_seg - alpha.reshape(1,1,1,1,1,-1,1)*R.reshape(self.Nx,self.Ny,self.Nz,1,1,1,1)\n    if self.SPL_time is not None:\n        self.SPL_time = self.SPL_time - alpha.reshape(1,1,1,-1,1)*R.reshape(self.Nx,self.Ny,self.Nz,1,1)\n    self.ATM_ABS = True\n</code></pre>"},{"location":"reference/spl.html#src.prepost.spl.SplField.Aweight","title":"<code>Aweight()</code>","text":"<p>Applies A-weighting to the SPL field. The weighting can only be applied to <code>SPL_time</code> or <code>SPL_seg</code> and not to frequency integrated data.</p> Source code in <code>src/prepost/spl.py</code> <pre><code>def Aweight(self):\n    \"\"\"\n    Applies A-weighting to the SPL field.\n    The weighting can only be applied to `SPL_time` or `SPL_seg` and not to frequency integrated data.\n    \"\"\"\n    if self.AWEIGHT:\n        logging.warning(\"A weighting already applied\")\n        return\n    if not self.third:\n        logging.warning(\"results are not int third octave band\")\n    print('compute Aweight')\n    Af = 12200**2*self.frequencies**4./(self.frequencies**2+20.6**2)/(self.frequencies**2+12200**2)/(self.frequencies**2+107.7**2)**0.5/(self.frequencies**2+737.9**2)**0.5\n    dBA = 20*np.log10(Af/0.7943)\n    if self.SPL_seg is not None:\n        self.SPL_seg = self.SPL_seg + dBA.reshape(1,1,1,1,1,-1,1)\n    if self.SPL_time is not None:\n        self.SPL_time = self.SPL_time + dBA.reshape(1,1,1,-1,1)\n    self.AWEIGHT = True\n    return dBA\n</code></pre>"},{"location":"reference/spl.html#src.prepost.spl.SplField.combine_2_turbines","title":"<code>combine_2_turbines(spl2, shift=0, tmax=None)</code>","text":"<p>Combines the SPL fields of two turbines. The function first tries to combine <code>SPL_time</code>, then <code>OASPL_time</code> then <code>OASPL_seg</code>  if the array are loaded.  If the two signals dont have the same length the signal are looped until reaching a same value.  If a tmax is set this loop is cut when it reaches tmax. </p> <p>The two time signal can also be shifted with an offset added to <code>spl2</code>. </p> <p>Parameters:</p> <ul> <li> <code>spl2</code>               (<code>SplField</code>)           \u2013            <p>The second SPL field object.</p> </li> <li> <code>shift</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>The shift between the two turbines. Default is 0.</p> </li> <li> <code>tmax</code>               (<code>float</code>, default:                   <code>None</code> )           \u2013            <p>The maximum time. Default is None.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>int</code>          \u2013            <p>Returns -1 if the combination is not possible.</p> </li> </ul> Source code in <code>src/prepost/spl.py</code> <pre><code>def combine_2_turbines(self, spl2, shift: int = 0, tmax: float = None):\n    \"\"\"\n    Combines the SPL fields of two turbines.\n    The function first tries to combine `SPL_time`, then `OASPL_time` then `OASPL_seg` \n    if the array are loaded. \n    If the two signals dont have the same length the signal are looped until reaching a same value. \n    If a tmax is set this loop is cut when it reaches tmax. \n\n    The two time signal can also be shifted with an offset added to `spl2`. \n\n    Args:\n        spl2 (SplField): The second SPL field object.\n        shift (int, optional): The shift between the two turbines. Default is 0.\n        tmax (float, optional): The maximum time. Default is None.\n\n    Returns:\n        int: Returns -1 if the combination is not possible.\n    \"\"\"\n    seg_flag = False\n    if self.SPL_time is not None:\n        s1 = self.SPL_time\n        if spl2.SPL_time is not None:\n            s2 = spl2.SPL_time\n            spl_flag = 1\n        else:\n            print(\"error spl2 has no SPL_time\")\n            return -1\n    elif self.OASPL_time is not None: \n        s1 = self.OASPL_time \n        if spl2.OASPL_time is not None:\n            s2 = spl2.OASPL_time\n            spl_flag = 0\n        else:\n            print(\"error spl2 has no OASPL_time\")\n            return -1\n    elif self.OASPL_seg is not None:\n\n        s1 = self.OASPL_seg_tot\n        if spl2.OASPL_seg_tot is not None:\n            s2 = spl2.OASPL_seg_tot\n            seg_flag = True\n            spl_flag = 0\n        print(\"combine turbines for OASPL_seg_tot\")\n    else:\n        print(\"Error: no OASPL_time or SPL_time loaded\")\n\n    dim = len(s1.shape)-1\n    print(s1.shape)\n    if (s1.shape[-1] == s2.shape[-1]):\n        print('signal same size, periode unchanged')\n        spl_tot = 10*np.log10(\n                10**(s1/10)\n                + 10**(np.roll(s2,shift, axis=dim)/10))\n        if seg_flag:\n            Nt = self.Nbeta\n        else:\n            Nt = self.Nt\n    else:\n        Nt = np.lcm(self.Nt, spl2.Nt)\n        if tmax is not None:\n            Nt = min(Nt, int(tmax * self.sampling))\n        print('signal of different length, periode set to :')\n        print(Nt)\n        spl_tot = 10*np.log10(10**(uneven_loop(s1, Nt)/10) +\n                              10**(uneven_loop(s2, Nt)/10))\n\n        print('done.')\n\n    if seg_flag:\n        self.OASPL_seg_tot = spl_tot\n    elif spl_flag:\n        self.SPL_time = spl_tot\n    else:\n        self.OASPL_time = spl_tot\n    if not seg_flag:\n        self.Nt = Nt\n        dt = self.time[1]-self.time[0]\n        self.time = np.arange(0, self.Nt*dt, dt)\n</code></pre>"},{"location":"reference/spl.html#src.prepost.spl.SplField.compute_third_octave","title":"<code>compute_third_octave(fc=None, Nfc=None)</code>","text":"<p>Compute third octave band spectrum from previously computed frequencies. Be sure that fc anf Nfc corresponds to the <code>self.frequencies</code> computed.  If fc or Nfc set to None a default value are set (corresponding to frequency compute in Colas et al. (2023)).</p> <p>Modifies:</p> <ul> <li><code>SPL_time</code>  of shape (Nx, Ny, Nz, Nfreq, Nt) with new Nfreq</li> <li><code>SPL_seg</code> of shape (Nx, Ny, Nz, Nseg, Nblade, Nfreq, Nbeta) with new Nfreq</li> </ul> <p>Parameters:</p> <ul> <li> <code>fc</code>               (<code>ndarray</code>, default:                   <code>None</code> )           \u2013            <p>central frequency of each band. Default to None.</p> </li> <li> <code>Nfc</code>               (<code>ndarray</code>, default:                   <code>None</code> )           \u2013            <p>number of frequency computed per band. default to None.</p> </li> </ul> Source code in <code>src/prepost/spl.py</code> <pre><code>def compute_third_octave(self, fc: np.ndarray = None, Nfc: np.ndarray = None):\n    \"\"\"\n    Compute third octave band spectrum from previously computed frequencies.\n    Be sure that fc anf Nfc corresponds to the `self.frequencies` computed. \n    If fc or Nfc set to None a default value are set (corresponding to frequency compute in Colas et al. (2023)).\n\n    Modifies:\n\n    - `SPL_time`  of shape (Nx, Ny, Nz, Nfreq, Nt) with new Nfreq\n    - `SPL_seg` of shape (Nx, Ny, Nz, Nseg, Nblade, Nfreq, Nbeta) with new Nfreq\n\n    Args:\n        fc (np.ndarray): central frequency of each band. Default to None.\n        Nfc (np.ndarray): number of frequency computed per band. default to None.\n    \"\"\"\n    if (fc is None) or (Nfc is None):\n        print(\"set to default frequency bands\")\n        fc = [50, 63, 80, 100, 125, 160, 200, 250, 315, 400, 500, 630, 800, 1000]\n        Nfc = [1,  1,  1,   1,   1,  1,   2,   2,   3,   4,   4,   4,   5,  5]\n    print('computing third octave ...')\n    if self.third:\n        logging.warning('skipping function: results are already in 3rd octave band.')\n        return\n    if self.SPL_time is not None:\n        SPL_time_third = np.zeros(np.shape(self.SPL_time[...,0,0]) + (len(fc),self.Nt))\n    if self.SPL_seg is not None:\n        SPL_seg_third =  np.zeros(np.shape(self.SPL_seg[...,0,0]) + (len(fc),self.Nbeta))\n    for ifreq in range(len(Nfc)):\n        # temp_array = 10*np.log10(fc[ifreq]*0.232/Nfc[ifreq]* np.sum(10 ** (self.SPL_time[..., int(np.sum(Nfc[0:ifreq])):int(np.sum(Nfc[0:ifreq+1])),:]/10), axis=3))\n        # temp_array[temp_array == -inf] = 0\n        if self.SPL_time is not None:\n            SPL_time_third[..., ifreq,:] = 10*np.log10(fc[ifreq]*0.232/Nfc[ifreq]* np.sum(10 ** (self.SPL_time[..., int(np.sum(Nfc[0:ifreq])):int(np.sum(Nfc[0:ifreq+1])),:]/10), axis=3))\n        if self.SPL_seg is not None:\n            SPL_seg_third[..., ifreq,:] = 10*np.log10(fc[ifreq]*0.232/Nfc[ifreq]* np.sum(10 ** (self.SPL_seg[..., int(np.sum(Nfc[0:ifreq])):int(np.sum(Nfc[0:ifreq+1])),:]/10), axis=5))\n\n    if self.SPL_time is not None:\n        self.SPL_time = SPL_time_third\n    if self.SPL_seg is not None:\n        self.SPL_seg = SPL_seg_third\n\n    self.frequencies = np.array(fc)\n    self.Nfreq = len(fc)\n    self.third = True\n    print('done.')\n</code></pre>"},{"location":"reference/spl.html#src.prepost.spl.SplField.compute_oaspl","title":"<code>compute_oaspl()</code>","text":"<p>Compute OASPL from previously computed thrid octave band spectrum. </p> <p>Computes:</p> <ul> <li><code>OASPL_time</code>  of shape (Nx, Ny, Nz,Nt)</li> <li><code>OASPL_seg</code> of shape (Nx, Ny, Nz, Nseg, Nblade, Nbeta)</li> <li><code>OASPL_seg_tot</code> of shape (Nx, Ny, Nz, Nbeta)</li> </ul> Source code in <code>src/prepost/spl.py</code> <pre><code>def compute_oaspl(self):\n    \"\"\"\n    Compute OASPL from previously computed thrid octave band spectrum. \n\n    Computes:\n\n    - `OASPL_time`  of shape (Nx, Ny, Nz,Nt)\n    - `OASPL_seg` of shape (Nx, Ny, Nz, Nseg, Nblade, Nbeta)\n    - `OASPL_seg_tot` of shape (Nx, Ny, Nz, Nbeta)\n\n    \"\"\"\n    print('computing OASPL ...')\n    if self.third is False:\n        logging.warning('need to convert to third octave band spectra first.')\n        return -1\n    if not self.AWEIGHT:\n        logging.warning(\"computed OASPL without A weighting\")\n\n    if not self.ATM_ABS:\n        logging.warning(\"computed OASPL without atmospheric abs\")\n\n    if self.SPL_time is not None:\n        self.OASPL_time = 10*np.log10(np.sum(10**(self.SPL_time/10), 3))\n    if self.SPL_seg is not None:\n        self.OASPL_seg_tot = 10*np.log10(np.sum(10**(self.SPL_seg/10), (3,4,5)))\n        self.OASPL_seg = 10*np.log10(np.sum(10**(self.SPL_seg/10), (5)))\n    self.oaspl = True\n    print('done.')\n</code></pre>"},{"location":"reference/spl.html#src.prepost.spl.SplField.compute_am","title":"<code>compute_am()</code>","text":"<p>Compute AM from previoulsy computed spectrum or OASPL.</p> <p>Computes:</p> <ul> <li><code>am_time</code>  of shape (Nx, Ny, Nz, Nfreq)</li> <li><code>am_seg</code> of shape (Nx, Ny, Nz, Nfreq)</li> <li><code>OAam_time</code> of shape (Nx, Ny, Nz)</li> <li><code>OAam_seg</code> of shape (Nx, Ny, Nz)</li> </ul> Source code in <code>src/prepost/spl.py</code> <pre><code>def compute_am(self):\n    \"\"\"\n    Compute AM from previoulsy computed spectrum or OASPL.\n\n    Computes:\n\n    - `am_time`  of shape (Nx, Ny, Nz, Nfreq)\n    - `am_seg` of shape (Nx, Ny, Nz, Nfreq)\n    - `OAam_time` of shape (Nx, Ny, Nz)\n    - `OAam_seg` of shape (Nx, Ny, Nz)\n    \"\"\"\n    print('Computing AM ...')\n    if self.SPL_time is not None:\n        self.am_time = np.max(self.SPL_time,4)-np.min(self.SPL_time,4)\n    if self.SPL_seg is not None:\n        print(self.SPL_seg.shape)\n        spl = 10*np.log10(np.sum(10**(self.SPL_seg/10),(3,4)))\n        print(spl.shape)\n        self.am_seg = np.max(spl,4)-np.min(spl,4)\n        print(self.am_seg.shape)\n    if self.OASPL_time is not None:\n        self.OAam_time = np.max(self.OASPL_time,3)-np.min(self.OASPL_time,3)\n    if self.OASPL_seg_tot is not None:\n        self.OAam_seg = np.max(self.OASPL_seg_tot,3)-np.min(self.OASPL_seg_tot,3)\n    print('done.')\n</code></pre>"},{"location":"reference/spl.html#src.prepost.spl.SplField.compute_time_average","title":"<code>compute_time_average()</code>","text":"<p>Compute AM from previoulsy computed spectrum or OASPL.</p> <p>Computes:</p> <ul> <li><code>mean_time</code>  of shape (Nx, Ny, Nz, Nfreq)</li> <li><code>mean_seg</code> of shape (Nx, Ny, Nz, Nfreq)</li> <li><code>OAmean_time</code> of shape (Nx, Ny, Nz)</li> <li><code>OAmean_seg</code> of shape (Nx, Ny, Nz)</li> </ul> Source code in <code>src/prepost/spl.py</code> <pre><code>def compute_time_average(self):\n    \"\"\"\n    Compute AM from previoulsy computed spectrum or OASPL.\n\n    Computes:\n\n    - `mean_time`  of shape (Nx, Ny, Nz, Nfreq)\n    - `mean_seg` of shape (Nx, Ny, Nz, Nfreq)\n    - `OAmean_time` of shape (Nx, Ny, Nz)\n    - `OAmean_seg` of shape (Nx, Ny, Nz)\n    \"\"\"\n    print('computing time/beta average ...')\n    if self.SPL_time is not None:\n        self.mean_time = np.mean(self.SPL_time,4)\n    if self.SPL_seg is not None:\n        self.mean_seg = 10*np.log10(np.sum(10**(self.SPL_seg/10),(3,4,6))/self.Nbeta)\n        # self.mean_seg = np.mean(spl,4)\n    if self.OASPL_time is not None:\n        self.OAmean_time = 10*np.log10(np.mean(10**(self.OASPL_time/10),3))\n    if self.OASPL_seg is not None:\n        self.OAmean_seg = np.mean(self.OASPL_seg,3)\n    if self.OASPL_seg_tot is not None:\n        self.OAmean_seg = 10*np.log10(np.mean(10**(self.OASPL_seg_tot/10),3))\n    print('done.')\n</code></pre>"},{"location":"reference/spl.html#src.prepost.spl.SplField.plot_spl","title":"<code>plot_spl(time=True, OA=False, x=None, y=None, z=None, freq=None, it=None, roll=0, angle=False, **kwargs)</code>","text":"<p>Plots the SPL field.  if <code>x</code>, <code>y</code>, <code>z</code>, <code>freq</code>, <code>it</code> is set to <code>None</code> the plot is done in this direction.  Plots can be 1D (SPL\\((x)\\) or SPL\\((it)\\) for example) or 2D (SPL\\((x,y)\\) or SPL\\((freq,it)\\) for example) </p> <p>Parameters:</p> <ul> <li> <code>time</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Flag indicating if time data (True) or angular data (False) is plotted. Default is True.</p> </li> <li> <code>OA</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Flag indicating if the OASPL data (True) or frequency data (False) is plotted. Default is False.</p> </li> <li> <code>x</code>               (<code>float</code>, default:                   <code>None</code> )           \u2013            <p>The x-coordinate to plot the data. Default is None.</p> </li> <li> <code>y</code>               (<code>float</code>, default:                   <code>None</code> )           \u2013            <p>The y-coordinate to plot the data. Default is None.</p> </li> <li> <code>z</code>               (<code>float</code>, default:                   <code>None</code> )           \u2013            <p>The z-coordinate to plot the data. Default is None.</p> </li> <li> <code>freq</code>               (<code>float</code>, default:                   <code>None</code> )           \u2013            <p>The frequency to plot the data. Default is None.</p> </li> <li> <code>it</code>               (<code>int</code>, default:                   <code>None</code> )           \u2013            <p>The time index to plot the data. Default is None.</p> </li> <li> <code>roll</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>Allow to shift the SPL in time domain by several indices. Default is 0.</p> </li> <li> <code>angle</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Flag indicating if the angle data is plotted. Default is False.</p> </li> <li> <code>**kwargs</code>           \u2013            <p>Additional keyword arguments for plotting.</p> </li> </ul> Source code in <code>src/prepost/spl.py</code> <pre><code>def plot_spl(self, time=True, OA=False,\n             x: float = None, y: float = None, z: float = None,\n             freq: float = None, it: int = None,\n             roll=0, angle=False, **kwargs):\n\n    \"\"\"\n    Plots the SPL field. \n    if `x`, `y`, `z`, `freq`, `it` is set to `None` the plot is done in this direction. \n    Plots can be 1D (SPL$(x)$ or SPL$(it)$ for example) or 2D (SPL$(x,y)$ or SPL$(freq,it)$ for example) \n\n    Args:\n        time (bool, optional): Flag indicating if time data (True) or angular data (False) is plotted. Default is True.\n        OA (bool, optional): Flag indicating if the OASPL data (True) or frequency data (False) is plotted. Default is False.\n        x (float, optional): The x-coordinate to plot the data. Default is None.\n        y (float, optional): The y-coordinate to plot the data. Default is None.\n        z (float, optional): The z-coordinate to plot the data. Default is None.\n        freq (float, optional): The frequency to plot the data. Default is None.\n        it (int, optional): The time index to plot the data. Default is None.\n        roll (int, optional): Allow to shift the SPL in time domain by several indices. Default is 0.\n        angle (bool, optional): Flag indicating if the angle data is plotted. Default is False.\n        **kwargs: Additional keyword arguments for plotting.\n    \"\"\"\n\n    # choose Over all data or frequency data\n    # choose between beta data or time dat\n    test_dim = [x is None, y is None, z is None, freq is None, it is None]\n    beta = self.wt.beta.reshape(1, 1, 1, 1, self.wt.Nblade, self.wt.Nbeta)\n    self.time_src = beta[:, :, :, :, 0, :].reshape(-1)/self.wt.omega\n\n    if time:\n        absice = [self.x_grid[:, 0, 0], self.y_grid[0, :, 0],\n                  self.z_grid[0, 0, :], self.frequencies, self.time]\n        labels = ['x (m)', 'y (m)', 'z (m)', 'f (Hz)', 't (s)']\n        time_src = self.time\n    else:\n        test_dim = [x is None, y is None, z is None, freq is None, it is None]\n        beta = self.wt.beta.reshape(1, 1, 1, 1, self.wt.Nblade, self.wt.Nbeta)\n        beta = np.concatenate((beta, beta+2*np.pi/3, beta+4*np.pi/3), axis=5)\n        if angle:\n            time_src = beta[:, :, :, :, 0, :].reshape(-1)*180/np.pi\n        else:\n            time_src = beta[:, :, :, :, 0, :].reshape(-1)/self.wt.omega\n\n        absice = [self.x_grid[:, 0, 0],\n                  self.y_grid[0, :, 0], self.z_grid[0, 0, :],\n                  self.frequencies, time_src]\n        if angle:\n            labels = ['x (m)', 'y (m)', 'z (m)', 'f (Hz)', '$\\\\beta$ (deg)']\n        else:\n            labels = ['x (m)', 'y (m)', 'z (m)', 'f (Hz)', '$t$ (s)']\n    if OA:\n        test_dim[3] = False\n        if time:\n            # spl = np.roll(self.OASPL_time, roll,axis=-1)\n            spl = self.OASPL_time\n        else:\n            spl = self.OASPL_seg_tot\n    else:\n        if time:\n            # spl = np.roll(self.SPL_time,roll,axis=-1)\n            spl = self.SPL_time\n        else:\n            spl = 10*np.log10(np.sum(10**(self.SPL_seg/10),(3,4)))\n\n    # find coresponding freq, ix, iy, iz \n    if freq is not None:\n        ifreq = np.argmin(np.abs(self.frequencies-freq))\n        spl = spl[...,ifreq:ifreq+1,:]\n    if x is not None:\n        ix = np.argmin(np.abs(self.x_grid[:,0,0]-x))\n        print(ix)\n        spl = spl[ix:ix+1,...]\n    if y is not None :\n        iy = np.argmin(np.abs(self.y_grid[0,:,0]-y))\n        print(iy)\n        spl = spl[:,iy:iy+1,...]\n    if z is not None :\n        iz = np.nonzero(self.z_grid[0,0,:]==z)[0][0]\n        print(iz)\n        spl = spl[:,:,iz:iz+1,...]\n    if it is not None :\n        spl = spl[...,it]\n    spl = np.squeeze(spl)\n\n    # plot either pcolor or lineplot \n    if len(spl.shape) == 1:\n        print(\"plotting 1D spl\")\n        plt.plot(absice[np.where(test_dim)[0][0]], spl,**kwargs)\n        # plt.plot(spl,**kwargs)\n        plt.xlabel(labels[np.where(test_dim)[0][0]])\n        plt.ylabel('SPL (dB)')\n\n    if len(spl.shape) == 2:\n        print(\"plotting 2D spl\")\n        # if z is not None:\n        # if test dim == [1,1,0,0,0]:\n        #     absice = [self.x_grid[:, :, 0],\n        #           self.y_grid[:, :, 0], self.z_grid[0, 0, :],\n        #           self.frequencies,time_src]\n        # # if y is not None:\n        # if test dim == [1,0,1,0,0]:\n        #     absice = [self.x_grid[:, 0, :],\n        #               self.y_grid[:, 0, :], self.z_grid[:, 0, :],\n        #           self.frequencies,time_src]\n        # # if x is not None:\n        # if test dim == [0,1,1,0,0]:\n        #     absice = [self.x_grid[0, :, :],\n        #               self.y_grid[0, :, :], self.z_grid[0, :, :],\n        #           self.frequencies,time_src]\n        #absice = [self.x_grid[:, :, 0],\n        #          self.y_grid[:, :, 0], self.z_grid[0, 0, :],\n        #          self.frequencies, time_src]\n        #plt.pcolormesh(absice[np.where(test_dim)[0][0]],absice[np.where(test_dim)[0][1]],spl,**kwargs)\n\n\n        plt.pcolormesh(absice[np.where(test_dim)[0][0]],absice[np.where(test_dim)[0][1]],spl.T,**kwargs)\n        plt.xlabel(labels[np.where(test_dim)[0][0]])\n        plt.ylabel(labels[np.where(test_dim)[0][1]])\n    if len(spl.shape) == 3:\n        return\n</code></pre>"},{"location":"reference/spl.html#src.prepost.spl.SplField.plot_mean","title":"<code>plot_mean(time=True, OA=False, x=None, y=None, z=None, freq=None, **kwargs)</code>","text":"<p>Plots the time averaged SPL field.  if <code>x</code>, <code>y</code>, <code>z</code>, <code>freq</code> is set to <code>None</code> the plot is done in this direction.  Plots can be 1D (SPL\\((x)\\) or SPL\\((it)\\) for example) or 2D (SPL\\((x,y)\\) or SPL\\((freq,it)\\) for example) </p> <p>Parameters:</p> <ul> <li> <code>time</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Flag indicating if time data (True) or angular data (False) is plotted. Default is True.</p> </li> <li> <code>OA</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Flag indicating if the OASPL data (True) or frequency data (False) is plotted. Default is False.</p> </li> <li> <code>x</code>               (<code>float</code>, default:                   <code>None</code> )           \u2013            <p>The x-coordinate to plot the data. Default is None.</p> </li> <li> <code>y</code>               (<code>float</code>, default:                   <code>None</code> )           \u2013            <p>The y-coordinate to plot the data. Default is None.</p> </li> <li> <code>z</code>               (<code>float</code>, default:                   <code>None</code> )           \u2013            <p>The z-coordinate to plot the data. Default is None.</p> </li> <li> <code>freq</code>               (<code>float</code>, default:                   <code>None</code> )           \u2013            <p>The frequency to plot the data. Default is None.</p> </li> <li> <code>**kwargs</code>           \u2013            <p>Additional keyword arguments for plotting.</p> </li> </ul> Source code in <code>src/prepost/spl.py</code> <pre><code>def plot_mean(self, time: bool = True, OA: bool = False, x: float = None, y: float = None, z: float = None, freq: float = None, **kwargs):\n    \"\"\"\n    Plots the time averaged SPL field. \n    if `x`, `y`, `z`, `freq` is set to `None` the plot is done in this direction. \n    Plots can be 1D (SPL$(x)$ or SPL$(it)$ for example) or 2D (SPL$(x,y)$ or SPL$(freq,it)$ for example) \n\n    Args:\n        time (bool, optional): Flag indicating if time data (True) or angular data (False) is plotted. Default is True.\n        OA (bool, optional): Flag indicating if the OASPL data (True) or frequency data (False) is plotted. Default is False.\n        x (float, optional): The x-coordinate to plot the data. Default is None.\n        y (float, optional): The y-coordinate to plot the data. Default is None.\n        z (float, optional): The z-coordinate to plot the data. Default is None.\n        freq (float, optional): The frequency to plot the data. Default is None.\n        **kwargs: Additional keyword arguments for plotting.\n    \"\"\"\n    # choose Over all data or frequency data \n    # choose between beta data or time dat \n    test_dim = [x is None, y is None, z is None, freq is None] \n    absice = [self.x_grid[:,0,0],self.y_grid[0,:,0],self.z_grid[0,0,:],self.frequencies]\n    labels = ['x (m)', 'y (m)', 'z (m)', 'f (Hz)']\n    if OA:\n        test_dim[3] = False\n        if time:\n            mean = self.OAmean_time\n        else:\n            mean = self.OAmean_seg\n    else:\n        if time:\n            mean = self.mean_time\n        else:\n            mean = self.mean_seg\n\n    # find coresponding freq, ix, iy, iz \n    if freq is not None:\n        ifreq = np.argmin(np.abs(self.frequencies-freq))\n        mean = mean[...,ifreq:ifreq+1]\n    if x is not None:\n        ix = np.argmin(np.abs(self.x_grid[:,0,0]-x))\n        mean = mean[ix:ix+1,...]\n    if y is not None :\n        iy = np.argmin(np.abs(self.y_grid[0,:,0]-y))\n        mean = mean[:,iy:iy+1,...]\n    if z is not None :\n        iz = np.nonzero(self.z_grid[0,0,:]==z)[0][0]\n        mean = mean[:,:,iz:iz+1,...]\n    mean = np.squeeze(mean)\n\n    # plot either pcolor or lineplot \n    if len(mean.shape)==1:\n        plt.plot(absice[np.where(test_dim)[0][0]], mean,**kwargs)\n        plt.xlabel(labels[np.where(test_dim)[0][0]])\n        plt.ylabel('OASPL(dB)')\n\n        # if x is  None:\n        #     plt.plot(self.x_grid[:,0,0],mean,**kwargs)\n        # if y is  None:\n        #     plt.plot(self.y_grid[0,:,0],mean,**kwargs)\n        # if z is  None:\n        #     plt.plot(self.z_grid[0,0,:],mean,**kwargs)\n        # if freq is None:\n        #     plt.plot(self.frequencies,mean,**kwargs)\n\n    if len(mean.shape)==2:\n        # if z is not None:\n        #     absice = [self.x_grid[:, :, 0],\n        #           self.y_grid[:, :, 0], self.z_grid[0, 0, :],\n        #           self.frequencies]\n        # if y is not None:\n        #     absice = [self.x_grid[:, 0, :],\n        #               self.y_grid[:, 0, :], self.z_grid[:, 0, :],\n        #           self.frequencies]\n        # if x is not None:\n        #     absice = [self.x_grid[0, :, :],\n        #               self.y_grid[0, :, :], self.z_grid[0, :, :],\n        #           self.frequencies]\n        plt.pcolormesh(absice[np.where(test_dim)[0][0]],absice[np.where(test_dim)[0][1]],mean.T,**kwargs)\n        # plt.pcolormesh(absice[np.where(test_dim)[0][0]],absice[np.where(test_dim)[0][1]],mean,**kwargs)\n        plt.xlabel(labels[np.where(test_dim)[0][0]])\n        plt.ylabel(labels[np.where(test_dim)[0][1]])\n\n        #plt.gca().set_aspect('equal', adjustable='box')\n\n\n    if len(mean.shape)==3:\n        print(\"use anim function to plot 3D data field\")\n        return\n</code></pre>"},{"location":"reference/spl.html#src.prepost.spl.SplField.plot_am","title":"<code>plot_am(time=True, OA=False, x=None, y=None, z=None, freq=None, **kwargs)</code>","text":"<p>Plots the amplitude modulation field.  if <code>x</code>, <code>y</code>, <code>z</code>, <code>freq</code> is set to <code>None</code> the plot is done in this direction.  Plots can be 1D (AM\\((x)\\) or AM\\((freq)\\) for example) or 2D (AM\\((x,y)\\) or AM\\((x,freq)\\) for example) </p> <p>Parameters:</p> <ul> <li> <code>time</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Flag indicating if time data (True) or angular data (False) is plotted. Default is True.</p> </li> <li> <code>OA</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Flag indicating if the OASPL data (True) or frequency data (False) is plotted. Default is False.</p> </li> <li> <code>x</code>               (<code>float</code>, default:                   <code>None</code> )           \u2013            <p>The x-coordinate to plot the data. Default is None.</p> </li> <li> <code>y</code>               (<code>float</code>, default:                   <code>None</code> )           \u2013            <p>The y-coordinate to plot the data. Default is None.</p> </li> <li> <code>z</code>               (<code>float</code>, default:                   <code>None</code> )           \u2013            <p>The z-coordinate to plot the data. Default is None.</p> </li> <li> <code>freq</code>               (<code>float</code>, default:                   <code>None</code> )           \u2013            <p>The frequency to plot the data. Default is None.</p> </li> <li> <code>**kwargs</code>           \u2013            <p>Additional keyword arguments for plotting.</p> </li> </ul> Source code in <code>src/prepost/spl.py</code> <pre><code>def plot_am(self,time=True,OA=False,x:float=None,y:float=None,z:float=None,freq:float=None,**kwargs):\n    \"\"\"\n    Plots the amplitude modulation field. \n    if `x`, `y`, `z`, `freq` is set to `None` the plot is done in this direction. \n    Plots can be 1D (AM$(x)$ or AM$(freq)$ for example) or 2D (AM$(x,y)$ or AM$(x,freq)$ for example) \n\n    Args:\n        time (bool, optional): Flag indicating if time data (True) or angular data (False) is plotted. Default is True.\n        OA (bool, optional): Flag indicating if the OASPL data (True) or frequency data (False) is plotted. Default is False.\n        x (float, optional): The x-coordinate to plot the data. Default is None.\n        y (float, optional): The y-coordinate to plot the data. Default is None.\n        z (float, optional): The z-coordinate to plot the data. Default is None.\n        freq (float, optional): The frequency to plot the data. Default is None.\n        **kwargs: Additional keyword arguments for plotting.\n    \"\"\"\n    test_dim = [x is None, y is None, z is None, freq is None] \n    absice = [self.x_grid[:,0,0],self.y_grid[0,:,0],self.z_grid[0,0,:],self.frequencies]\n    labels = ['x (m)', 'y (m)', 'z (m)', 'f (Hz)']\n    if OA:\n        test_dim[3] = False\n        if time:\n            am = self.OAam_time\n        else:\n            am = self.OAam_seg\n    else :\n        if time:\n            am = self.am_time\n        else:\n            am = self.am_seg\n\n    if freq is not None:\n        ifreq = np.argmin(np.abs(self.frequencies-freq))\n        am = am[...,ifreq:ifreq+1]\n    if x is not None:\n        ix = np.argmin(np.abs(self.x_grid[:,0,0]-x))\n        am = am[ix:ix+1,...]\n    if y is not None :\n        iy = np.argmin(np.abs(self.y_grid[0,:,0]-y))\n        am = am[:,iy:iy+1,...]\n    if z is not None :\n        iz = np.nonzero(self.z_grid[0,0,:]==z)[0][0]\n        am = am[:,:,iz:iz+1,...]\n    am = np.squeeze(am)\n\n    if len(am.shape)==1:\n        plt.plot(absice[np.where(test_dim)[0][0]], am,**kwargs)\n        plt.xlabel(labels[np.where(test_dim)[0][0]])\n        plt.ylabel('am (dB)')\n\n    if len(am.shape)==2:\n        # absice = [self.x_grid[:, :, 0],\n        #           self.y_grid[:, :, 0], self.z_grid[0, 0, :],\n        #           self.frequencies]\n        plt.pcolormesh(absice[np.where(test_dim)[0][0]],absice[np.where(test_dim)[0][1]],am.T,**kwargs)\n        plt.xlabel(labels[np.where(test_dim)[0][0]])\n        plt.ylabel(labels[np.where(test_dim)[0][1]])\n        #plt.pcolormesh(absice[np.where(test_dim)[0][1]],absice[np.where(test_dim)[0][0]],am,**kwargs)\n        #plt.xlabel(labels[np.where(test_dim)[0][1]])\n        #plt.ylabel(labels[np.where(test_dim)[0][0]])\n        # plt.gca().set_aspect('equal', adjustable='box')\n\n    if len(am.shape)==3:\n        return \n</code></pre>"},{"location":"reference/spl.html#src.prepost.spl.SplField.anim_spl","title":"<code>anim_spl(time=True, OA=False, x=None, y=None, z=None, freq=None, **kwargs)</code>","text":"<p>Create an animation of the SPL field. if <code>x</code>, <code>y</code>, <code>z</code>, <code>freq</code>, <code>freq</code> is set to <code>None</code> the plot is done in this direction. Animation can be 1D (SPL\\((x,it)\\) or SPL\\((freq,it)\\) for example) or 2D (SPL\\((x,y,it)\\) or SPL\\((x,freq,it)\\) for example)</p> <p>Parameters:</p> <ul> <li> <code>time</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Flag indicating if time data (True) or angular data (False) is plotted. Default is True.</p> </li> <li> <code>OA</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Flag indicating if the OASPL data (True) or frequency data (False) is plotted. Default is False.</p> </li> <li> <code>x</code>               (<code>float</code>, default:                   <code>None</code> )           \u2013            <p>The x-coordinate to plot the data. Default is None.</p> </li> <li> <code>y</code>               (<code>float</code>, default:                   <code>None</code> )           \u2013            <p>The y-coordinate to plot the data. Default is None.</p> </li> <li> <code>z</code>               (<code>float</code>, default:                   <code>None</code> )           \u2013            <p>The z-coordinate to plot the data. Default is None.</p> </li> <li> <code>freq</code>               (<code>float</code>, default:                   <code>None</code> )           \u2013            <p>The frequency to plot the data. Default is None.</p> </li> <li> <code>**kwargs</code>           \u2013            <p>Additional keyword arguments for plotting.</p> </li> </ul> Source code in <code>src/prepost/spl.py</code> <pre><code>def anim_spl(self,time=True,OA=False,x:float=None,y:float=None,z:float=None,freq:float=None,**kwargs):\n    \"\"\"\n    Create an animation of the SPL field.\n    if `x`, `y`, `z`, `freq`, `freq` is set to `None` the plot is done in this direction.\n    Animation can be 1D (SPL$(x,it)$ or SPL$(freq,it)$ for example) or 2D (SPL$(x,y,it)$ or SPL$(x,freq,it)$ for example)\n\n    Args:\n        time (bool, optional): Flag indicating if time data (True) or angular data (False) is plotted. Default is True.\n        OA (bool, optional): Flag indicating if the OASPL data (True) or frequency data (False) is plotted. Default is False.\n        x (float, optional): The x-coordinate to plot the data. Default is None.\n        y (float, optional): The y-coordinate to plot the data. Default is None.\n        z (float, optional): The z-coordinate to plot the data. Default is None.\n        freq (float, optional): The frequency to plot the data. Default is None.\n        **kwargs: Additional keyword arguments for plotting.\n    \"\"\"\n    # choose Over all data or frequency data \n    # choose between beta data or time dat\n    test_dim = [x is None, y is None, z is None, freq is None] \n    absice = [self.x_grid[:,0,0],self.y_grid[0,:,0],self.z_grid[0,0,:],self.frequencies]\n    labels = ['x (m)', 'y (m)', 'z (m)', 'f (Hz)', 't (s)']\n\n    if OA:\n        test_dim[3] = False\n        if time:\n            spl = self.OASPL_time\n        else:\n            spl = self.OASPL_seg_tot\n    else:\n        if time:\n            spl = self.SPL_time\n        else:\n            spl = np.sum(10**(self.SPL_seg/10),(3,4))\n\n    if time:\n        nframes = self.Nt\n    else:\n        nframes = self.Nbeta\n\n    # find coresponding freq, ix, iy, iz \n    if freq is not None:\n        ifreq = np.argmin(np.abs(self.frequencies-freq))\n        spl = spl[...,ifreq:ifreq+1,:]\n    if x is not None:\n        ix = np.argmin(np.abs(self.x_grid[:,0,0]-x))\n        print(ix)\n        spl = spl[ix:ix+1,...]\n    if y is not None :\n        iy = np.argmin(np.abs(self.y_grid[0,:,0]-y))\n        print(iy)\n        spl = spl[:,iy:iy+1,...]\n    if z is not None :\n        iz = np.nonzero(self.z_grid[0,0,:]==z)[0][0]\n        print(iz)\n        spl = spl[:,:,iz:iz+1,...]\n    spl = np.squeeze(spl)\n\n    # plot either pcolor or lineplot \n    if len(spl.shape) == 2:\n        fig, ax = plt.subplots()\n        line, = ax.plot(absice[np.where(test_dim)[0][0]],spl[...,0].T,**kwargs)\n        plt.xlabel(labels[np.where(test_dim)[0][0]])\n        plt.ylabel('SPL (dB)')\n        def animate(ii):\n            line.set_ydata(spl[...,ii%nframes])\n            return line,\n        anim = FuncAnimation(fig, animate, frames=160, interval=30, repeat=True)\n        return anim\n\n    if len(spl.shape) == 3:\n        logging.info(\"2D animation ..\")\n        fig, ax = plt.subplots()\n        if z is not None:\n            absice2D = [self.x_grid[:,:,0], self.y_grid[:,:,0], self.z_grid[:,:,0], self.frequencies]\n        if x is not None:\n            absice2D = [self.x_grid[0,:,:], self.y_grid[0,:,:], self.z_grid[0,:,:], self.frequencies]\n        if y is not None:\n            absice2D = [self.x_grid[:,0,:], self.y_grid[:,0,:], self.z_grid[:,0,:], self.frequencies]\n        # absice2D = [self.x_grid[:,0,:], self.y_grid[:,0,:], self.z_grid[:,0,:], self.frequencies]\n\n        cax = ax.pcolormesh(absice2D[np.where(test_dim)[0][0]],absice2D[np.where(test_dim)[0][1]],spl[...,0],**kwargs)\n        # plt.gca().set_aspect('equal', adjustable='box')\n        plt.xlabel(labels[np.where(test_dim)[0][0]])\n        plt.ylabel(labels[np.where(test_dim)[0][1]])\n        # cax = ax.pcolormesh(absice[np.where(test_dim)[0][1]],absice[np.where(test_dim)[0][0]],spl[...,0],**kwargs)\n        # plt.gca().set_aspect('equal', adjustable='box')\n        # plt.xlabel(labels[np.where(test_dim)[0][1]])\n        # plt.ylabel(labels[np.where(test_dim)[0][0]])\n\n        # plt.gca().invert_yaxis()\n\n        divider = make_axes_locatable(ax)\n        cb = divider.append_axes(\"right\", size=\"5%\", pad=0.05)\n        cb.set_title('OASPL (dBA)')\n        plt.colorbar(cax, cax=cb)\n        plt.tight_layout()\n        def animate(ii):\n            # ax.clear()\n            cax.set_array(spl[...,ii%nframes])\n            plt.tight_layout()\n        anim = FuncAnimation(fig, animate, frames=nframes, interval=100, repeat=True)\n        return anim\n\n    if len(spl.shape)==4:\n        logging.warning('splwith 4 dimensions not allowed')\n        return \n</code></pre>"},{"location":"reference/spl_process.html","title":"Reference for <code>prepost/spl_process.py</code>","text":"<p>These functions are designed to process and analyze simulation data from wind turbine and especially wind farm noise.  They facilitate the concatenation, refinement, and interpolation of delta L fields for multiple turbines. Functions like <code>concatenate_angles_dl</code> and <code>concatenate_all_dl</code> are used to combine angle-specific data from multiple turbines, refine the angular resolution, and interpolate the results onto a common mesh. Other functions, such as <code>concatenate_side_dl</code> and <code>concatenate_planes_dl</code>,  are used for creating side views and plane-specific analyses. Additionally, <code>combine_dl_src</code> and <code>convert_to_receiver_time</code> integrate delta L fields with source fields and converts SPL as function of the rotor position into SPL as a function of receiver time. </p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p>"},{"location":"reference/spl_process.html#src.prepost.spl_process.concatenate_angles_dl","title":"<code>concatenate_angles_dl(casename, path2Pe, refine=2, nx=350, ny=320, iTurb=None, plot=False, dl_fname=None, spp_fname=None, spl_fname=None)</code>","text":"<p>Concatenates angles for delta L field from simulation results.</p> <p>This function reads simulation parameters, initializes the delta L field, and processes the data to concatenate angles. It optionally plots the results and saves the concatenated delta L field to a file. WARNING: this function is not used that much and <code>concatenate_all_dl</code> is the prefered method.  </p> <p>Parameters:</p> <ul> <li> <code>casename</code>               (<code>str</code>)           \u2013            <p>The name of the simulation case.</p> </li> <li> <code>path2Pe</code>               (<code>str</code>)           \u2013            <p>The path to the PE results.</p> </li> <li> <code>refine</code>               (<code>int</code>, default:                   <code>2</code> )           \u2013            <p>The number of refinement steps (artificially increase the number of propagation angle). Defaults to 2.</p> </li> <li> <code>nx</code>               (<code>int</code>, default:                   <code>350</code> )           \u2013            <p>The number of points in the x-direction for cartesian interpolation. Defaults to 350.</p> </li> <li> <code>ny</code>               (<code>int</code>, default:                   <code>320</code> )           \u2013            <p>The number of points in the y-direction for cartesian interpolation. Defaults to 320.</p> </li> <li> <code>iTurb</code>               (<code>ndarray</code>, default:                   <code>None</code> )           \u2013            <p>The indices of the turbines to process. Defaults to None.</p> </li> <li> <code>plot</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to plot the results. Defaults to False.</p> </li> <li> <code>dl_fname</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>The filename to save  the delta L field. Defaults to None.</p> </li> <li> <code>spp_fname</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>The filename to save the Spp field. Defaults to None.</p> </li> <li> <code>spl_fname</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>The filename to save the Spl field. Defaults to None.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>           \u2013            <p>None</p> </li> </ul> Source code in <code>src/prepost/spl_process.py</code> <pre><code>def concatenate_angles_dl(casename: str, path2Pe: str, refine: int = 2, nx: int = 350, ny: int = 320, iTurb: np.ndarray = None, plot: bool = False, dl_fname: str = None, spp_fname: str = None, spl_fname: str = None) -&gt; None:\n    \"\"\"\n    Concatenates angles for delta L field from simulation results.\n\n    This function reads simulation parameters, initializes the delta L field,\n    and processes the data to concatenate angles. It optionally plots the results\n    and saves the concatenated delta L field to a file.\n    WARNING: this function is not used that much and `concatenate_all_dl` is the prefered method.  \n\n    Args:\n        casename (str): The name of the simulation case.\n        path2Pe (str): The path to the PE results.\n        refine (int, optional): The number of refinement steps (artificially increase the number of propagation angle). Defaults to 2.\n        nx (int, optional): The number of points in the x-direction for cartesian interpolation. Defaults to 350.\n        ny (int, optional): The number of points in the y-direction for cartesian interpolation. Defaults to 320.\n        iTurb (np.ndarray, optional): The indices of the turbines to process. Defaults to None.\n        plot (bool, optional): Whether to plot the results. Defaults to False.\n        dl_fname (str, optional): The filename to save  the delta L field. Defaults to None.\n        spp_fname (str, optional): The filename to save the Spp field. Defaults to None.\n        spl_fname (str, optional): The filename to save the Spl field. Defaults to None.\n\n    Returns:\n        None\n    \"\"\"\n    print('Start concatenating angles ...')\n    if dl_fname is None :\n        dl_fname = 'DL'\n    if spp_fname is None:\n        spp_fname = 'Spp'\n    if spl_fname is None:\n        spl_fname = 'Spl'\n\n    # load simulation parameters\n    simu = Simu(casename)\n    simu.load(path2Pe+casename+'.dat')\n\n    if iTurb is None:\n        iTurb = np.arange(0,len(simu.tx))\n    # if not trubine index given loop over all turbines \n    for ii in iTurb:\n        #--------------------------------------------------------------\n        # create delta L field (read from Pe results)\n        deltaL = DeltaLField(path2Pe,casename)\n        for h in simu.heights:\n            for t in simu.tau:\n                logging.info(\"h,t= %s,%s\" % (h, t))\n                deltaL.read_receiver(ii,h,t,simu.distribute_tau)\n        flag = deltaL.check_compatibility()\n        if flag == -1:\n            logging.warning('error in check compatibility')\n            quit()\n\n        deltaL.concatenate_angles()\n        deltaL.loop_angle()\n        for kk in range(refine):\n            deltaL.refine_angle()\n\n        deltaL.shift_domain(simu.tx[ii]*simu.les.z_i,simu.ty[ii]*simu.les.z_i)\n        if plot:\n            deltaL.plotTopRaw(2,100,100)\n            plt.xlim(simu.x1,simu.x2)\n            plt.ylim(simu.y1,simu.y2)\n            plt.clim(-10,10)\n            plt.show()\n        deltaL.xS = simu.tx[ii]*simu.les.z_i\n        deltaL.yS = simu.ty[ii]*simu.les.z_i\n\n       # define common mesh \n        x = np.linspace(simu.x1,simu.x2,nx)\n        y = np.linspace(simu.y1,simu.y2,ny)\n\n        deltaL.interpolate_from_polar(x,y)\n\n        logging.info(\"saving delta L as :\" + dl_fname+str(ii)+'.dat')\n        deltaL.save(dl_fname+str(ii)+'.dat')\n\n        # reset fields\n        deltaL = None\n        spl = None\n        src = None\n    print('done.')\n</code></pre>"},{"location":"reference/spl_process.html#src.prepost.spl_process.init_deltaL_field","title":"<code>init_deltaL_field(path2Pe, casename, simu, iTurb)</code>","text":"<p>Initializes the delta L field for a given turbine.</p> <p>This function sets up the delta L field with the necessary parameters and dimensions based on the simulation data <code>Simu</code>.</p> <p>Parameters:</p> <ul> <li> <code>path2Pe</code>               (<code>str</code>)           \u2013            <p>The path to the Pe results.</p> </li> <li> <code>casename</code>               (<code>str</code>)           \u2013            <p>The name of the simulation case.</p> </li> <li> <code>simu</code>               (<code>Simu</code>)           \u2013            <p>The simulation object containing parameters.</p> </li> <li> <code>iTurb</code>               (<code>int</code>)           \u2013            <p>The index of the turbine.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>DeltaLField</code> (              <code>DeltaLField</code> )          \u2013            <p>The initialized delta L field.</p> </li> </ul> Source code in <code>src/prepost/spl_process.py</code> <pre><code>def init_deltaL_field(\n    path2Pe: str,\n    casename: str,\n    simu: Simu,\n    iTurb: int\n) -&gt; DeltaLField:\n    \"\"\"\n    Initializes the delta L field for a given turbine.\n\n    This function sets up the delta L field with the necessary parameters and\n    dimensions based on the simulation data `Simu`.\n\n    Args:\n        path2Pe (str): The path to the Pe results.\n        casename (str): The name of the simulation case.\n        simu (Simu): The simulation object containing parameters.\n        iTurb (int): The index of the turbine.\n\n    Returns:\n        DeltaLField: The initialized delta L field.\n    \"\"\"\n    deltaL = DeltaLField(path2Pe,casename)\n\n    Lx1 = simu.x2-simu.tx[iTurb]*simu.les.z_i\n    Lx2 = simu.tx[iTurb]*simu.les.z_i - simu.x1 \n    Ly1 = simu.y2 - simu.ty[iTurb]*simu.les.z_i\n    Ly2 = simu.ty[iTurb]*simu.les.z_i - simu.y1\n\n    xmax = np.sqrt(max(Lx1,Lx2)**2 + max(Ly1,Ly2)**2) + 50\n    dx = simu.inputs[\"dout\"]\n    deltaL.x = np.arange(0, xmax + dx , dx)\n    deltaL.nx = np.size(deltaL.x)\n\n    deltaL.ntau = simu.tau.size\n    deltaL.tau = simu.tau\n    deltaL.height = np.array(simu.heights)\n    deltaL.nheight = len(simu.heights)\n\n    deltaL.nz = simu.inputs[\"nb_receiver\"]\n    deltaL.z =  np.array(simu.inputs[\"heights(1)\"])\n\n    deltaL.Nfreq = simu.frequencies.size\n    deltaL.frequencies = simu.frequencies\n\n    # create matrice for deltaL polar \n    deltaL.deltaL_polar = np.zeros(\n        (deltaL.nx, deltaL.nz, deltaL.ntau, deltaL.Nfreq, deltaL.nheight)\n    )\n    return deltaL\n</code></pre>"},{"location":"reference/spl_process.html#src.prepost.spl_process.add_1Pe_to_deltaL_field","title":"<code>add_1Pe_to_deltaL_field(deltaL, iTurb, height, tau)</code>","text":"<p>Adds Pe results to the delta L field for a given turbine, height, and tau.</p> <p>This function reads the receiver data from the Pe results and updates the <code>deltaL_polar</code> field accordingly.</p> <p>Parameters:</p> <ul> <li> <code>deltaL</code>               (<code>DeltaLField</code>)           \u2013            <p>The delta L field object.</p> </li> <li> <code>iTurb</code>               (<code>int</code>)           \u2013            <p>The index of the turbine.</p> </li> <li> <code>height</code>               (<code>float</code>)           \u2013            <p>The height at which to add the Pe results.</p> </li> <li> <code>tau</code>               (<code>float</code>)           \u2013            <p>The tau value at which to add the Pe results.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>           \u2013            <p>None</p> </li> </ul> Source code in <code>src/prepost/spl_process.py</code> <pre><code>def add_1Pe_to_deltaL_field(\n    deltaL: DeltaLField,\n    iTurb: int,\n    height: float,\n    tau: float\n) -&gt; None:\n    \"\"\"\n    Adds Pe results to the delta L field for a given turbine, height, and tau.\n\n    This function reads the receiver data from the Pe results and updates the\n    `deltaL_polar` field accordingly.\n\n    Args:\n        deltaL (DeltaLField): The delta L field object.\n        iTurb (int): The index of the turbine.\n        height (float): The height at which to add the Pe results.\n        tau (float): The tau value at which to add the Pe results.\n\n    Returns:\n        None\n    \"\"\"\n    res = PeResults(\n                deltaL.casename,\n                iTurb,\n                height,\n                tau,\n                dirname=deltaL.dirname,\n                distribute_tau=deltaL.simu.distribute_tau,\n            )\n\n    fname = deltaL.fname(iTurb, tau, height, deltaL.simu.distribute_tau)\n    res.read_receiver(fname)\n    # find height and tau index of the simulation\n    if (res.frequencies!=deltaL.simu.frequencies).any():\n        logging.warning(\"frequencies not the same\")\n    if (res.heights!=deltaL.z).any():\n        logging.warning(\"heights not the same\")\n\n    iheight = np.argmin(abs(deltaL.height - height))\n    itau = np.argmin(abs(deltaL.tau - tau))\n    # find corresponding index\n    ixmin = np.argmin(abs(deltaL.x - res.x[0]))\n    ixmax = np.argmin(abs(deltaL.x - res.x[-1]))\n    logging.info(\"height = \" + str(height) + \", tau = \" + str(tau))\n    deltaL.deltaL_polar[ixmin : ixmax + 1, :, itau, :, iheight] = res.receiver\n    # copy last values\n    deltaL.deltaL_polar[ixmax+1:, :, itau, :, iheight] = deltaL.deltaL_polar[ixmax, :, itau, :, iheight][None,:,:,]\n</code></pre>"},{"location":"reference/spl_process.html#src.prepost.spl_process.concatenate_angles","title":"<code>concatenate_angles(casename, path2Pe, simu, iTurb, refine, z=None, stepx=None)</code>","text":"<p>Concatenates angles for the delta L field for a given turbine.</p> <p>This function initializes the delta L field, adds Pe results, and processes the data to concatenate angles. It optionally refines the angles and selects a specific height from the receiver heights. It can also increase the grid size in the radius direction.</p> <p>Parameters:</p> <ul> <li> <code>casename</code>               (<code>str</code>)           \u2013            <p>The name of the simulation case.</p> </li> <li> <code>path2Pe</code>               (<code>str</code>)           \u2013            <p>The path to the Pe results.</p> </li> <li> <code>simu</code>               (<code>Simu</code>)           \u2013            <p>The simulation object containing parameters.</p> </li> <li> <code>iTurb</code>               (<code>int</code>)           \u2013            <p>The index of the turbine.</p> </li> <li> <code>refine</code>               (<code>int</code>)           \u2013            <p>The number of refinement steps.</p> </li> <li> <code>z</code>               (<code>float</code>, default:                   <code>None</code> )           \u2013            <p>The height to select. Defaults to None.</p> </li> <li> <code>stepx</code>               (<code>int</code>, default:                   <code>None</code> )           \u2013            <p>The step size for refinement. Defaults to None.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>DeltaLField</code> (              <code>DeltaLField</code> )          \u2013            <p>The concatenated delta L field.</p> </li> </ul> Source code in <code>src/prepost/spl_process.py</code> <pre><code>def concatenate_angles(\n    casename: str,\n    path2Pe: str,\n    simu: Simu,\n    iTurb: int,\n    refine: int,\n    z: float = None,\n    stepx: int = None\n) -&gt; DeltaLField:\n    \"\"\"\n    Concatenates angles for the delta L field for a given turbine.\n\n    This function initializes the delta L field, adds Pe results, and processes\n    the data to concatenate angles. It optionally refines the angles and selects\n    a specific height from the receiver heights. It can also increase the grid size in the radius direction.\n\n    Args:\n        casename (str): The name of the simulation case.\n        path2Pe (str): The path to the Pe results.\n        simu (Simu): The simulation object containing parameters.\n        iTurb (int): The index of the turbine.\n        refine (int): The number of refinement steps.\n        z (float, optional): The height to select. Defaults to None.\n        stepx (int, optional): The step size for refinement. Defaults to None.\n\n    Returns:\n        DeltaLField: The concatenated delta L field.\n    \"\"\"\n    # create delta L field (read from Pe results)\n    deltaL = init_deltaL_field(path2Pe, casename, simu, iTurb)\n\n    for h in simu.heights:\n        for t in simu.tau:\n            add_1Pe_to_deltaL_field(deltaL, iTurb, h, t)\n\n    deltaL.loop_angle()\n    # create polar mesh\n    angles = np.reshape(deltaL.tau * np.pi / 180, (1, -1))\n    r = np.reshape(deltaL.x, (-1, 1))\n\n    deltaL.x_polar = r * np.cos(angles)\n    deltaL.y_polar = r * np.sin(angles)\n    deltaL.z_polar = deltaL.z\n\n    # select one heights \n    if z is not None:\n        if z in deltaL.z:\n            iz = np.where(z==deltaL.z)[0][0]\n        else:\n            logging.warning(\"z is not in deltaL.z\")\n\n        deltaL.z_polar = deltaL.z_polar[iz:iz+1]\n        deltaL.deltaL_polar = deltaL.deltaL_polar[:,iz:iz+1,...]\n\n    if stepx is not None:\n        deltaL.deltaL_polar = deltaL.deltaL_polar[::stepx, ...]\n        deltaL.x_polar = deltaL.x_polar[::stepx, ...]\n        deltaL.x = deltaL.x[::stepx]\n        deltaL.y_polar = deltaL.y_polar[::stepx, ...]\n\n    deltaL.nx = deltaL.x_polar.shape[0]\n    deltaL.ntau = deltaL.x_polar.shape[1]\n    deltaL.nz = deltaL.z_polar.shape[0]\n\n    # refine angles (linera interpolation)\n    for kk in range(refine):\n        deltaL.refine_angle()\n\n    deltaL.nx = deltaL.x_polar.shape[0]\n    deltaL.ntau = deltaL.x_polar.shape[1]\n    deltaL.nz = deltaL.z_polar.shape[0]\n\n\n    deltaL.shift_domain(simu.tx[iTurb]*simu.les.z_i,simu.ty[iTurb]*simu.les.z_i)\n    deltaL.xS = simu.tx[iTurb]*simu.les.z_i\n    deltaL.yS = simu.ty[iTurb]*simu.les.z_i\n    return deltaL \n</code></pre>"},{"location":"reference/spl_process.html#src.prepost.spl_process.concatenate_all_dl","title":"<code>concatenate_all_dl(casename, path2Pe, refine=2, z=None, nx=None, ny=None, stepx=None, iTurb=None, plot=False, dl_fname=None, spp_fname=None, spl_fname=None)</code>","text":"<p>Concatenates all delta L fields for all turbines.</p> <p>This function processes the delta L fields for all turbines, optionally refines the angles, and saves the concatenated delta L fields into different files.</p> <p>Parameters:</p> <ul> <li> <code>casename</code>               (<code>str</code>)           \u2013            <p>The name of the simulation case.</p> </li> <li> <code>path2Pe</code>               (<code>str</code>)           \u2013            <p>The path to the Pe results.</p> </li> <li> <code>refine</code>               (<code>int</code>, default:                   <code>2</code> )           \u2013            <p>The number of refinement steps. Defaults to 2.</p> </li> <li> <code>z</code>               (<code>float</code>, default:                   <code>None</code> )           \u2013            <p>The receiver height to select. Defaults to None.</p> </li> <li> <code>nx</code>               (<code>int</code>, default:                   <code>None</code> )           \u2013            <p>The number of points in the x-direction for cartesian interpolation. Defaults to None.</p> </li> <li> <code>ny</code>               (<code>int</code>, default:                   <code>None</code> )           \u2013            <p>The number of points in the y-direction for cartesian interpolation. Defaults to None.</p> </li> <li> <code>stepx</code>               (<code>int</code>, default:                   <code>None</code> )           \u2013            <p>The step size for a coarser grid in the radius direction. Defaults to None.</p> </li> <li> <code>iTurb</code>               (<code>ndarray</code>, default:                   <code>None</code> )           \u2013            <p>The indices of the turbines to process. Defaults to None.</p> </li> <li> <code>plot</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to plot the results. Defaults to False.</p> </li> <li> <code>dl_fname</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>The filename to save the delta L field. Defaults to None.</p> </li> <li> <code>spp_fname</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>The filename to save the Spp field. Defaults to None.</p> </li> <li> <code>spl_fname</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>The filename to save the Spl field. Defaults to None.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>           \u2013            <p>None</p> </li> </ul> Source code in <code>src/prepost/spl_process.py</code> <pre><code>def concatenate_all_dl(\n    casename: str,\n    path2Pe: str,\n    refine: int = 2,\n    z: float = None,\n    nx: int = None,\n    ny: int = None,\n    stepx: int = None,\n    iTurb: np.ndarray = None,\n    plot: bool = False,\n    dl_fname: str = None,\n    spp_fname: str = None,\n    spl_fname: str = None\n) -&gt; None:\n    \"\"\"\n    Concatenates all delta L fields for all turbines.\n\n    This function processes the delta L fields for all turbines, optionally\n    refines the angles, and saves the concatenated delta L fields into different files.\n\n    Args:\n        casename (str): The name of the simulation case.\n        path2Pe (str): The path to the Pe results.\n        refine (int, optional): The number of refinement steps. Defaults to 2.\n        z (float, optional): The receiver height to select. Defaults to None.\n        nx (int, optional): The number of points in the x-direction for cartesian interpolation. Defaults to None.\n        ny (int, optional): The number of points in the y-direction for cartesian interpolation. Defaults to None.\n        stepx (int, optional): The step size for a coarser grid in the radius direction. Defaults to None.\n        iTurb (np.ndarray, optional): The indices of the turbines to process. Defaults to None.\n        plot (bool, optional): Whether to plot the results. Defaults to False.\n        dl_fname (str, optional): The filename to save the delta L field. Defaults to None.\n        spp_fname (str, optional): The filename to save the Spp field. Defaults to None.\n        spl_fname (str, optional): The filename to save the Spl field. Defaults to None.\n\n    Returns:\n        None\n    \"\"\"\n    print('Start concatenating angles ...')\n    if dl_fname is None :\n        dl_fname = 'DL'\n    if spp_fname is None:\n        spp_fname = 'Spp'\n    if spl_fname is None:\n        spl_fname = 'Spl'\n\n    # load simulation parameters\n    simu = Simu(casename)\n    simu.load(path2Pe+casename+'.dat')\n\n    if iTurb is None:\n        iTurb = np.arange(0,len(simu.tx))\n    # if not trubine index given loop over all turbines \n    for ii in iTurb:\n        deltaL = concatenate_angles(simu.casename,path2Pe,simu, ii, refine, z, stepx)\n        if nx is None or ny is None:\n            logging.info(\"saving delta L polar shape as :\" + dl_fname+str(ii)+'.dat')\n            print(deltaL.x_polar.shape)\n            print(deltaL.z_polar.shape)\n\n            deltaL.x_cart = np.meshgrid(deltaL.x_polar.flatten(),\n                                         deltaL.z_polar,\n                                         indexing='ij')[0].reshape(deltaL.nx,deltaL.ntau,deltaL.nz)\n            deltaL.y_cart = np.meshgrid(deltaL.y_polar.flatten(),\n                                         deltaL.z_polar,\n                                         indexing='ij')[0].reshape(deltaL.nx,deltaL.ntau,deltaL.nz)\n            deltaL.z_cart = np.meshgrid(deltaL.y_polar.flatten(),\n                                         deltaL.z_polar,\n                                         indexing='ij')[1].reshape(deltaL.nx, deltaL.ntau,deltaL.nz)\n            deltaL.deltaL_cart = np.transpose(deltaL.deltaL_polar,(0,2,1,3,4))\n            deltaL.x_array = deltaL.x_cart[:,0]\n            deltaL.y_array = deltaL.y_cart[0,:]\n            deltaL.z_array = deltaL.z_polar\n            deltaL.x_polar = None\n            deltaL.y_polar = None\n            deltaL.deltaL_polar = None\n            deltaL.deltaLlist = []\n            deltaL.save(dl_fname+str(ii)+'.dat')\n        else:\n            # define common mesh  for interpolation from simu\n            x = np.linspace(simu.x1,simu.x2,nx)\n            y = np.linspace(simu.y1,simu.y2,ny)\n\n            deltaL.interpolate_from_polar(x,y)\n\n            logging.info(\"saving delta L cartesian shape as :\" + dl_fname+str(ii)+'.dat')\n            deltaL.x_polar = None\n            deltaL.y_polar = None\n            deltaL.deltaL_polar = None\n            deltaL.deltaLlist = []\n            deltaL.save(dl_fname+str(ii)+'.dat')\n\n        # reset fields\n        deltaL = None\n        spl = None\n        src = None\n    print('done.')\n</code></pre>"},{"location":"reference/spl_process.html#src.prepost.spl_process.concatenate_side_dl","title":"<code>concatenate_side_dl(casename, path2Pe, iTurb=None, tau=[0, 180], nx=None, nz=None, dl_fname=None, spp_fname=None, spl_fname=None)</code>","text":"<p>Concatenates side views of the delta L field for all turbines.</p> <p>This function processes the delta L fields to create side views and saves the results to files.</p> <p>Parameters:</p> <ul> <li> <code>casename</code>               (<code>str</code>)           \u2013            <p>The name of the simulation case.</p> </li> <li> <code>path2Pe</code>               (<code>str</code>)           \u2013            <p>The path to the Pe results.</p> </li> <li> <code>iTurb</code>               (<code>ndarray</code>, default:                   <code>None</code> )           \u2013            <p>The indices of the turbines to process. Defaults to None.</p> </li> <li> <code>tau</code>               (<code>list</code>, default:                   <code>[0, 180]</code> )           \u2013            <p>The tau values to process. Defaults to [0, 180].</p> </li> <li> <code>nx</code>               (<code>int</code>, default:                   <code>None</code> )           \u2013            <p>The number of points in the x-direction. Defaults to None.</p> </li> <li> <code>nz</code>               (<code>int</code>, default:                   <code>None</code> )           \u2013            <p>The number of points in the z-direction. Defaults to None.</p> </li> <li> <code>dl_fname</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>The filename for the delta L field. Defaults to None.</p> </li> <li> <code>spp_fname</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>The filename for the Spp field. Defaults to None.</p> </li> <li> <code>spl_fname</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>The filename for the Spl field. Defaults to None.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>           \u2013            <p>None</p> </li> </ul> Source code in <code>src/prepost/spl_process.py</code> <pre><code>def concatenate_side_dl(\n    casename: str,\n    path2Pe: str,\n    iTurb: np.ndarray = None,\n    tau: list = [0, 180],\n    nx: int = None,\n    nz: int = None,\n    dl_fname: str = None,\n    spp_fname: str = None,\n    spl_fname: str = None\n) -&gt; None:\n    \"\"\"\n    Concatenates side views of the delta L field for all turbines.\n\n    This function processes the delta L fields to create side views and saves\n    the results to files.\n\n    Args:\n        casename (str): The name of the simulation case.\n        path2Pe (str): The path to the Pe results.\n        iTurb (np.ndarray, optional): The indices of the turbines to process. Defaults to None.\n        tau (list, optional): The tau values to process. Defaults to [0, 180].\n        nx (int, optional): The number of points in the x-direction. Defaults to None.\n        nz (int, optional): The number of points in the z-direction. Defaults to None.\n        dl_fname (str, optional): The filename for the delta L field. Defaults to None.\n        spp_fname (str, optional): The filename for the Spp field. Defaults to None.\n        spl_fname (str, optional): The filename for the Spl field. Defaults to None.\n\n    Returns:\n        None\n    \"\"\"\n    simu = Simu(casename)\n    print('Start concatenating side view...')\n    if dl_fname is None :\n        dl_fname = './xz/DL'\n    if spp_fname is None:\n        spp_fname = './xz/Spp'\n    if spl_fname is None:\n        spl_fname = './xz/Spl'\n    if iTurb is None:\n        iTurb = np.arange(0,len(simu.tx))\n\n    # load simulation parameters\n    simu = Simu(casename)\n    simu.load(path2Pe+casename+'.dat')\n    for ii in iTurb:\n        #--------------------------------------------------------------\n        # create delta L field (read from Pe results)\n        deltaL = DeltaLField(path2Pe, casename)\n        deltaL.create_side_view(ii, tau)\n\n        deltaL.shift_domain(simu.tx[ii]*simu.les.z_i,simu.ty[ii]*simu.les.z_i)\n\n        deltaL.xS = simu.tx[ii]*simu.les.z_i\n        deltaL.yS = simu.ty[ii]*simu.les.z_i\n\n        # interpolate on coarse grid\n        if (nx is not None) and (nz is not None):\n            x = np.linspace(simu.x1, simu.x2, nx)\n            z = np.linspace(0, simu.h, nz)\n            deltaL.interpolate_xz(x, z)\n\n        deltaL.save(dl_fname+str(ii)+'.dat')\n\n        # reset fields\n        deltaL = None\n    print('done.')\n</code></pre>"},{"location":"reference/spl_process.html#src.prepost.spl_process.combine_dl_src","title":"<code>combine_dl_src(casename, path2Pe, iTurb=None, dl_fname=None, spp_fname=None, spl_fname=None, polar=False, third=True, free_field=False)</code>","text":"<p>Combines the delta L field with the source field for all turbines.</p> <p>This function processes the delta L and source fields, combines them, and saves the results to files. The field must be in cartesian coordinate system bu the matrix shape can be polar. If the size of the grid dont match the source results are interpolated on the delta L results grid.</p> <p>Parameters:</p> <ul> <li> <code>casename</code>               (<code>str</code>)           \u2013            <p>The name of the simulation case.</p> </li> <li> <code>path2Pe</code>               (<code>str</code>)           \u2013            <p>The path to the Pe results.</p> </li> <li> <code>iTurb</code>               (<code>ndarray</code>, default:                   <code>None</code> )           \u2013            <p>The indices of the turbines to process. Defaults to None.</p> </li> <li> <code>dl_fname</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>The filename for the delta L field. Defaults to None.</p> </li> <li> <code>spp_fname</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>The filename for the Spp field. Defaults to None.</p> </li> <li> <code>spl_fname</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>The filename for the Spl field. Defaults to None.</p> </li> <li> <code>polar</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to use polar coordinates. Defaults to False.</p> </li> <li> <code>third</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to compute SPL in third octave bands before saving (reduce the size of files). Defaults to True.</p> </li> <li> <code>free_field</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to consider free field conditions. Defaults to False.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>           \u2013            <p>None</p> </li> </ul> Source code in <code>src/prepost/spl_process.py</code> <pre><code>def combine_dl_src(\n    casename: str,\n    path2Pe: str,\n    iTurb: np.ndarray = None,\n    dl_fname: str = None,\n    spp_fname: str = None,\n    spl_fname: str = None,\n    polar: bool = False,\n    third: bool = True,\n    free_field: bool = False\n) -&gt; None:\n    \"\"\"\n    Combines the delta L field with the source field for all turbines.\n\n    This function processes the delta L and source fields, combines them, and\n    saves the results to files.\n    The field must be in cartesian coordinate system bu the matrix shape can be polar.\n    If the size of the grid dont match the source results are interpolated on the delta L results grid.\n\n\n    Args:\n        casename (str): The name of the simulation case.\n        path2Pe (str): The path to the Pe results.\n        iTurb (np.ndarray, optional): The indices of the turbines to process. Defaults to None.\n        dl_fname (str, optional): The filename for the delta L field. Defaults to None.\n        spp_fname (str, optional): The filename for the Spp field. Defaults to None.\n        spl_fname (str, optional): The filename for the Spl field. Defaults to None.\n        polar (bool, optional): Whether to use polar coordinates. Defaults to False.\n        third (bool, optional): Whether to compute SPL in third octave bands before saving (reduce the size of files). Defaults to True.\n        free_field (bool, optional): Whether to consider free field conditions. Defaults to False.\n\n    Returns:\n        None\n    \"\"\"\n\n    print('Start combining DeltaL and Spp...')\n    if dl_fname is None :\n        dl_fname = './xz/DL'\n    if spp_fname is None:\n        spp_fname = './xz/Spp'\n    if spl_fname is None:\n        spl_fname = './xz/Spl'\n\n    # load simulation parameters \n    simu = Simu(casename)\n    simu.load(path2Pe+casename+'.dat')\n\n    # compute spl for gievn wind turbin\n    if iTurb is None:\n        iTurb = np.arange(0,len(simu.tx))\n\n    for ii in iTurb:\n        #-----------------------------------------------------------------\n        # create delta L field (read from Pe results)\n        deltaL = DeltaLField(path2Pe,casename)\n\n        # loadDelta L field\n        deltaL.load(dl_fname+str(ii)+'.dat')\n\n        # read source file\n        #-----------------------------------------------------------------\n        src = Source()\n        src.load(spp_fname+str(ii)+'.dat')\n\n        # deltaL.deltaL_cart = np.transpose(deltaL.deltaL_polar, (0,2,1,3,4))\n\n        # if deltaL.x_cart is None:\n        #     print(\"interpolating Spp to polar \")\n        #     if src.mesh.x_coord.size != deltaL.x_polar[:,:].size:\n        #         src.interpolate_xy(deltaL.x_polar[:, : ], deltaL.y_polar[:, :])\n        if src.mesh.y_array.size != deltaL.x_cart.shape[1]:\n            src.interpolate_xy(deltaL.x_cart[:, :, 0], deltaL.y_cart[:, :, 0])\n        elif src.mesh.z_array.size != deltaL.z_cart.shape[2]:\n            src.interpolate_xz(deltaL.x_cart[:, 0, 0], deltaL.z_cart[0, 0, :])\n\n        # create spl field\n        #-----------------------------------------------------------------\n        spl = SplField(src,deltaL)\n        if polar:\n            flag = spl.check_compatibility_polar()\n        else:\n            flag = spl.check_compatibility_cart()\n        if flag == -1:\n            return flag\n        spl.src.wt.tau = 0\n\n        # combine Delta L spp\n        print(deltaL.height)\n        spl.combine_linear_broadband(free_field=free_field)\n\n        if third:\n            fc = [50, 63, 80, 100, 125, 160, 200, 250, 315, 400, 500, 630, 800, 1000]\n            Nfc = [1,  1,  1,   1,   1,  1,   2,   2,   3,   4,   4,   4,   5,  5]\n            spl.compute_third_octave(fc, Nfc)\n        spl.atm_absorption()\n        spl.save(spl_fname+str(ii)+'.dat')\n\n        # reset fields\n        deltaL = None\n        spl = None\n        src = None\n</code></pre>"},{"location":"reference/spl_process.html#src.prepost.spl_process.convert_to_receiver_time","title":"<code>convert_to_receiver_time(casename, path2Pe, iTurb=None, spl_fname=None, oaspl=False, spl_fname_out=None, **kwargs)</code>","text":"<p>Converts the SPL field to receiver time for all turbines.</p> <p>Parameters:</p> <ul> <li> <code>casename</code>               (<code>str</code>)           \u2013            <p>The name of the simulation case.</p> </li> <li> <code>path2Pe</code>               (<code>str</code>)           \u2013            <p>The path to the Pe results.</p> </li> <li> <code>iTurb</code>               (<code>ndarray</code>, default:                   <code>None</code> )           \u2013            <p>The indices of the turbines to process. Defaults to None.</p> </li> <li> <code>spl_fname</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>The filename for the SPL field. Defaults to None.</p> </li> <li> <code>oaspl</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to load OASPL data. Defaults to False.</p> </li> <li> <code>spl_fname_out</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>The output filename for the SPL field. Defaults to None.</p> </li> <li> <code>**kwargs</code>           \u2013            <p>Additional keyword arguments.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>           \u2013            <p>None</p> </li> </ul> Source code in <code>src/prepost/spl_process.py</code> <pre><code>def convert_to_receiver_time(\n    casename: str,\n    path2Pe: str,\n    iTurb: np.ndarray = None,\n    spl_fname: str = None,\n    oaspl: bool = False,\n    spl_fname_out: str = None,\n    **kwargs\n) -&gt; None:\n    \"\"\"\n    Converts the SPL field to receiver time for all turbines.\n\n    Args:\n        casename (str): The name of the simulation case.\n        path2Pe (str): The path to the Pe results.\n        iTurb (np.ndarray, optional): The indices of the turbines to process. Defaults to None.\n        spl_fname (str, optional): The filename for the SPL field. Defaults to None.\n        oaspl (bool, optional): Whether to load OASPL data. Defaults to False.\n        spl_fname_out (str, optional): The output filename for the SPL field. Defaults to None.\n        **kwargs: Additional keyword arguments.\n\n    Returns:\n        None\n    \"\"\"\n    if spl_fname is None:\n        spl_fname = 'Spl'\n\n    # load simulation parameters\n    simu = Simu(casename)\n    simu.load(path2Pe+casename+'.dat')\n    if iTurb is None:\n        iTurb = np.arange(0, len(simu.tx))\n\n    for ii in iTurb:\n        # -----------------------------------------------------------------\n        # create spl field\n        # -----------------------------------------------------------------\n        spl = SplField()\n        if oaspl:\n            spl.load(spl_fname+str(ii)+'.dat',seg=False,time=False,oaspl=True)\n        else:\n            spl.load(spl_fname+str(ii)+'.dat',seg=True,time=False,oaspl=False)\n\n        spl.info()\n\n        # Receiver Time computation\n        # -----------------------------------------------------------------\n        # compute Spl at receiver time\n        spl.create_full_rotation()\n        # compute source/receiver time matrix\n        spl.compute_real_receiver_time(last=True, loop=True)\n        # create time solution from angle\n        spl.angle_to_time_3_full(dt=0.1)\n        # save spl  in file\n        spl.clean_full_rotation()\n        if spl_fname_out is not None:\n            spl.SPL_seg = None\n            spl.OASPL_seg = None\n            spl.save(spl_fname_out+str(ii)+'.dat')\n        else:\n            spl.save(spl_fname+str(ii)+'.dat')\n        # reset fields\n        spl = None\n</code></pre>"},{"location":"reference/spl_process.html#src.prepost.spl_process.concatenate_planes_dl","title":"<code>concatenate_planes_dl(casename, path2Pe, nx=350, ny=320, iTurb=None, xplane=None, yplane=None, dl_fname=None)</code>","text":"<p>This function processes the delta L field to concatenate planes and saves the results to files. WARNING: this was not used a lot and it may be a bit broken. </p> <p>Parameters:</p> <ul> <li> <code>casename</code>               (<code>str</code>)           \u2013            <p>The name of the simulation case.</p> </li> <li> <code>path2Pe</code>               (<code>str</code>)           \u2013            <p>The path to the Pe results.</p> </li> <li> <code>nx</code>               (<code>int</code>, default:                   <code>350</code> )           \u2013            <p>The number of points in the x-direction. Defaults to 350.</p> </li> <li> <code>ny</code>               (<code>int</code>, default:                   <code>320</code> )           \u2013            <p>The number of points in the y-direction. Defaults to 320.</p> </li> <li> <code>iTurb</code>               (<code>int</code>, default:                   <code>None</code> )           \u2013            <p>The index of the turbine to process. Defaults to None.</p> </li> <li> <code>xplane</code>               (<code>ndarray</code>, default:                   <code>None</code> )           \u2013            <p>The x-planes to process. Defaults to None.</p> </li> <li> <code>yplane</code>               (<code>ndarray</code>, default:                   <code>None</code> )           \u2013            <p>The y-planes to process. Defaults to None.</p> </li> <li> <code>dl_fname</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>The filename for the delta L field. Defaults to None.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>           \u2013            <p>None</p> </li> </ul> Source code in <code>src/prepost/spl_process.py</code> <pre><code>def concatenate_planes_dl(\n    casename: str,\n    path2Pe: str,\n    nx: int = 350,\n    ny: int = 320,\n    iTurb: int = None,\n    xplane: np.ndarray = None,\n    yplane: np.ndarray = None,\n    dl_fname: str = None\n) -&gt; None:\n    \"\"\"\n    This function processes the delta L field to concatenate planes and saves\n    the results to files.\n    WARNING: this was not used a lot and it may be a bit broken. \n\n    Args:\n        casename (str): The name of the simulation case.\n        path2Pe (str): The path to the Pe results.\n        nx (int, optional): The number of points in the x-direction. Defaults to 350.\n        ny (int, optional): The number of points in the y-direction. Defaults to 320.\n        iTurb (int, optional): The index of the turbine to process. Defaults to None.\n        xplane (np.ndarray, optional): The x-planes to process. Defaults to None.\n        yplane (np.ndarray, optional): The y-planes to process. Defaults to None.\n        dl_fname (str, optional): The filename for the delta L field. Defaults to None.\n\n    Returns:\n        None\n    \"\"\"\n    # load simulation parameters \n    simu = Simu(casename) \n    simu.load(path2Pe+casename+'.dat')\n\n    # compute spl for given wind turbine\n    if iTurb is not None:\n        #-----------------------------------------------------------------\n        # create delta L field (read from Pe results)\n\n        # retrieve planes to be computed \n        if xplane is not None:\n            deltaL = DeltaLField(path2Pe,casename)\n            # check that planes was set to be recorded\n            if not np.all(np.isin(xplane,simu.xplanes)) :\n                print('planes were not calculated')\n                return -1\n\n            # set plane in the turbine coordinate system      \n            xplane = xplane-simu.tx[iTurb]*simu.les.z_i\n            # read all slice for all heights and angles  \n            deltaL.read_all_slices(iTurb,simu.heights,simu.tau,simu.distribute_tau,xplanes=xplane)\n\n            # concatenate slice x constant\n            deltaL.concatenate_xslices()\n            # # shift domain to absolute coordinate\n            deltaL.shift_domain(simu.tx[iTurb]*simu.les.z_i,simu.ty[iTurb]*simu.les.z_i)\n            # # create interpolation mesh \n            x = np.linspace(simu.x1,simu.x2,nx)\n            y = np.linspace(simu.y1,simu.y2,ny)\n            # set sour receiver (usefull for later)\n            deltaL.xS = simu.tx[iTurb]*simu.les.z_i\n            deltaL.yS = simu.ty[iTurb]*simu.les.z_i\n            # interpolate mesh on regular y values \n            print('interpolating ...')\n            # deltaL.interpolate_planes(y=y)\n            deltaL.interpolate_planes(y=y)\n\n            # save mesh\n            if dl_fname is None :\n                dl_fname = './yz/DL'\n            print('saving ...')\n            deltaL.save(dl_fname+str(iTurb)+'.dat')\n            deltaL = None\n            quit()\n\n        # retrieve planes to be computed \n        if yplane is not None:\n            deltaL = DeltaLField(path2Pe,casename)\n            # check that planes were recorded\n            if not np.all(np.isin(yplane,simu.yplanes)) :\n                print('planes were not calculated')\n\n            yplane = yplane-simu.ty[iTurb]*simu.les.z_i\n            # read planes from all angles all receiver\n            deltaL.read_all_slices(iTurb,simu.heights,simu.tau,simu.distribute_tau,yplanes=yplane)\n\n            # concatenate slice x constant\n            deltaL.concatenate_yslices()\n            # shift domain to absolute coordinate\n            deltaL.shift_domain(simu.tx[iTurb]*simu.les.z_i,simu.ty[iTurb]*simu.les.z_i)\n            # create interpolation mesh \n            x = np.linspace(simu.x1,simu.x2,nx)\n            y = np.linspace(simu.y1,simu.y2,ny)\n            # set sour receiver (usefull for later)\n            deltaL.xS = simu.tx[iTurb]*simu.les.z_i\n            deltaL.yS = simu.ty[iTurb]*simu.les.z_i\n            # interpolate mesh on regular y values \n            print('interpolating ...')\n            deltaL.interpolate_planes(x=x)\n\n            # save mesh\n            if dl_fname is None :\n                dl_fname = './xz/DL'\n            print('saving ...')\n            deltaL.save(dl_fname+str(iTurb)+'.dat')\n            deltaL = None\n    # if not trubine index given loop over all turbines \n    else:\n        for iTurb in range(len(simu.tx)):\n            #-----------------------------------------------------------------\n            # create delta L field (read from Pe results)\n            deltaL = DeltaLField(path2Pe,casename)\n\n            # retrieve planes to be computed \n            if xplane is not None:\n                # check that planes were recorded\n                if not np.all(np.isin(xplane,simu.xplanes)) :\n                    print('planes were not calculated')\n                else:\n                    xplane = xplane-simu.tx[iTurb]*simu.les.z_i\n                # read planes from all angles all receiver\n                for plane in xplane:\n                    for t in simu.tau:\n                        for h in simu.heights:\n                            deltaL.read_planes(iTurb,h,t,simu.distribute_tau,xplane=plane)\n                    deltaL.concatenate_plane()\n                    deltaL.plane_list=[]\n                # shift domain to absolute coordinate\n                deltaL.shiftDomain(simu.tx[iTurb]*simu.les.z_i,simu.ty[iTurb]*simu.les.z_i)\n                # create interpolation mesh \n                x = np.linspace(simu.x1,simu.x2,nx)\n                y = np.linspace(simu.y1,simu.y2,ny)\n                # set sour receiver (usefull for later)\n                deltaL.xS = simu.tx[iTurb]*simu.les.z_i\n                deltaL.yS = simu.ty[iTurb]*simu.les.z_i\n                # interpolate mesh on regular y values \n                deltaL.interpolate_planes(y=y)\n                # save mesh\n                if dl_fname is None :\n                    dl_fname = 'DLx'\n                deltaL.save(dl_fname+str(iTurb)+'.dat')\n                deltaL = None\n\n            deltaL = DeltaLField(path2Pe,casename)\n            # retrieve planes to be computed \n            if yplane is not None:\n                # check that planes were recorded\n                if not np.all(np.isin(yplane,simu.yplanes)) :\n                    print('planes were not calculated')\n                else:\n                    yplane = yplane-simu.ty[iTurb]*simu.les.z_i\n                # read planes from all angles all receiver\n                for plane in yplane:\n                    for t in simu.tau:\n                        for h in simu.heights:\n                            deltaL.read_planes(iTurb,h,t,simu.distribute_tau,yplane=plane)\n                    deltaL.concatenate_plane()\n                    deltaL.plane_list=[]\n                # shift domain to absolute coordinate\n                deltaL.shiftDomain(simu.tx[iTurb]*simu.les.z_i,simu.ty[iTurb]*simu.les.z_i)\n                # create interpolation mesh \n                x = np.linspace(simu.x1,simu.x2,nx)\n                y = np.linspace(simu.y1,simu.y2,ny)\n                # set sour receiver (usefull for later)\n                deltaL.xS = simu.tx[iTurb]*simu.les.z_i\n                deltaL.yS = simu.ty[iTurb]*simu.les.z_i\n                # interpolate mesh on regular y values \n                deltaL.interpolate_planes(x=x)\n                # save mesh\n                if dl_fname is None :\n                    dl_fname = 'DLy'\n                deltaL.save(dl_fname+str(iTurb)+'.dat')\n                deltaL = None\n</code></pre>"},{"location":"reference/spl_process.html#src.prepost.spl_process.postprocessingPlanesCombine","title":"<code>postprocessingPlanesCombine(casename, path2Pe, iTurb=None, dl_fname=None, spp_fname=None, spl_fname=None)</code>","text":"<p>Combines the delta L field with the source field for a given turbine and plane.</p> <p>Parameters:</p> <ul> <li> <code>casename</code>               (<code>str</code>)           \u2013            <p>The name of the simulation case.</p> </li> <li> <code>path2Pe</code>               (<code>str</code>)           \u2013            <p>The path to the Pe results.</p> </li> <li> <code>iTurb</code>               (<code>int</code>, default:                   <code>None</code> )           \u2013            <p>The index of the turbine to process. Defaults to None.</p> </li> <li> <code>dl_fname</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>The filename for the delta L field. Defaults to None.</p> </li> <li> <code>spp_fname</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>The filename for the Spp field. Defaults to None.</p> </li> <li> <code>spl_fname</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>The filename for the Spl field. Defaults to None.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>           \u2013            <p>None</p> </li> </ul> Source code in <code>src/prepost/spl_process.py</code> <pre><code>def postprocessingPlanesCombine(\n    casename: str,\n    path2Pe: str,\n    iTurb: int = None,\n    dl_fname: str = None,\n    spp_fname: str = None,\n    spl_fname: str = None\n) -&gt; None:\n    \"\"\"\n    Combines the delta L field with the source field for a given turbine and plane.\n\n    Args:\n        casename (str): The name of the simulation case.\n        path2Pe (str): The path to the Pe results.\n        iTurb (int, optional): The index of the turbine to process. Defaults to None.\n        dl_fname (str, optional): The filename for the delta L field. Defaults to None.\n        spp_fname (str, optional): The filename for the Spp field. Defaults to None.\n        spl_fname (str, optional): The filename for the Spl field. Defaults to None.\n\n    Returns:\n        None\n    \"\"\"\n    if dl_fname is None :\n        dl_fname = 'DLy'\n    if spp_fname is None:\n        spp_fname = 'SppY_'\n    if spl_fname is None:\n        spl_fname = 'SplY_'\n\n    # load simulation parameters \n    simu = Simu(casename) \n    simu.load(path2Pe+casename+'.dat')\n\n    #-----------------------------------------------------------------\n    # create delta L field (read from Pe results)\n    deltaL = DeltaLField(path2Pe,casename)\n\n    # loadDelta L field \n    deltaL.load(dl_fname+str(iTurb)+'.dat')\n\n    # read source file \n    #-----------------------------------------------------------------\n    src = Source()\n    src.load(spp_fname+str(iTurb)+'.dat')\n\n    print(src.Spp.shape)\n\n    print(deltaL.deltaLInterpolated.shape)\n\n\n    # create spl field \n    #-----------------------------------------------------------------\n    z = np.linspace(0,300,100)\n    x = np.linspace(500,4000,100)\n\n\n    # src.interpolateXY(x,np.array([1600]))\n    src.interpolateXZ(x,z)\n    deltaL.interpolateXZ(x,z)\n\n    print(src.y_interpolate.shape)\n    print(deltaL.y_interpolate.shape)\n\n    print(src.y_interpolate[0,:,0])\n    print(deltaL.y_interpolate[0,:,0])\n    spl = SplField(src,deltaL)\n\n    spl.check_compatibility()\n    spl.src.wt.tau = 0\n\n    # combine Delta L spp \n    spl.combine_linear_broadband()\n    # spl.src.save(spp_fname+str(iTurb)+'.dat')\n    # spl.deltaL.save(dl_fname+str(iTurb)+'.dat')\n    spl.save(spl_fname+str(iTurb)+'.dat')\n</code></pre>"},{"location":"reference/utils.html","title":"Reference for <code>prepost/utils.py</code>","text":""},{"location":"reference/utils.html#src.prepost.utils.uneven_tile","title":"<code>uneven_tile(A, reps)</code>","text":"Source code in <code>src/prepost/utils.py</code> <pre><code>def uneven_tile(A: np.ndarray, reps: tuple):\n\n    d = len(reps)\n    if (d &lt; A.ndim):\n        tup = (1,)*(A.ndim-d) + reps\n\n    even_reps = tuple(int(rep) for rep in reps)\n    rest_reps = tuple(int((rep-int(rep))*n) for rep, n in zip(reps, A.shape))\n    shape_out = tuple((s*et + rt)\n                      for s, et, rt in zip(A.shape, even_reps, rest_reps))\n    c = np.tile(A, even_reps)\n\n    if c.size &gt; 0:\n        for idim, rep in enumerate(rest_reps):\n            if rep &gt; 0:\n                indices = np.arange(0, rep)\n                c = np.concatenate(\n                    (c, np.take(c, indices, axis=idim)), axis=idim)\n\n    return c.reshape(shape_out)\n</code></pre>"},{"location":"reference/utils.html#src.prepost.utils.uneven_loop","title":"<code>uneven_loop(A, N)</code>","text":"Source code in <code>src/prepost/utils.py</code> <pre><code>def uneven_loop(A: np.ndarray, N: int):\n    n = A.shape[-1]\n    if N == n:\n        return A\n    if N &lt; n:\n        print(\"cant loop because new Nt smaller than old Nt\")\n        return -1\n    ncopy = N // n\n    nrest = N % n\n    new_shape = list(A.shape)\n    new_shape[-1] = N\n    new_shape = tuple(new_shape)\n\n    A_new = np.zeros(new_shape)\n\n    for ii in range(ncopy):\n        A_new[..., ii*n:(ii+1)*n] = A\n    if nrest &gt; 0:\n        A_new[..., (ncopy)*n:] = A[..., :nrest]\n    return A_new\n</code></pre>"},{"location":"reference/utils.html#src.prepost.utils.computeThirdOctaveFrequencies","title":"<code>computeThirdOctaveFrequencies(fc, Nfc)</code>","text":"Source code in <code>src/prepost/utils.py</code> <pre><code>def computeThirdOctaveFrequencies(fc, Nfc):\n    if len(fc) != len(Nfc):\n        print('Fc and Nfc must be of same length')\n        return\n    Nfreq = sum(Nfc)\n    print(Nfreq)\n    freq = np.array([])\n    for ii in range(len(fc)):\n        freq = np.concatenate(\n            (freq, np.round(fc[ii]*2**((2*np.arange(1, Nfc[ii]+1)/(Nfc[ii]+1) - 1)/6))))\n    print(len(freq))\n    return (freq)\n</code></pre>"},{"location":"reference/utils.html#src.prepost.utils.Aweight","title":"<code>Aweight(f)</code>","text":"Source code in <code>src/prepost/utils.py</code> <pre><code>def Aweight(f):\n    Af = 12200**2*f**4./(f**2+20.6**2)/(f**2+12200**2) / \\\n        (f**2+107.7**2)**0.5/(f**2+737.9**2)**0.5\n    dBA = 20*np.log10(Af/0.7943)\n    return dBA\n</code></pre>"},{"location":"reference/utils.html#src.prepost.utils.chkList","title":"<code>chkList(lst)</code>","text":"Source code in <code>src/prepost/utils.py</code> <pre><code>def chkList(lst: list) -&gt; (bool, int):\n    ele = lst[0]\n    # Comparing each element with first item\n    for ii, item in enumerate(lst):\n        if not np.all(ele == item):\n            return False, ii\n    return True, 0\n</code></pre>"},{"location":"reference/utils.html#src.prepost.utils.interp_weights","title":"<code>interp_weights(xy, uv, d=2)</code>","text":"Source code in <code>src/prepost/utils.py</code> <pre><code>def interp_weights(xy, uv, d=2):\n    tri = qhull.Delaunay(xy)\n    simplex = tri.find_simplex(uv)\n    vertices = np.take(tri.simplices, simplex, axis=0)\n    temp = np.take(tri.transform, simplex, axis=0)\n    delta = uv - temp[:, d]\n    bary = np.einsum('njk,nk-&gt;nj', temp[:, :d, :], delta)\n    return vertices, np.hstack((bary, 1 - bary.sum(axis=1, keepdims=True)))\n</code></pre>"},{"location":"reference/utils.html#src.prepost.utils.interpolate","title":"<code>interpolate(values, vtx, wts)</code>","text":"Source code in <code>src/prepost/utils.py</code> <pre><code>def interpolate(values, vtx, wts):\n    return np.einsum('nj,nj-&gt;n', np.take(values, vtx), wts)\n</code></pre>"},{"location":"reference/utils.html#src.prepost.utils.atm_absorption","title":"<code>atm_absorption(T0, p0, rh, f)</code>","text":"Source code in <code>src/prepost/utils.py</code> <pre><code>def atm_absorption(T0, p0, rh, f):\n    # function return the atmospheric attenuation of sound\n    # due to the thermo-viscous effects and relaxation of oxygen and nitrogen.\n    #\n    # Usage: [alpha] = atm_absorption(T0,p0,rh,f)\n    #         alpha - attenuation of sound for input parameters in dB/m\n    #         T0 - temperature in K\n    #         p0 - static pressure in pascal\n    #         rh - relative humidity en #\n    #         f - frequency of sound (may be a vector)\n    #\n    #\n    # References:   Salomons p.109-111\n\n    p0_ref = 1.01325e+05  # reference static pressure (pa)\n\n    T0_tpw = 273.15  # triple point in K\n    T0_ref = 293.15  # ref temp in K\n\n    rho = p0/p0_ref\n    tau = T0/T0_ref\n\n    # calculate saturation pressure\n    Csat = -6.8346*(T0_tpw/T0)**1.261 + 4.6151\n    p0_sat = p0_ref*10**Csat\n    h = rh*p0_sat/p0  # absolute humidity\n\n    # Scaled relaxation frequency for Nitrogen\n    frN = rho*tau**(-1/2)*(9 + 280*h*np.exp(-4.17*(tau**(-1/3)-1)))\n\n    # scaled relaxation frequency for Oxygen\n    frO = rho*(24 + 40400*h*(0.02+h)/(0.391+h))\n\n    # attenuation coefficient in dB/m\n    b1 = 0.1068*np.exp(-3352/T0)/(frN + f**2/frN)\n    b2 = 0.01275*np.exp(-2239.1/T0)/(frO + f**2/frO)\n    alpha = 8.686*f**2*tau**(1/2)*(1.84e-11/rho + tau**(-3)*(b1 + b2))\n    return alpha\n</code></pre>"},{"location":"reference/utils.html#src.prepost.utils.cos_window","title":"<code>cos_window(n, overlap)</code>","text":"Source code in <code>src/prepost/utils.py</code> <pre><code>def cos_window(n, overlap):\n    w = np.ones((n,))\n    if overlap == 0:\n        return w\n    if overlap &gt; n/2:\n        logging.warning('error overlap larger than signal')\n        quit()\n    w[:overlap] = np.sin(0.5*np.arange(0, overlap, 1)*np.pi/(overlap-1))**2\n    w[-overlap:] = np.cos(0.5*np.arange(0, overlap, 1)*np.pi/(overlap-1))**2\n\n    return w\n</code></pre>"},{"location":"reference/utils.html#src.prepost.utils.integrateThirdOctave","title":"<code>integrateThirdOctave(frequencies, s)</code>","text":"Source code in <code>src/prepost/utils.py</code> <pre><code>def integrateThirdOctave(frequencies, s):\n    # #name of third octave bands\n    # one_third_freq_preferred = np.array([5, 6.3, 8, 10, 12.5, 16, 20, 25,  31.5,\n    # 40, 50, 63, 80, 100, 125, 160, 200, 250, 315, 400, 500, 630, 800, 1000])\n    one_third_freq_preferred = np.array(\n        [50, 63, 80, 100, 125, 160, 200, 250, 315, 400, 500, 630, 800, 1000])\n\n    # check if frequencies and spectrum are broadcastable\n    if (len(frequencies) != s.shape[-1]):\n        print('last dimension of s must be equal to number of frequencies')\n        return (one_third_freq_preferred, -1)\n    # number of band\n    Nband = len(one_third_freq_preferred)\n    # df = frequencies[1] - frequencies[0]\n    # real central frequency of each band\n    one_third_bands = np.zeros((Nband, 2))\n    one_third_freq = 1000*((2**(1/3)))**(np.arange(1, Nband+1)-Nband)\n\n    # upper and lower limit of each band\n    one_third_bands[:, 0] = one_third_freq/(2**(1/6))\n    one_third_bands[:, 1] = one_third_freq*(2**(1/6))\n    # allocate memory for third octave band spevctrum\n    bands = np.zeros(s.shape[0:-1] + (Nband,))\n    # loop over the thir octave bands\n    for ii in range(Nband):\n        # find frequencies index inside the band\n        idx = np.squeeze(np.array(np.nonzero((frequencies &gt;= one_third_bands[ii, 0]) &amp; (\n            frequencies &lt; one_third_bands[ii, 1]))))\n\n        # if band outside frequency range\n        if idx.size == 0:\n            bands[..., ii] = 0\n        # if only one frequency inside the band\n        elif (idx.size == 1):\n            df = one_third_freq[ii]*0.232\n            bands[..., ii] = df*(s[..., idx])\n        # I need to take a look at what I have done here (from matlab code)\n        else:\n            df = one_third_freq[ii]*0.232/len(idx)\n            if np.amin(idx) == 0:\n                bands[..., ii] = df*(0.75*s[..., idx[1]] +\n                                     np.sum(s[..., idx[1:]], -1) +\n                                     0.75*s[..., idx[-1]] + 0.25*(s[..., idx[-1]+1]))\n\n            elif np.amax(idx) == s.shape[-1]-1:\n                bands[..., ii] = df*(0.25*s[..., idx[0]-1] + 0.75*s[..., idx[0]]\n                                     + np.sum(s[..., idx[1:-1]], -1)\n                                     + 0.75*s[..., idx[-1]])\n            else:\n                bands[..., ii] = df*(0.25*s[..., idx[0]-1] + 0.75*s[..., idx[0]]\n                                     + np.sum(s[..., idx[2:-1]], -1)\n                                     + 0.75*s[..., idx[-1]] + 0.25*s[..., idx[-1]+1])\n\n    return (one_third_freq_preferred, bands)\n</code></pre>"},{"location":"reference/utils.html#src.prepost.utils.save_figure","title":"<code>save_figure(filepath=None, fig='gcf', clean=True)</code>","text":"Source code in <code>src/prepost/utils.py</code> <pre><code>def save_figure(filepath: str = None, fig='gcf', clean: bool = True):\n    # plt.savefig(filepath) \n    from matplotlib.lines import Line2D\n    from matplotlib.legend import Legend\n    Line2D._us_dashSeq = property(lambda self: self._dash_pattern[1])\n    Line2D._us_dashOffset = property(lambda self: self._dash_pattern[0])\n    Legend._ncol = property(lambda self: self._ncols)\n\n    if clean:\n        tikzplotlib.clean_figure()\n\n    isExist = os.path.exists(os.path.dirname(filepath))\n    if not isExist:\n        os.makedirs(os.path.dirname(filepath))\n    tikzplotlib.save(filepath=filepath, figure=fig,\n                     wrap=False,\n                     add_axis_environment=True,\n                     tex_relative_path_to_data='\\\\figpath',\n                     dpi=300,\n                     externalize_tables=True,\n                     override_externals=True,\n                     extra_axis_parameters={\n                         # 'axis background/.style={fill=gray!60}',\n                         'xtick distance= \\\\xtick',\n                         'ytick distance = \\\\ytick',\n                         'colorbar=\\\\colorb',\n                         'colorbar style ={title=\\\\clegend,at={(1.02,1)},anchor=north west,width=0.15cm,major tick length=0.15cm,tick pos=right}',\n                         'height=\\\\height',\n                         'width=\\\\width',\n                         'tick align=outside',\n                         'xmin=\\\\xmin',\n                         'xmax=\\\\xmax',\n                         'ymin=\\\\ymin', 'ymax=\\\\ymax',\n                         'xlabel=\\\\xlabel',\n                         'ylabel =\\\\ylabel'}\n                     )\n    print(tikzplotlib.Flavors.latex.preamble())\n</code></pre>"},{"location":"reference/utils.html#src.prepost.utils.save_simple_figure","title":"<code>save_simple_figure(filepath=None, fig='gcf', clean=True)</code>","text":"Source code in <code>src/prepost/utils.py</code> <pre><code>def save_simple_figure(filepath: str = None, fig='gcf', clean: bool = True):\n    # plt.savefig(filepath) \n    from matplotlib.lines import Line2D\n    from matplotlib.legend import Legend\n    Line2D._us_dashSeq = property(lambda self: self._dash_pattern[1])\n    Line2D._us_dashOffset = property(lambda self: self._dash_pattern[0])\n    Legend._ncol = property(lambda self: self._ncols)\n    if clean:\n        tikzplotlib.clean_figure()\n\n    isExist = os.path.exists(os.path.dirname(filepath))\n    if not isExist:\n        os.makedirs(os.path.dirname(filepath))\n    tikzplotlib.save(filepath=filepath, figure=fig,\n                     wrap=False,\n                     add_axis_environment=True,\n                     tex_relative_path_to_data='\\\\figpath',\n                     dpi=300,\n                     externalize_tables=True,\n                     override_externals=True,\n                     extra_axis_parameters={\n                         # 'axis background/.style={fill=gray!60}',\n                         'height=\\\\height',\n                         'width=\\\\width',\n                         \"axis on top\",\n                         'colorbar style ={title=\\\\clegend,at={(1.02,1)},anchor=north west,width=0.15cm,major tick length=0.15cm,tick pos=right}',\n                         }\n                     )\n    print(tikzplotlib.Flavors.latex.preamble())\n</code></pre>"},{"location":"reference/wape.html","title":"Reference for <code>prepost/wape.py</code>","text":""},{"location":"reference/wape.html#src.prepost.wape.PeResults","title":"<code>PeResults(casename, iTurb, height, tau, dirname='./', distribute_tau=None)</code>","text":"<p>This class is used to handle PE results computed with the code found in <code>src/kernel/New_PE_c/</code>. This allow to read results from the .h5 files and to plot the \\(\\Delta L\\) fields. </p> <p>Parameters:</p> <ul> <li> <code>casename</code>               (<code>str</code>)           \u2013            <p>Name of the case.</p> </li> <li> <code>iTurb</code>               (<code>int</code>)           \u2013            <p>Index of the turbine.</p> </li> <li> <code>height</code>               (<code>float</code>)           \u2013            <p>Source height.</p> </li> <li> <code>tau</code>               (<code>float</code>)           \u2013            <p>Propagation angle.</p> </li> <li> <code>dirname</code>               (<code>str</code>, default:                   <code>'./'</code> )           \u2013            <p>Directory name. Defaults to \"./\".</p> </li> <li> <code>distribute_tau</code>               (<code>int</code>, default:                   <code>None</code> )           \u2013            <p>Number of tau distributions. Defaults to None.</p> </li> </ul> Source code in <code>src/prepost/wape.py</code> <pre><code>def __init__(self, casename: str, iTurb: int, height: float, tau: float, dirname: str = \"./\", distribute_tau: int = None):\n    self.casename = casename\n    self.iTurb = iTurb\n    self.tau = tau\n    if int(tau) == tau:\n        self.tau_str = format(tau, \"04d\")\n    else:\n        self.tau_str = str(tau)\n\n    self.height = height\n    self.dirname = dirname\n    self.distribute_tau = distribute_tau\n    self.deltaL = None\n    self.receiver = None\n    self.THIRD = False\n</code></pre>"},{"location":"reference/wape.html#src.prepost.wape.PeResults.read_carto","title":"<code>read_carto(fname)</code>","text":"<p>Reads the cartography data from the H5 file. These are 2D fields saved for the different frequency. They are stored in a matrix <code>self.deltaL</code> of shape (Nz,Nx,Nf).</p> <p>Parameters:</p> <ul> <li> <code>fname</code>               (<code>str</code>)           \u2013            <p>File name of the H5 file.</p> </li> </ul> Source code in <code>src/prepost/wape.py</code> <pre><code>def read_carto(self, fname: str):\n    \"\"\"Reads the cartography data from the H5 file.\n    These are 2D fields saved for the different frequency.\n    They are stored in a matrix `self.deltaL` of shape (Nz,Nx,Nf).\n\n    Args:\n        fname (str): File name of the H5 file.\n    \"\"\"\n    file = h5py.File(fname, \"r\")\n    solutions = file.get(\"solution\")\n    mesh = file.get(\"mesh\")\n    frequencies = list(solutions.keys())\n    self.frequencies = np.array([float(i) for i in frequencies])\n    self.x = np.array(mesh[\"x\"])\n    self.z = np.array(mesh[\"y\"])\n    self.deltaL = np.zeros((len(self.x), len(self.z), len(self.frequencies)))\n    # solution matrix (Nz,Nx,Nf)\n    for ii in range(len(frequencies)):\n        sol = solutions.get(frequencies[ii])\n        self.deltaL[:, :, ii] = np.transpose(np.array(sol[\"deltaL\"]))\n</code></pre>"},{"location":"reference/wape.html#src.prepost.wape.PeResults.read_receiver","title":"<code>read_receiver(fname)</code>","text":"<p>Reads the receiver data from the H5 file. They are 2D field (there can be different receiver heights).  They are stored in a matrix <code>self.receiver</code> of shape (Nx, Nrec, Nf).</p> <p>Parameters:</p> <ul> <li> <code>fname</code>               (<code>str</code>)           \u2013            <p>File name of the H5 file.</p> </li> </ul> Source code in <code>src/prepost/wape.py</code> <pre><code>def read_receiver(self, fname: str):\n    \"\"\"Reads the receiver data from the H5 file.\n    They are 2D field (there can be different receiver heights). \n    They are stored in a matrix `self.receiver` of shape (Nx, Nrec, Nf).\n\n    Args:\n        fname (str): File name of the H5 file.\n    \"\"\"\n    file = h5py.File(fname, \"r\")\n    mesh = file.get(\"mesh\")\n    self.x = np.array(mesh[\"x\"])\n\n    # read delta L saved at receivers\n    receivers_all = file.get(\"receiver\")\n    self.heights = np.array(receivers_all.get(\"heights\"))\n    frequencies = list(receivers_all.keys())\n    id_height = frequencies.index(\"heights\")\n    frequencies.pop(id_height)\n    self.frequencies = np.array([float(i) for i in frequencies])\n    self.z = self.heights\n\n    self.receiver = np.zeros(\n        (len(self.x), len(self.heights), len(self.frequencies))\n    )\n    for ii in range(len(self.frequencies)):\n        rec = receivers_all.get(frequencies[ii])\n        self.receiver[:, :, ii] = np.transpose(np.array(rec[\"deltaL\"]))\n</code></pre>"},{"location":"reference/wape.html#src.prepost.wape.PeResults.read_planes","title":"<code>read_planes(fname)</code>","text":"<p>Reads the plane data from the H5 file. Slice of the solution are saved at the different \\(r\\) position.  This is done to obtain constan \\(x\\) or \\(y\\) plane solution from different propagation angle around the source. The slice used for \\(x\\) constant and \\(y\\) constant planes are saved in two different matrices of size (Nplane, Nz, Nf).</p> <p>Parameters:</p> <ul> <li> <code>fname</code>               (<code>str</code>)           \u2013            <p>File name of the H5 file.</p> </li> </ul> Source code in <code>src/prepost/wape.py</code> <pre><code>def read_planes(self, fname: str):\n    \"\"\"Reads the plane data from the H5 file.\n    Slice of the solution are saved at the different $r$ position. \n    This is done to obtain constan $x$ or $y$ plane solution from different propagation angle around the source.\n    The slice used for $x$ constant and $y$ constant planes are saved in two different matrices of size (Nplane, Nz, Nf).\n\n    Args:\n        fname (str): File name of the H5 file.\n    \"\"\"\n    t0 = time.time()\n    file = h5py.File(fname, \"r\")\n    t1 = time.time()\n    mesh = file.get(\"mesh\")\n    self.z = np.array(mesh[\"y\"])\n    self.x = np.array(mesh[\"x\"])\n\n    # read delta L saved at receivers\n    planes = file.get(\"planes\")\n    frequencies = list(planes.keys())\n    self.frequencies = np.array([float(i) for i in frequencies])\n\n    rec = planes.get(frequencies[0])\n\n    self.xycoord = np.array(rec[\"xycoord\"])\n    self.xxcoord = np.array(rec[\"xxcoord\"])\n    self.xcount = np.array(rec[\"xcount\"])\n    self.nxplanes = self.xycoord.size\n\n    self.yxcoord = np.array(rec[\"yxcoord\"])\n    self.yycoord = np.array(rec[\"yycoord\"])\n    self.ycount = np.array(rec[\"ycount\"])\n\n    self.nyplanes = self.yxcoord.size\n    self.xplanes = np.zeros((self.nxplanes, len(self.z), len(self.frequencies)))\n    self.yplanes = np.zeros((self.nyplanes, len(self.z), len(self.frequencies)))\n    t2 = time.time()\n    for ii in range(len(self.frequencies)):\n        rec = planes.get(frequencies[ii])\n        self.xplanes[:, :, ii] = np.transpose(np.array(rec[\"xplane\"]))\n        self.yplanes[:, :, ii] = np.transpose(np.array(rec[\"yplane\"]))\n\n    t_end = time.time()\n\n    t_read =  t1 - t0\n    t_info = t2 - t1\n    t_get_dat = t_end - t2\n    t_tot = t_end - t0 \n\n    print('time -----')\n    print(t_read/t_tot, t_info/t_tot, t_get_dat/t_tot) \n    print('----------')\n</code></pre>"},{"location":"reference/wape.html#src.prepost.wape.PeResults.plotSide","title":"<code>plotSide(freq, cmap='RdBu_r')</code>","text":"<p>Plots the side view of the deltaL for a given frequency. Must be used after <code>read_carto()</code></p> <p>Parameters:</p> <ul> <li> <code>freq</code>               (<code>float</code>)           \u2013            <p>Frequency to plot.</p> </li> <li> <code>cmap</code>               (<code>str</code>, default:                   <code>'RdBu_r'</code> )           \u2013            <p>Colormap to use. Defaults to \"RdBu_r\".</p> </li> </ul> Source code in <code>src/prepost/wape.py</code> <pre><code>def plotSide(self, freq: float, cmap: str = \"RdBu_r\"):\n    \"\"\"Plots the side view of the deltaL for a given frequency.\n    Must be used after `read_carto()`\n\n    Args:\n        freq (float): Frequency to plot.\n        cmap (str, optional): Colormap to use. Defaults to \"RdBu_r\".\n    \"\"\"\n    ifreq = np.nonzero(self.frequencies == freq)[0][0]\n    if ifreq is None:\n        print(\"frequence was not calculated.\")\n        return\n    plt.pcolormesh(\n        self.x, self.z, self.deltaL[:, :, ifreq].T, cmap=cmap, shading=\"gouraud\"\n    )\n</code></pre>"},{"location":"reference/wape.html#src.prepost.wape.PeResults.plotSide3octave","title":"<code>plotSide3octave(freq, cmap='RdBu_r')</code>","text":"<p>Plots the side view of the deltaL for a given third-octave frequency. Must be used after computing the third octave averaged solution with  <code>compute3Octave</code>. Args:     freq (float): Third-octave frequency to plot.     cmap (str, optional): Colormap to use. Defaults to \"RdBu_r\".</p> Source code in <code>src/prepost/wape.py</code> <pre><code>def plotSide3octave(self, freq: float, cmap: str = \"RdBu_r\"):\n    \"\"\"Plots the side view of the deltaL for a given third-octave frequency.\n    Must be used after computing the third octave averaged solution with  `compute3Octave`.\n    Args:\n        freq (float): Third-octave frequency to plot.\n        cmap (str, optional): Colormap to use. Defaults to \"RdBu_r\".\n    \"\"\"\n    ifreq = np.nonzero(self.fc == freq)[0][0]\n    if ifreq is None:\n        print(\"frequence was not calculated.\")\n        return\n    plt.pcolormesh(\n        self.x,\n        self.z,\n        self.deltaL3octave[:, :, ifreq].T,\n        cmap=cmap,\n        shading=\"gouraud\",\n    )\n    plt.clim(-10, 10)\n    plt.ylim(0, 300)\n</code></pre>"},{"location":"reference/wape.html#src.prepost.wape.PeResults.plotLineTotalDeltaL","title":"<code>plotLineTotalDeltaL(height)</code>","text":"<p>Plots the total deltaL along a line at a given height. This does not make much sense.</p> <p>Parameters:</p> <ul> <li> <code>height</code>               (<code>float</code>)           \u2013            <p>Height to plot.</p> </li> </ul> Source code in <code>src/prepost/wape.py</code> <pre><code>def plotLineTotalDeltaL(self, height: float):\n    \"\"\"Plots the total deltaL along a line at a given height.\n    This does not make much sense.\n\n    Args:\n        height (float): Height to plot.\n    \"\"\"\n    iheight = np.nonzero(self.heights == height)[0][0]\n    plt.plot(\n        self.x,\n        10 * np.log10(np.sum(10 ** (self.deltaL3octave[:, iheight, :] / 10), 1)),\n    )\n</code></pre>"},{"location":"reference/wape.html#src.prepost.wape.PeResults.plotSideTotalDeltaL","title":"<code>plotSideTotalDeltaL(cmap='RdBu_r')</code>","text":"<p>Plots the side view of the total deltaL. This does not make much sense.</p> <p>Parameters:</p> <ul> <li> <code>cmap</code>               (<code>str</code>, default:                   <code>'RdBu_r'</code> )           \u2013            <p>Colormap to use. Defaults to \"RdBu_r\".</p> </li> </ul> Source code in <code>src/prepost/wape.py</code> <pre><code>def plotSideTotalDeltaL(self, cmap: str = \"RdBu_r\"):\n    \"\"\"Plots the side view of the total deltaL.\n    This does not make much sense.\n\n    Args:\n        cmap (str, optional): Colormap to use. Defaults to \"RdBu_r\".\n    \"\"\"\n    plt.pcolormesh(\n        self.x,\n        self.z,\n        10 * np.log10(np.sum(10 ** (self.deltaL3octave[:, :, :] / 10), 2)).T,\n        cmap=cmap,\n        shading=\"gouraud\",\n    )\n    plt.clim(-10, 10)\n    plt.gca().set_aspect(\"equal\", adjustable=\"box\")\n    plt.ylim(0, 300)\n</code></pre>"},{"location":"reference/wape.html#src.prepost.wape.PeResults.plotLine","title":"<code>plotLine(freq, z, **kwargs)</code>","text":"<p>Plots the deltaL along a line at a given frequency and height. It must be used after the <code>read_receiver()</code>functions.</p> <p>Parameters:</p> <ul> <li> <code>freq</code>               (<code>float</code>)           \u2013            <p>Frequency to plot.</p> </li> <li> <code>z</code>               (<code>float</code>)           \u2013            <p>Height to plot.</p> </li> <li> <code>**kwargs</code>           \u2013            <p>Additional keyword arguments for plotting.</p> </li> </ul> Source code in <code>src/prepost/wape.py</code> <pre><code>def plotLine(self, freq: float, z: float, **kwargs):\n    \"\"\"Plots the deltaL along a line at a given frequency and height.\n    It must be used after the `read_receiver()`functions.\n\n    Args:\n        freq (float): Frequency to plot.\n        z (float): Height to plot.\n        **kwargs: Additional keyword arguments for plotting.\n    \"\"\"\n    ifreq = np.nonzero(self.frequencies == freq)[0][0]\n    iz = np.nonzero(self.z == z)[0][0]\n    if ifreq is None:\n        print(\"frequence was not calculated.\")\n        return\n    if iz is None:\n        print(\"receiver's height was not calculated.\")\n        return\n    if self.receiver is not None:\n        plt.plot(self.x, self.receiver[:, iz, ifreq],**kwargs)\n    else:\n        plt.plot(self.x, self.deltaL[:, iz, ifreq],**kwargs)\n</code></pre>"},{"location":"reference/wape.html#src.prepost.wape.PeResults.plotLine3octave","title":"<code>plotLine3octave(freq, height, **kwargs)</code>","text":"<p>Plots the deltaL along a line at a given third-octave frequency and height.</p> <p>Parameters:</p> <ul> <li> <code>freq</code>               (<code>float</code>)           \u2013            <p>Third-octave frequency to plot.</p> </li> <li> <code>height</code>               (<code>float</code>)           \u2013            <p>Height to plot.</p> </li> <li> <code>**kwargs</code>           \u2013            <p>Additional keyword arguments for plotting.</p> </li> </ul> Source code in <code>src/prepost/wape.py</code> <pre><code>def plotLine3octave(self, freq: float, height: float, **kwargs):\n    \"\"\"Plots the deltaL along a line at a given third-octave frequency and height.\n\n    Args:\n        freq (float): Third-octave frequency to plot.\n        height (float): Height to plot.\n        **kwargs: Additional keyword arguments for plotting.\n    \"\"\"\n    ifreq = np.nonzero(self.fc == freq)[0][0]\n    iheight = np.nonzero(self.heights == height)[0][0]\n    if ifreq is None:\n        print(\"frequence was not calculated.\")\n        return\n    if iheight is None:\n        print(\"receiver's height was not calculated.\")\n        return\n    plt.plot(self.x, self.receiver3octave[:, iheight, ifreq],**kwargs)\n</code></pre>"},{"location":"reference/wape.html#src.prepost.wape.PeResults.compute3octave","title":"<code>compute3octave(fc=None, Nfc=None)</code>","text":"<p>Computes the third-octave frequency average \\(\\Delta L\\).  fc and Nfc must corresponds to the <code>self.frequencies</code>. read from the H5 files.  A check is perfomed at the beginning of the function.</p> <p>Parameters:</p> <ul> <li> <code>fc</code>               (<code>list</code>, default:                   <code>None</code> )           \u2013            <p>List of center frequencies. Defaults to None.</p> </li> <li> <code>Nfc</code>               (<code>list</code>, default:                   <code>None</code> )           \u2013            <p>List of the number of frequencies per band. Defaults to None.</p> </li> </ul> Source code in <code>src/prepost/wape.py</code> <pre><code>def compute3octave(self, fc: list = None, Nfc: list = None):\n    \"\"\"Computes the third-octave frequency average $\\Delta L$. \n    fc and Nfc must corresponds to the `self.frequencies`. read from the H5 files. \n    A check is perfomed at the beginning of the function.\n\n    Args:\n        fc (list, optional): List of center frequencies. Defaults to None.\n        Nfc (list, optional): List of the number of frequencies per band. Defaults to None.\n    \"\"\"\n    if (fc is None) or (Nfc is None):\n        fc = [50, 63, 80, 100, 125, 160, 200, 250, 315, 400, 500, 630, 800, 1000]\n        Nfc = [1,  1,  1,   1,   1,  1,   2,   2,   3,   4,   4,   4,   5,  5]\n    freq = computeThirdOctaveFrequencies(fc, Nfc)\n    if not np.all(freq == self.frequencies):\n        print(\"central frequencies are not the same\")\n        return\n    self.fc = np.array(fc)\n    self.Nfc = np.array(Nfc)\n    if self.deltaL is not None:\n        self.deltaL3octave = np.zeros((len(self.x), self.deltaL.shape[1], len(fc)))\n    if self.receiver is not None:\n        self.receiver3octave = np.zeros((len(self.x), len(self.heights), len(fc)))\n    for ifc in range(len(fc)):\n        if self.deltaL is not None:\n            self.deltaL3octave[:, :, ifc] = 10 * np.log10(\n            np.sum(10** (self.deltaL[:,:,\n                        int(np.sum(self.Nfc[0:ifc])) : np.sum(\n                            self.Nfc[0 : ifc + 1]),]/10),2,)/Nfc[ifc])\n        if self.receiver is not None:\n            self.receiver3octave[:, :, ifc] = 10 * np.log10(\n                    np.sum(10** (self.receiver[:, :,\n                                               int(np.sum(self.Nfc[0:ifc])) : np.sum(\n                                                   self.Nfc[0 : ifc + 1]),]/10),2,)/Nfc[ifc])\n</code></pre>"},{"location":"reference/wape.html#src.prepost.wape.PeResults.plotLineOaspl","title":"<code>plotLineOaspl(height)</code>","text":"<p>Plots the OASPL along a line at a given height.</p> <p>Parameters:</p> <ul> <li> <code>height</code>               (<code>float</code>)           \u2013            <p>Height to plot.</p> </li> </ul> Source code in <code>src/prepost/wape.py</code> <pre><code>def plotLineOaspl(self, height: float):\n    \"\"\"Plots the OASPL along a line at a given height.\n\n    Args:\n        height (float): Height to plot.\n    \"\"\"\n    iheight = np.argmin(abs(self.heights - height))\n    SPL, SPL_A, OASPL, OASPL_A = computeSPLLine(\n        np.squeeze(self.receiver3octave[iheight, :, :]),\n        np.squeeze(self.x),\n        np.squeeze(self.heights[iheight] + self.h),\n        self.fc,\n        self.tau,\n        self.height,\n        c0=343,\n    )\n    plt.plot(self.x, OASPL_A)\n</code></pre>"},{"location":"reference/wape.html#src.prepost.wape.PeResults.plotFlowSide","title":"<code>plotFlowSide(fname, cmap='RdYlBu_r', xstep=1, zstep=1)</code>","text":"<p>Plots the side view of the flow field from a given H5 file. WARNING: the PE code is note very well implemented. If several angles are run in the same folder the <code>flow.h5</code> file will be overwritten.  Hence only the flow from the last angle computed can be plotted.</p> <p>Parameters:</p> <ul> <li> <code>fname</code>               (<code>str</code>)           \u2013            <p>File name of the H5 file containing the flow data.</p> </li> <li> <code>cmap</code>               (<code>str</code>, default:                   <code>'RdYlBu_r'</code> )           \u2013            <p>Colormap to use. Defaults to \"RdYlBu_r\".</p> </li> <li> <code>xstep</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>Step size in the x-direction. Defaults to 1.</p> </li> <li> <code>zstep</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>Step size in the z-direction. Defaults to 1.</p> </li> </ul> Source code in <code>src/prepost/wape.py</code> <pre><code>def plotFlowSide(self, fname: str, cmap: str = \"RdYlBu_r\", xstep: int = 1, zstep: int = 1):\n    \"\"\"Plots the side view of the flow field from a given H5 file.\n    WARNING: the PE code is note very well implemented. If several angles are run in the same folder the `flow.h5` file will be overwritten. \n    Hence only the flow from the last angle computed can be plotted.\n\n    Args:\n        fname (str): File name of the H5 file containing the flow data.\n        cmap (str, optional): Colormap to use. Defaults to \"RdYlBu_r\".\n        xstep (int, optional): Step size in the x-direction. Defaults to 1.\n        zstep (int, optional): Step size in the z-direction. Defaults to 1.\n    \"\"\"\n    f = h5py.File(fname, \"r\")\n\n    # read mesh\n    x = np.array(f[\"x\"])\n    z = np.array(f[\"z\"])\n\n    # read flow\n    u = np.array(f[\"u\"])\n    c = np.array(f[\"c\"])\n    fig, ax = plt.subplots(figsize=(10, 1.8))\n    cax = ax.pcolormesh(\n        x[::xstep, ::zstep],\n        z[::xstep, ::zstep],\n        u[::xstep, ::zstep],\n        cmap=cmap,\n        shading=\"gouraud\",\n    )\n    ax.set_aspect(\"equal\", adjustable=\"box\")\n    divider = make_axes_locatable(ax)\n    cbax = divider.append_axes(\"right\", size=\"2%\", pad=0.05)\n    ax.set_xlabel(\"$x$ (m)\")\n    ax.set_ylabel(\"$z$ (m)\")\n    fig.colorbar(cax, cax=cbax, label=\"$u$ (m/s)\")\n    plt.tight_layout()\n\n\n    fig, ax = plt.subplots(figsize=(10, 1.8))\n    cax = ax.pcolormesh(\n        x[::xstep, ::zstep],\n        z[::xstep, ::zstep],\n        c[::xstep, ::zstep],\n        cmap=cmap,\n        shading=\"gouraud\",\n    )\n    ax.set_aspect(\"equal\", adjustable=\"box\")\n    divider = make_axes_locatable(ax)\n    cbax = divider.append_axes(\"right\", size=\"2%\", pad=0.05)\n    ax.set_xlabel(\"$x$ (m)\")\n    ax.set_ylabel(\"$z$ (m)\")\n    fig.colorbar(cax, cax=cbax, label=\"$c$ (m/s)\")\n    plt.tight_layout()\n    return u,x,z\n</code></pre>"},{"location":"reference/source/BEM.html","title":"Reference for <code>prepost/source/BEM.py</code>","text":"<p>This functions allows to use Blade Element Momentum Theory to recursively compute the angle of attack on an airfoil.  It takes into accound drag and lift coefficient previously computed using <code>prepost.source.wind_turbine.WindTurbine.createBLData</code> </p> <p>TODO add explanation here !!</p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p>"},{"location":"reference/source/BEM.html#src.prepost.source.BEM.simple","title":"<code>simple(Cl_tck, Cd_tck, Re, J, theta, twist, blade_length, seg, F)</code>","text":"Source code in <code>src/prepost/source/BEM.py</code> <pre><code>def simple(Cl_tck,Cd_tck,Re,J,theta,twist,blade_length,seg,F):\n    a = 0\n    adash = 0\n    conv_limit = 1e-6\n    imax = 100\n    it = 0\n    F = 1\n    x = seg/blade_length\n\n    a_conv = []\n    adash_conv = []\n    alpha_conv = []\n\n    for it in range(imax):\n        # phi = np.arctan((1-a)/(J*x*(1+adash)))\n        # if a == 1: \n        #     phi = 0\n        #     print('test')\n        # else:\n        #     phi = np.arctan((1-a)/(J*x*(1+adash)))\n        phi = np.arctan2((1-a*F)/(J*x*(1+adash)),1)\n        # phi = np.arctan(np.divide((1-a),(J*x*(1+adash)),out=np.zeros_like(1-a),where=(J*x*(1+adash)!=0)))\n        alpha = (phi - np.pi/2  + twist)\n        F = 2/np.pi * np.arccos(np.exp(-3*(blade_length - seg)/(2*seg*np.sin(phi))))\n        # F = 1\n        Cl = interp.bisplev(np.array([Re]),np.array([alpha])* 180 / np.pi,Cl_tck)\n        Cd = interp.bisplev(np.array([Re]),np.array([alpha])* 180 / np.pi,Cd_tck)\n\n\n        Cn = Cl*np.cos(phi) + Cd*np.sin(phi)\n        Ct = Cl*np.sin(phi) - Cd*np.cos(phi)\n        a_new = 1/(4*F*np.sin(phi)**2/(theta*Cn)+1)\n        adash_new = 1/(4*F*np.sin(phi)*np.cos(phi)/(theta*Ct)-1)\n        epsilon = ((a - a_new) ** 2 + (adash - adash_new) ** 2) ** 0.5\n        if epsilon &lt; conv_limit:\n            break\n        a = a_new\n        adash = adash_new\n        it += 1\n\n    return alpha,a_new,adash_new,F,epsilon,a_conv,adash_conv,alpha_conv\n</code></pre>"},{"location":"reference/source/BEM.html#src.prepost.source.BEM.hemant1","title":"<code>hemant1(Cl_tck, Cd_tck, Re, J, R, r, twist, c)</code>","text":"Source code in <code>src/prepost/source/BEM.py</code> <pre><code>def hemant1(Cl_tck,Cd_tck,Re,J,R,r,twist,c):\n    conv_limit = 1e-6\n    imax = 100\n    Z = 3\n    a = 0; a_dash = 0\n    F = 2 / np.pi * np.arccos(np.exp(-(3 / 2) * (1 - r/ R) * (1 + J ** 2) ** 0.5))\n\n    a_conv = []\n    adash_conv = []\n    alpha_conv = []\n\n    for it in range(imax):\n        prev_a = a; prev_a_dash = a_dash\n        phi = np.arctan2(R/(r*J) * (1 - a * F) / (1 + a_dash), 1)\n        alpha = (phi - np.pi/2 + twist)\n\n        Cl = interp.bisplev(np.array([Re]),np.array([alpha])* 180/np.pi,Cl_tck)\n        lambda_coef = Z * c* Cl / (8 * np.pi * r)\n\n        a = (1 + F / lambda_coef * np.tan(phi) * np.sin(phi)) ** (-1)\n        a_dash = (F / lambda_coef * np.cos(phi) - 1) ** (-1)\n\n        a_conv.append(a)\n        adash_conv.append(a_dash)\n        alpha_conv.append(alpha)\n\n        epsilon = ((a - prev_a) ** 2 + (a_dash - prev_a_dash) ** 2) ** 0.5\n        if epsilon &lt; conv_limit:\n            break\n    eps = 0\n    if it == imax-1 : \n        a = np.nan\n        a_dash = np.nan\n        alpha = np.nan \n\n    return alpha,a,a_dash,F,eps,a_conv,adash_conv,alpha_conv\n</code></pre>"},{"location":"reference/source/BEM.html#src.prepost.source.BEM.hemant2","title":"<code>hemant2(Cl_tck, Cd_tck, Re, J, R, r, twist, c)</code>","text":"Source code in <code>src/prepost/source/BEM.py</code> <pre><code>def hemant2(Cl_tck,Cd_tck,Re,J,R,r,twist,c):\n    a = 0\n    a_dash = 0\n    conv_limit = 1e-6\n    imax = 100\n    Z = 3\n    a = 0; a_dash = 0\n    F = 2 / np.pi * np.arccos(np.exp(-(3 / 2) * (1 - r/ R) * (1 + J ** 2) ** 0.5))\n    a_conv = []\n    adash_conv = []\n    alpha_conv = []\n    for it in range(imax):\n        prev_a = a; prev_a_dash = a_dash\n\n        phi = np.arctan2(R/(r*J) * (1 - a * F) / (1 + a_dash), 1)\n        alpha = (phi - np.pi/2 + twist)\n        Cl = interp.bisplev(np.array([Re]),np.array([alpha])* 180 / np.pi,Cl_tck)\n        Cd = interp.bisplev(np.array([Re]),np.array([alpha])* 180 / np.pi,Cd_tck)\n        # F = 2/np.pi * np.arccos(np.exp(-3*(1 - r/R)/(2*np.sin(phi))))\n        lambda_coef = Z * c* Cl / (8 * np.pi * r)\n        eps = Cd/Cl\n        # eps = 0\n\n        a = (1 + F*np.sin(phi)**2/(lambda_coef*(np.cos(phi) + eps*np.sin(phi))))**(-1)\n        a_dash = (-1 + F*np.sin(phi)*np.cos(phi)/(lambda_coef*(np.sin(phi) - eps*np.cos(phi))))**(-1)\n\n        a_conv.append(a)\n        adash_conv.append(a_dash)\n        alpha_conv.append(alpha)\n\n\n        epsilon = ((a - prev_a) ** 2 + (a_dash - prev_a_dash) ** 2) ** 0.5\n        if epsilon &lt; conv_limit:\n            break\n    if it ==imax:\n        print('not converged')\n\n    return alpha,a,a_dash,F,eps, a_conv,adash_conv,alpha_conv\n</code></pre>"},{"location":"reference/source/BEM.html#src.prepost.source.BEM.hemant3","title":"<code>hemant3(Cl_tck, Cd_tck, Re, J, R, r, twist, c, Uinf, Urot)</code>","text":"Source code in <code>src/prepost/source/BEM.py</code> <pre><code>def hemant3(Cl_tck,Cd_tck,Re,J,R,r,twist,c,Uinf,Urot):\n    nu0 = 1.45e-5  \n    a = 0\n    a_dash = 0\n    conv_limit = 1e-6\n    imax = 99\n    Z = 3\n    a = 0; a_dash = 0\n    F = 2 / np.pi * np.arccos(np.exp(-(3 / 2) * (1 - r/ R) * (1 + J ** 2) ** 0.5))\n    a_conv = []\n    adash_conv = []\n    alpha_conv = []\n    for it in range(imax):\n        prev_a = a; prev_a_dash = a_dash\n\n        phi = np.arctan2(R/(r*J) * (1 - a * F) / (1 + a_dash), 1)\n        alpha = (phi - np.pi/2 + twist)\n        Cl = interp.bisplev(np.array([Re]),np.array([alpha])* 180 / np.pi,Cl_tck)\n        Cd = interp.bisplev(np.array([Re]),np.array([alpha])* 180 / np.pi,Cd_tck)\n        # F = 2/np.pi * np.arccos(np.exp(-3*(1 - r/R)/(2*np.sin(phi))))\n        lambda_coef = Z * c* Cl / (8 * np.pi * r)\n        eps = Cd/Cl\n        # eps = 0\n\n        a = (1 + F*np.sin(phi)**2/(lambda_coef*(np.cos(phi) + eps*np.sin(phi))))**(-1)\n        a_dash = (-1 + F*np.sin(phi)*np.cos(phi)/(lambda_coef*(np.sin(phi) - eps*np.cos(phi))))**(-1)\n\n        a_conv.append(a)\n        adash_conv.append(a_dash)\n        alpha_conv.append(alpha)\n\n        U_rel= np.sqrt((Uinf* (1 - F * a)) ** 2 + (Urot * (1 + a_dash)) ** 2)\n        Re = U_rel* c / nu0\n\n\n        epsilon = ((a - prev_a) ** 2 + (a_dash - prev_a_dash) ** 2) ** 0.5\n        if epsilon &lt; conv_limit:\n            break\n    if it ==imax:\n        print('not converged')\n\n    return alpha,a,a_dash,F,eps, a_conv,adash_conv, alpha_conv\n</code></pre>"},{"location":"reference/source/BEM.html#src.prepost.source.BEM.noBEM","title":"<code>noBEM(Cl_tck, Cd_tck, Re, J, R, r, twist, c)</code>","text":"Source code in <code>src/prepost/source/BEM.py</code> <pre><code>def noBEM(Cl_tck,Cd_tck,Re,J,R,r,twist,c):\n    a = 0; a_dash = 0\n    phi = np.arctan2(R/(r*J), 1)\n    alpha = (phi - np.pi/2 + twist)\n    eps = 0\n    F = 1\n    return alpha,a,a_dash,F,eps\n</code></pre>"},{"location":"reference/source/WP_Goody.html","title":"Reference for <code>prepost/source/WP_Goody.py</code>","text":""},{"location":"reference/source/WP_Goody.html#src.prepost.source.WP_Goody.WP_Goody","title":"<code>WP_Goody(frequ, delta_star, theta_momen, cf, UeUinf, U_rota)</code>","text":"<p>Compute the wall pressure spectra (WPS) using the Goody model.</p> <p>This function calculates the wall pressure spectra (Phi_pp1) and the  normalized WPS (Phi_pp2) (U^3delta_starrho^2) based on boundary layer properties, wall shear stress, and turbulent boundary layer thickness.</p> <p>Parameters:</p> <ul> <li> <code>frequ</code>               (<code>ndarray</code>)           \u2013            <p>Frequency array in Hz.</p> </li> <li> <code>delta_star</code>               (<code>float</code>)           \u2013            <p>Displacement thickness of the boundary layer.</p> </li> <li> <code>theta_momen</code>               (<code>float</code>)           \u2013            <p>Momentum thickness of the boundary layer.</p> </li> <li> <code>cf</code>               (<code>float</code>)           \u2013            <p>Skin friction coefficient.</p> </li> <li> <code>UeUinf</code>               (<code>float</code>)           \u2013            <p>Ratio of edge velocity to free stream velocity.</p> </li> <li> <code>U_rota</code>               (<code>float</code>)           \u2013            <p>Rotational velocity of the blade.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>tuple[ndarray, ndarray]</code>           \u2013            <p>tuple[np.ndarray, np.ndarray]:  - Phi_pp1 (np.ndarray): Wall pressure spectra. - Phi_pp2 (np.ndarray): Normalized wall pressure spectra.</p> </li> </ul> Source code in <code>src/prepost/source/WP_Goody.py</code> <pre><code>def WP_Goody(frequ: np.ndarray, delta_star: float, theta_momen: float, \n             cf: float, UeUinf: float, U_rota: float) -&gt; tuple[np.ndarray, np.ndarray]:\n    \"\"\"\n    Compute the wall pressure spectra (WPS) using the Goody model.\n\n    This function calculates the wall pressure spectra (Phi_pp1) and the \n    normalized WPS (Phi_pp2) (U^3*delta_star*rho^2) based on boundary layer properties, wall shear stress,\n    and turbulent boundary layer thickness.\n\n    Args:\n        frequ (np.ndarray): Frequency array in Hz.\n        delta_star (float): Displacement thickness of the boundary layer.\n        theta_momen (float): Momentum thickness of the boundary layer.\n        cf (float): Skin friction coefficient.\n        UeUinf (float): Ratio of edge velocity to free stream velocity.\n        U_rota (float): Rotational velocity of the blade.\n\n    Returns:\n        tuple[np.ndarray, np.ndarray]: \n            - Phi_pp1 (np.ndarray): Wall pressure spectra.\n            - Phi_pp2 (np.ndarray): Normalized wall pressure spectra.\n    \"\"\"\n\n    nu0 = 1.45e-5\n    rho0 = 1.225\n\n    Ue = U_rota * np.abs(UeUinf)\n    Const1 = 0.5\n    Const2 = 3\n\n    # Re_c = U*c(index)/nu\n    # delta = c(index)*0.382/(U*c(index)/nu)^0.2\n    # delta_star = c(index)*0.047*Re_c^-0.2\n    # tau_w = 0.0233*rho*Uc^2*(nu/Uc/delta)^0.25\n    # u_star = sqrt(tau_w/rho)\n\n\n    H = delta_star / theta_momen\n    delta = theta_momen * (3.15 + 1.72 / (H - 1)) + delta_star                     #Boundary layer thickness (also Drela 1986 paper )\n    # tau_w = abs(cf)*0.5* 1.225*U_rota^2;%Pa wall share stress\n    # use Ue instead of U_rota for wall shear stress\n    tau_w = np.abs(cf) * 0.5 * 1.225 * Ue ** 2                                     # wall share stress\n    u_star = np.sqrt(tau_w / rho0)\n    R_T = (delta / Ue)/(nu0 / u_star ** 2)\n    Const3 = 1.1 * R_T ** (-0.57)\n    omega_tilta = 2 * np.pi * frequ * delta / Ue\n    Phi_pp1 = tau_w ** 2 * delta * Const2 * omega_tilta ** 2 / ((omega_tilta ** 0.75 + Const1) ** 3.7 + (Const3 * omega_tilta) ** 7) / Ue\n    # Phi_pp2 = Phi_pp1/rho^2/delta/U^3;\n    Phi_pp2 = Phi_pp1 * Ue / tau_w ** 2 / delta\n\n    return Phi_pp1, Phi_pp2\n</code></pre>"},{"location":"reference/source/WP_LEE.html","title":"Reference for <code>prepost/source/WP_LEE.py</code>","text":""},{"location":"reference/source/WP_LEE.html#src.prepost.source.WP_LEE.WP_LEE","title":"<code>WP_LEE(freq, delta_star, theta_momen, dpdx, cf, UeUinf, Uinf)</code>","text":"<p>Compute the wall pressure spectrum (WPS) using the Lee et al. (2018) model.</p> <p>This function estimates the wall pressure spectrum based on boundary layer properties,  external velocity, wall shear stress, and pressure gradients using the Lee model.</p> <p>Parameters:</p> <ul> <li> <code>freq</code>               (<code>ndarray</code>)           \u2013            <p>Frequency array in Hz.</p> </li> <li> <code>delta_star</code>               (<code>float</code>)           \u2013            <p>Displacement thickness of the boundary layer.</p> </li> <li> <code>theta_momen</code>               (<code>float</code>)           \u2013            <p>Momentum thickness of the boundary layer.</p> </li> <li> <code>dpdx</code>               (<code>float</code>)           \u2013            <p>Pressure gradient in the streamwise direction.</p> </li> <li> <code>cf</code>               (<code>float</code>)           \u2013            <p>Skin friction coefficient.</p> </li> <li> <code>UeUinf</code>               (<code>float</code>)           \u2013            <p>Ratio of external velocity to free-stream velocity.</p> </li> <li> <code>Uinf</code>               (<code>float</code>)           \u2013            <p>Free-stream velocity (m/s).</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>tuple[ndarray, ndarray]</code>           \u2013            <p>tuple[np.ndarray, np.ndarray]:  - Phipp_LEE (np.ndarray): Wall pressure spectrum in physical units. - Phipp_LEE_adim (np.ndarray): Non-dimensional wall pressure spectrum.</p> </li> </ul> Source code in <code>src/prepost/source/WP_LEE.py</code> <pre><code>def WP_LEE(freq: np.ndarray, delta_star: float, theta_momen: float, \n           dpdx: float, cf: float, UeUinf: float, Uinf: float) -&gt; tuple[np.ndarray, np.ndarray]:\n    \"\"\"\n    Compute the wall pressure spectrum (WPS) using the Lee et al. (2018) model.\n\n    This function estimates the wall pressure spectrum based on boundary layer properties, \n    external velocity, wall shear stress, and pressure gradients using the Lee model.\n\n    Args:\n        freq (np.ndarray): Frequency array in Hz.\n        delta_star (float): Displacement thickness of the boundary layer.\n        theta_momen (float): Momentum thickness of the boundary layer.\n        dpdx (float): Pressure gradient in the streamwise direction.\n        cf (float): Skin friction coefficient.\n        UeUinf (float): Ratio of external velocity to free-stream velocity.\n        Uinf (float): Free-stream velocity (m/s).\n\n    Returns:\n        tuple[np.ndarray, np.ndarray]: \n            - Phipp_LEE (np.ndarray): Wall pressure spectrum in physical units.\n            - Phipp_LEE_adim (np.ndarray): Non-dimensional wall pressure spectrum.\n    \"\"\"\n    # global rho0 nu0\n    rho0 = 1.225\n    nu0 = 1.45e-5\n\n    # % WPS model of Lee et al. (2018)\n    #calculate input parameters for the LEE model\n    Ue = Uinf * np.abs(UeUinf)                                                 # external velocity (m)\n    tau_w = np.abs(cf) * 0.5 * rho0 * Ue ** 2                                  # wall shear stress (Pa)\n    tau_max = tau_w                                                            # maximum shear stress (Pa)\n    H = delta_star / theta_momen                                               # shape factor\n    u_star = np.sqrt(tau_w / rho0)                                             # friction velocity (m/s)\n    delta = theta_momen * (3.15 + 1.72 / (H-1)) + delta_star                   # BL thickness (Drela 1986 paper)\n    beta_c = theta_momen / tau_w * np.abs(dpdx)                                # Clauser parameter\n\n    Delta = delta / delta_star  \n    if Delta&lt;0:\n        logging.warning('negative value of Delta')   \n\n    PI_Lee = 0.8 * (beta_c + 0.5) ** (3/4)\n    e_Lee=  3.7 + 1.5 * beta_c\n    d_Lee = 4.76 * ((1.4 / Delta) ** 0.75) * (0.375 * e_Lee - 1)\n\n    R_T = (delta / Ue) / (nu0 / u_star ** 2)                                   # ratio of outer to inner boundary layer time scales\n    a_Lee = 2.82 * Delta ** 2 * ((6.13 * (Delta ** (-0.75))+ d_Lee) ** e_Lee) * (4.2 * PI_Lee / Delta + 1)\n    hstar_Lee= min(3, (0.139 + 3.1043 * beta_c)) + 7\n    if beta_c &lt; 0.5:\n        dstar_Lee = max(1.0, 1.5 * d_Lee)\n    else:\n        dstar_Lee = d_Lee\n\n    # non-dimensional angular frequency\n    omega_adim = 2 * np.pi * freq * delta_star / Ue                           \n\n    #wall pressure spectrun in dimensional and non-dimensional forms LEE et al\n    Phipp_LEE_adim = (max(a_Lee, (0.25 * beta_c - 0.52) * a_Lee) * omega_adim ** 2) / ((4.76 * omega_adim ** 0.75 + dstar_Lee) ** e_Lee +(omega_adim * 8.8 * R_T ** (-0.57)) ** hstar_Lee)\n    Phipp_LEE = tau_max ** 2 * delta_star / Ue * Phipp_LEE_adim\n\n    return Phipp_LEE, Phipp_LEE_adim\n</code></pre>"},{"location":"reference/source/atmos.html","title":"Reference for <code>prepost/source/atmos.py</code>","text":""},{"location":"reference/source/atmos.html#src.prepost.source.atmos.Atmosphere","title":"<code>Atmosphere()</code>","text":"<p>Class to read and used ABL data from LES.  The class provides methods to read velocity and temperature profile from LES. to define generic velocity profile.  The class also providess function to compute the turbulence dissipation rate \\(\\epsilon\\) from the LES data</p> <p>Warning</p> <p>this is legacy code.  It is not used anymore in the <code>Source</code> class and is replaced by the <code>Les</code> class instead.  This was used when only a vertical profile was used as input for the source model.  Now an interpolation from the 3D les data is perfomed for each segment and blade position.  Maybe a different approach could be implememented where the flow data are given already interpolated  to the <code>Source</code> class in order to make the two class less intricated.</p> Source code in <code>src/prepost/source/atmos.py</code> <pre><code>def __init__(self):\n    return\n</code></pre>"},{"location":"reference/source/fresnelCS.html","title":"Reference for <code>prepost/source/fresnelCS.py</code>","text":""},{"location":"reference/source/fresnelCS.html#src.prepost.source.fresnelCS.fresnelCS","title":"<code>fresnelCS(y)</code>","text":"Source code in <code>src/prepost/source/fresnelCS.py</code> <pre><code>def fresnelCS(y):\n    eps = 2.2204e-16\n    # This function calculates the fresnel cosine and sine integrals.\n    # Input:\n    # y = values for which fresnel integrals have to be evaluated\n    #\n    # Output:\n    # FresnelC = fresnel cosine integral of y\n    # FresnelS = fresnel sine integral of y\n    #\n    # Adapted from:\n    # Atlas for computing mathematical functions : an illustrated guide for\n    # practitioners, with programs in C and Mathematica / William J. Thompson.\n    # New York : Wiley, c1997.\n    #\n    # Author: Venkata Sivakanth Telasula\n    # email: sivakanth.telasula@gmail.com\n    # date: August 11, 2005\n\n    fn = [0.49999988085884732562, 1.3511177791210715095, \\\n          1.3175407836168659241, 1.1861149300293854992, \\\n          0.7709627298888346769, 0.4173874338787963957, \\\n          0.19044202705272903923, 0.06655998896627697537, \\\n          0.022789258616785717418, 0.0040116689358507943804, \\\n          0.0012192036851249883877]\n\n    fd = [1.0, 2.7022305772400260215, \\\n          4.2059268151438492767, 4.5221882840107715516, \\\n          3.7240352281630359588, 2.4589286254678152943, \\\n          1.3125491629443702962, 0.5997685720120932908, \\\n          0.20907680750378849485, 0.07159621634657901433, \\\n          0.012602969513793714191, 0.0038302423512931250065]\n\n    gn = [0.50000014392706344801, 0.032346434925349128728, \\\n          0.17619325157863254363, 0.038606273170706486252, \\\n          0.023693692309257725361, 0.007092018516845033662, \\\n          0.0012492123212412087428, 0.00044023040894778468486, \\\n         -8.80266827476172521e-6, -1.4033554916580018648e-8, \\\n          2.3509221782155474353e-10]\n\n    gd  = [1.0, 2.0646987497019598937, 2.9109311766948031235, \\\n           2.6561936751333032911, 2.0195563983177268073, \\\n           1.1167891129189363902, 0.57267874755973172715, \\\n           0.19408481169593070798, 0.07634808341431248904, \\\n           0.011573247407207865977, 0.0044099273693067311209, \\\n          -0.00009070958410429993314]\n\n    FresnelC = np.zeros((y.shape[0], y.shape[1]))\n    FresnelS = np.zeros((y.shape[0], y.shape[1]))\n    for j1 in range(y.shape[0]):\n        for j2 in range(y.shape[1]):\n            x = y[j1, j2]\n            if  x &lt; 1.0: \n                t = -(np.pi / 2 * x * x) ** 2\n\n                #/* Cosine integral series */\n                twofn = 0.0; fact = 1.0; denterm = 1.0; numterm = 1.0; summation = 1.0; ratio = 10.0 \n\n                while ratio &gt; eps:\n                    twofn = twofn + 2.0\n                    fact = fact * twofn * (twofn - 1.0)\n                    denterm = denterm + 4.0\n                    numterm = numterm * t\n                    term = numterm / (fact * denterm)\n                    summation = summation + term\n                    ratio = np.abs(term / summation)\n\n                FresnelC[j1, j2] =  x * summation\n\n                #/* Sine integral series */\n                twofn = 1.0; fact = 1.0; denterm = 3.0; numterm = 1.0; summation = 1.0 / 3.0; ratio = 10.0\n\n                while ratio &gt; eps:\n                    twofn = twofn + 2.0\n                    fact = fact * twofn * (twofn - 1.0)\n                    denterm = denterm + 4.0\n                    numterm = numterm * t\n                    term = numterm / (fact * denterm)\n                    summation = summation + term\n                    ratio = np.abs(term / summation)\n\n                FresnelS[j1, j2] =  np.pi / 2 * x * x * x * summation\n\n            elif x &lt; 6.0:\n                #  \t{ /* Rational approximation for  f   */\n                sumn =  0.0\n                sumd =  fd[11]\n                for k in reversed(range(11)):\n                    sumn = fn[k] + x * sumn\n                    sumd = fd[k] + x * sumd\n\n                f = sumn / sumd\n                #/* Rational approximation for  g   */\n                sumn =  0.0\n                sumd =  gd[11]\n                for k in reversed(range(11)):\n                     sumn = gn[k] + x * sumn\n                     sumd = gd[k] + x * sumd\n                g = sumn / sumd\n                U = np.pi / 2 * x * x\n\n                SinU = np.sin(U)\n                CosU = np.cos(U)\n                FresnelC[j1 ,j2] = 0.5 + f * SinU - g * CosU\n                FresnelS[j1, j2] = 0.5 - f * CosU - g * SinU\n\n            else:\n\n        #  /* x &gt;= 6; asymptotic expansions for  f  and  g */\n                t = -(np.pi * x * x) ** (-2.0)\n        #  \t/* Expansion for  f   */\n                numterm = -1.0; term = 1.0; summation = 1.0; oldterm = 1.0; ratio = 10.0; eps10 = 0.1 * eps        \n                while ratio &gt; eps10:\n                    numterm = numterm + 4.0\n                    term = term * numterm * (numterm - 2.0) * t\n                    summation = summation + term\n                    absterm = np.abs(term)\n                    ratio = np.abs(term / summation)\n                    if oldterm &lt; absterm:\n                        print('\\n\\n !!In FresnelCS f not converged to eps')\n                        ratio = eps10\n                    oldterm = absterm\n\n                f = summation / (np.pi * x)\n            #   /* Expansion for  g   */\n                numterm = -1.0; term = 1.0; summation = 1.0; oldterm = 1.0;\tratio = 10.0; eps10 = 0.1*eps\n\n                while ratio &gt; eps10:\n                    numterm = numterm + 4.0\n                    term = term * numterm * (numterm + 2.0) * t\n                    summation = summation + term\n                    absterm = np.abs(term)\n                    ratio = np.abs(term / summation)\n\n                    if oldterm &lt; absterm:\n                        print('\\n\\n!!In FresnelCS g not converged to eps')\n                        ratio = eps10\n\n                    oldterm = absterm\n\n                g = summation / ((np.pi * x) ** 2 * x)\n                U = np.pi / 2 * x * x\n                SinU = np.sin(U)\n                CosU = np.cos(U)\n                FresnelC[j1, j2] = 0.5 + f * SinU - g * CosU\n                FresnelS[j1, j2] = 0.5 - f * CosU - g * SinU\n\n    return FresnelC, FresnelS\n</code></pre>"},{"location":"reference/source/func_repo_XFOIL.html","title":"Reference for <code>prepost/source/func_repo_XFOIL.py</code>","text":""},{"location":"reference/source/func_repo_XFOIL.html#src.prepost.source.func_repo_XFOIL.c_round","title":"<code>c_round(temp)</code>","text":"Source code in <code>src/prepost/source/func_repo_XFOIL.py</code> <pre><code>def c_round(temp):\n    return np.round(temp * 10 ** 6) / 10 ** 6\n</code></pre>"},{"location":"reference/source/func_repo_XFOIL.html#src.prepost.source.func_repo_XFOIL.XFOIL_pre","title":"<code>XFOIL_pre(inf, foil, path)</code>","text":"<p>Create thye Xoil prompt to be run in order to obtain data for a given airfoile profile, alpha</p> <p>Parameters:</p> <ul> <li> <code>inf</code>               (<code>dict</code>)           \u2013            <p>dictionary containing the flow input</p> </li> <li> <code>foil</code>               (<code>dict</code>)           \u2013            <p>dictionary containing thea airfoil input </p> </li> <li> <code>path</code>               (<code>str</code>)           \u2013            <p>ath to write and read the metadata</p> </li> </ul> Source code in <code>src/prepost/source/func_repo_XFOIL.py</code> <pre><code>def XFOIL_pre(inf:dict, foil:dict, path:str):\n    \"\"\"Create thye Xoil prompt to be run in order to obtain data for a given airfoile profile, alpha\n\n    Args:\n        inf (dict): dictionary containing the flow input\n        foil (dict): dictionary containing thea airfoil input \n        path (str): ath to write and read the metadata\n    \"\"\"\n    rho_inf = inf['rho']; nu_inf = inf['nu']; T_inf = inf['T']\n    foil_name = foil['name']; foil_chord = foil['chord']; foil_re = foil['re']; foil_mach = foil['mach']; foil_aoa = foil['AoA']; foil_trip_top = foil['trip_top']; foil_trip_bottom = foil['trip_bottom']\n    U_inf = foil_mach * (1.4 * 287 * T_inf) ** 0.5\n\n\n\n    if os.path.isfile(path + \"metadata1.dat\"):\n        os.remove(path + \"metadata1.dat\")\n    if os.path.isfile(path + \"metadata2.dat\"):\n        os.remove(path + \"metadata2.dat\")\n    if os.path.isfile(path + \"metadata3.dat\"):\n        os.remove(path + \"metadata3.dat\")\n    if os.path.isfile(\"xfoil_driver.txt\"):\n        os.remove(\"xfoil_driver.txt\")\n\n    #for the development of the xfoil_driver file\n    outfile  = open(\"xfoil_driver.txt\", mode = \"w\")\n    # outfile.write(\"PLOP\\nG F\\n\\n\")\n    outfile.write(\"LOAD \" + str(foil_name) + \"\\n\")\n    # outfile.write(\"63415\\n\")\n    outfile.write(\"GDES\\nGSET\\nSCAL\\n\" + str(foil_chord) + \"\\nEXEC\\nGSET\\n\\n\")\n    # outfile.write(\"PPAR\\nN 200\\n t 0.8\\n\\n\\n\")\n    outfile.write(\"PPAR\\nN 200\\n\\n\\n\")\n\n    # \n    outfile.write(\"OPER\\n\")\n    outfile.write(\"VPAR\\n\")\n\n    # outfile.write(\"N 1\\n\\n\")\n\n    outfile.write(\"XTR\\n%s\\n%s\\n\\n\"%(foil_trip_top,foil_trip_bottom))\n    outfile.write(\"ITER\\n%s\\n\"%(400))\n    outfile.write(\"VISC\\n%s\\n\"%(foil_re))\n    outfile.write(\"M\\n%s\\n\"%(foil_mach))\n\n    #outfile.write(\"OPER\\nRE \" + str(foil_re) + \"\\nM \" + str(foil_mach) + \"\\nITER 400\\nVISC\\nVPAR\\nXTR\\n\" + str(foil_trip_top) + \"\\n\" + str(foil_trip_bottom) + \"\\n\\n\")\n    #outfile.write(\"OPER\\nRE \" + str(foil_re) + \"\\nM \" + str(foil_mach) + \"\\nITER 400\\nVISC\\nVPAR\\n\\n\")\n\n    outfile.write(\"pacc\\n\")\n    outfile.write(path+\"metadata3.dat\\n\\n\")\n    # outfile.write(\"ALFA 1 \\n\")\n    outfile.write(\"ALFA  1\\n\")\n    outfile.write(\"ALFA \" + str(foil_aoa) + \"\\n\")\n    outfile.write(\"pacc\\n\")\n    outfile.write(\"DUMP \" +path+\"metadata1.dat\\n\")\n    outfile.write(\"CPWR \" + path+\"metadata2.dat\\n\\n\")\n    outfile.write(\"QUIT\\n\")\n    outfile.close()\n</code></pre>"},{"location":"reference/source/func_repo_XFOIL.html#src.prepost.source.func_repo_XFOIL.run_Xvfb","title":"<code>run_Xvfb(n=5)</code>","text":"<p>create a X virtual buffer to run xfoil wthout the frame popping</p> <p>Parameters:</p> <ul> <li> <code>n</code>               (<code>int</code>, default:                   <code>5</code> )           \u2013            <p>token of the fram buffer (could be set to anything I think). Defaults to 5.</p> </li> </ul> Source code in <code>src/prepost/source/func_repo_XFOIL.py</code> <pre><code>def run_Xvfb(n=5):\n    \"\"\"  create a X virtual buffer to run xfoil wthout the frame popping\n\n    Args:\n        n (int, optional): token of the fram buffer (could be set to anything I think). Defaults to 5.\n    \"\"\"\n    os.system(\"Xvfb :\"+str(n)+\" &amp;\")\n</code></pre>"},{"location":"reference/source/func_repo_XFOIL.html#src.prepost.source.func_repo_XFOIL.XFOIL_run","title":"<code>XFOIL_run(n=5)</code>","text":"<p>Ryun xfoil inside the virtual buffer </p> <p>Parameters:</p> <ul> <li> <code>n</code>               (<code>int</code>, default:                   <code>5</code> )           \u2013            <p>must be set to the same as in  <code>run_Xvfb</code>. Defaults to 5.</p> </li> </ul> Source code in <code>src/prepost/source/func_repo_XFOIL.py</code> <pre><code>def XFOIL_run(n=5):\n    \"\"\"Ryun xfoil inside the virtual buffer \n\n    Args:\n        n (int, optional): must be set to the same as in  `run_Xvfb`. Defaults to 5.\n    \"\"\"\n    os.system(\"DISPLAY=:\"+str(5) +\" xfoil &lt; xfoil_driver.txt\")\n</code></pre>"},{"location":"reference/source/func_repo_XFOIL.html#src.prepost.source.func_repo_XFOIL.kill_Xvfb","title":"<code>kill_Xvfb()</code>","text":"<p>kill all virtual buffers.</p> Source code in <code>src/prepost/source/func_repo_XFOIL.py</code> <pre><code>def kill_Xvfb():\n    \"\"\"kill all virtual buffers. \n    \"\"\"\n    os.system(\"kill $!\")\n</code></pre>"},{"location":"reference/source/func_repo_XFOIL.html#src.prepost.source.func_repo_XFOIL.XFOIL_post","title":"<code>XFOIL_post(path)</code>","text":"<p>read and create interpoland from boundary layer quantities writen in metadata1 and metadata2</p> <p>Parameters:</p> <ul> <li> <code>path</code>               (<code>str</code>)           \u2013            <p>path where to read BL quantities </p> </li> </ul> <p>Returns:</p> <ul> <li>           \u2013            <p>tuple[dict,int]: dictionary of interpoland for BL quantities, success flag</p> </li> </ul> Source code in <code>src/prepost/source/func_repo_XFOIL.py</code> <pre><code>def XFOIL_post(path:str):\n    \"\"\"read and create interpoland from boundary layer quantities writen in metadata1 and metadata2\n\n    Args:\n        path (str): path where to read BL quantities \n\n    Returns:\n        tuple[dict,int]: dictionary of interpoland for BL quantities, success flag\n    \"\"\"\n    # read metada1.dat\n    if os.path.isfile(path + '/metadata1.dat'):\n        run_flag = 1\n        #now for reading the required data from the metadata1/2.dat files\n        final_data = {}\n        final_data['x'] = []; final_data['x_cp'] = []; final_data['cf'] = []; final_data['Ue'] = []; final_data['Dstar'] = []; final_data['theta'] = []; final_data['cp'] = []\n        file_name = path + \"metadata1.dat\"\n        infile = open(file_name, mode = \"r+\")\n        data_in = infile.read()\n        data_in = data_in.split(\"\\n\")\n        # read data line by line\n        for temp in range(len(data_in) - 2):\n            temp_array = data_in[temp + 1].split(' ')\n            repo = []\n            for temp1 in range(len(temp_array)):\n                if temp_array[temp1] != '':\n                    repo.append(float(temp_array[temp1]))\n            final_data['x'].append(repo[1])\n            final_data['Ue'].append(repo[3])\n            final_data['Dstar'].append(repo[4])\n            final_data['theta'].append(repo[5])\n            final_data['cf'].append(repo[6])\n        infile.close()\n\n        # read metadata 2\n        file_name = path + \"metadata2.dat\"\n        infile = open(file_name, mode = \"r+\")\n        data_in = infile.read()\n        data_in = data_in.split(\"\\n\")\n        # read data line by line \n        for temp in range(len(data_in) - 4):\n            temp_array = data_in[temp + 3].split(' ')\n            repo = []\n            for temp1 in range(len(temp_array)):\n                if temp_array[temp1] != '':\n                    repo.append(float(temp_array[temp1]))\n            final_data['cp'].append(repo[-1])\n            final_data['x_cp'].append(repo[0])\n        infile.close()\n\n        #for the fitting of splines between the stored data\n        #for Dstar, theta and edge velocity\n        # find leading edge index \n        for temp in range(len(final_data['x'])):\n            if final_data['x'][temp] &lt; final_data['x'][temp + 1]:\n                break\n        LE_index = temp\n        tck_dict = {}\n\n        # create BL interpoland \n        tck_dict['Ue_suction'] = interp.splrep(final_data['x'][: LE_index][::-1], final_data['Ue'][: LE_index][::-1], k = 2)\n        tck_dict['Dstar_suction'] = interp.splrep(final_data['x'][: LE_index][::-1], final_data['Dstar'][: LE_index][::-1], k = 2)\n        tck_dict['theta_suction'] = interp.splrep(final_data['x'][: LE_index][::-1], final_data['theta'][: LE_index][::-1], k = 2)\n        tck_dict['Cf_suction'] = interp.splrep(final_data['x'][: LE_index][::-1], final_data['cf'][: LE_index][::-1], k = 2)\n\n        tck_dict['Ue_pressure'] = interp.splrep(final_data['x'][LE_index + 1 : ], final_data['Ue'][LE_index + 1 : ], k = 2)\n        tck_dict['Dstar_pressure'] = interp.splrep(final_data['x'][LE_index + 1 : ], final_data['Dstar'][LE_index + 1 : ], k = 2)\n        tck_dict['theta_pressure'] = interp.splrep(final_data['x'][LE_index + 1 : ], final_data['theta'][LE_index + 1 : ], k = 2)\n        tck_dict['Cf_pressure'] = interp.splrep(final_data['x'][LE_index + 1 : ], final_data['cf'][LE_index + 1 : ], k = 2)\n\n        #for the coefficient of pressure\n        # find leading edge index \n        for temp in range(len(final_data['x_cp'])):\n            if final_data['x_cp'][temp] &lt; final_data['x_cp'][temp + 1]:\n                break\n        LE_index_cp = temp\n        tck_dict['cp_suction'] = interp.splrep(final_data['x_cp'][: LE_index_cp][::-1], final_data['cp'][: LE_index_cp][::-1], k = 2)\n        tck_dict['cp_pressure'] = interp.splrep(final_data['x_cp'][LE_index_cp + 1 : ], final_data['cp'][LE_index_cp + 1 : ], k = 2)\n    else:\n        run_flag = 0\n        print('No result generated!!!!')\n        tck_dict = {}\n\n    return tck_dict, run_flag\n</code></pre>"},{"location":"reference/source/func_repo_XFOIL.html#src.prepost.source.func_repo_XFOIL.XFOIL_post2","title":"<code>XFOIL_post2(path)</code>","text":"<p>read polar from metadata3.dat</p> <p>Parameters:</p> <ul> <li> <code>path</code>               (<code>str</code>)           \u2013            <p>path to metadata files</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ndarray</code>           \u2013            <p>np.ndarray: array containing AoA, CL and CD coeff</p> </li> </ul> Source code in <code>src/prepost/source/func_repo_XFOIL.py</code> <pre><code>def XFOIL_post2(path:str)-&gt;np.ndarray:\n    \"\"\"read polar from metadata3.dat\n\n    Args:\n        path (str): path to metadata files\n\n    Returns:\n        np.ndarray: array containing AoA, CL and CD coeff \n    \"\"\"\n    file_name = path + 'metadata3.dat'\n    infile = open(file_name, mode = \"r+\")\n    data_in = infile.read()\n    data_in = data_in.split(\"\\n\")\n\n    row_offset = 13\n    iline = 0\n    aoa = []; Cl = []; Cd=[]\n    while data_in[iline + row_offset] != '':\n        temp_array = data_in[iline + row_offset].split(' ')\n        ichar = 0\n        aoa_flag = 0; Cl_flag = 0;Cd_flag=0\n        while Cd_flag == 0:\n            if temp_array[ichar] != '' and aoa_flag == 0:\n                aoa.append(float(temp_array[ichar]))\n                aoa_flag = 1\n                ichar = ichar + 1\n            elif temp_array[ichar] != '' and Cl_flag == 0 and aoa_flag ==1:\n                Cl.append(float(temp_array[ichar]))\n                Cl_flag = 1\n                ichar = ichar + 1\n            elif temp_array[ichar] != '' and Cl_flag == 1:\n                Cd.append(float(temp_array[ichar]))\n                Cd_flag = 1\n                ichar = ichar + 1\n            elif temp_array[ichar] == '':\n                ichar = ichar + 1\n        iline = iline + 1\n    # tck_polar = interp.splrep(aoa, Cl, k = 2)\n    # return tck_polar\n\n    # remove metadata file (needed for newt run )\n    return np.array(np.squeeze([aoa,Cl,Cd]))\n</code></pre>"},{"location":"reference/source/func_repo_XFOIL.html#src.prepost.source.func_repo_XFOIL.XFOIL_mp","title":"<code>XFOIL_mp(inf, foil, path)</code>","text":"<p>run xfoil, check if time limit is reached. if xfoil dont converge after 10s: break</p> <p>Parameters:</p> <ul> <li> <code>inf</code>               (<code>dict</code>)           \u2013            <p>dictionary containing the flow input</p> </li> <li> <code>foil</code>               (<code>dict</code>)           \u2013            <p>dictionary containing thea airfoil input </p> </li> <li> <code>path</code>               (<code>str</code>)           \u2013            <p>ath to write and read the metadata</p> </li> </ul> Source code in <code>src/prepost/source/func_repo_XFOIL.py</code> <pre><code>def XFOIL_mp(inf:dict, foil:dict,path:str):\n    \"\"\"run xfoil, check if time limit is reached. if xfoil dont converge after 10s: break\n\n    Args:\n        inf (dict): dictionary containing the flow input\n        foil (dict): dictionary containing thea airfoil input \n        path (str): ath to write and read the metadata\n    \"\"\"\n    # create prompt to input in xfoil \n    XFOIL_pre(inf, foil,path)\n    # run xfoil \n    try:\n        doitReturnValue = func_timeout(10, XFOIL_run)\n        print(\"XFOIL has converged satisfactorily!!\")\n    except FunctionTimedOut:\n        os.system(\"TASKKILL /F /IM xfoil.exe\")\n        print(\"XFOIL has timed out!!!\")\n</code></pre>"},{"location":"reference/source/func_repo_XFOIL.html#src.prepost.source.func_repo_XFOIL.XFOIL","title":"<code>XFOIL(path, target_frac, inf, foil)</code>","text":"<p>create prompt, launch Xcode and return values of interest acording at the given target fraction of the chord (closest to the trailing edge)</p> <p>Parameters:</p> <ul> <li> <code>path</code>               (<code>str</code>)           \u2013            <p>path to write and read the metadata</p> </li> <li> <code>target_frac</code>               (<code>float</code>)           \u2013            <p>fraction of the chord to measure the BL quantities</p> </li> <li> <code>inf</code>               (<code>dict</code>)           \u2013            <p>dictionary containing the flow input</p> </li> <li> <code>foil</code>               (<code>dict</code>)           \u2013            <p>dictionary containing thea airfoil input </p> </li> </ul> <p>Returns:</p> <ul> <li>           \u2013            <p>tuple[dict,np.ndarray]: outdir contains boundary layer quantities, polar contains the lift and drag coeeficient</p> </li> </ul> Source code in <code>src/prepost/source/func_repo_XFOIL.py</code> <pre><code>def XFOIL(path:str, target_frac:float, inf:dict, foil:dict):\n    \"\"\"create prompt, launch Xcode and return values of interest acording at the given target fraction of the chord (closest to the trailing edge)\n\n\n    Args:\n        path (str): path to write and read the metadata\n        target_frac (float): fraction of the chord to measure the BL quantities\n        inf (dict): dictionary containing the flow input\n        foil (dict): dictionary containing thea airfoil input \n\n    Returns:\n        tuple[dict,np.ndarray]: outdir contains boundary layer quantities, polar contains the lift and drag coeeficient \n    \"\"\"\n    # compute dynamic pressur ?? dont know why \n    dyn_press = 0.5 * inf['rho'] * (inf['mach'] * (1.4 * 287 * inf['T']) ** 0.5) ** 2\n    out_dict = {}\n\n    # create directory to save data file from xfoil \n    if not os.path.exists(path):\n        os.makedirs(path)\n\n    # run Xfoil, check if function timed out \n    XFOIL_mp(inf, foil,path)\n\n    # read data and post process data from X foil \n    tck_dict, run_flag = XFOIL_post(path)\n    # sample BL quantities at the given target_fraction of the chord \n    if run_flag == 1:\n        Dstar_suction = c_round(interp.splev(target_frac * foil['chord'], tck_dict['Dstar_suction'], der = 0))\n        theta_suction = c_round(interp.splev(target_frac * foil['chord'], tck_dict['theta_suction'], der = 0))\n        Ue_suction = c_round(interp.splev(target_frac * foil['chord'], tck_dict['Ue_suction'], der = 0))\n        Cf_suction = c_round(interp.splev(target_frac * foil['chord'], tck_dict['Cf_suction'], der = 0))\n        dpdx_suction = c_round(interp.splev(target_frac * foil['chord'], tck_dict['cp_suction'], der = 1) * dyn_press)\n        dpdx_suction1 = c_round((interp.splev(target_frac * foil['chord'], tck_dict['cp_suction'], der = 0) - interp.splev((target_frac - 0.05) * foil['chord'], tck_dict['cp_suction'], der = 0)) / (0.05 * foil['chord']) * dyn_press)\n\n        Dstar_pressure = c_round(interp.splev(target_frac * foil['chord'], tck_dict['Dstar_pressure'], der = 0))\n        theta_pressure = c_round(interp.splev(target_frac * foil['chord'], tck_dict['theta_pressure'], der = 0))\n        Ue_pressure = c_round(interp.splev(target_frac * foil['chord'], tck_dict['Ue_pressure'], der = 0))\n        Cf_pressure = c_round(interp.splev(target_frac * foil['chord'], tck_dict['Cf_pressure'], der = 0))\n        dpdx_pressure = c_round(interp.splev(target_frac * foil['chord'], tck_dict['cp_pressure'], der = 1) * dyn_press)\n        dpdx_pressure1 = c_round((interp.splev(target_frac * foil['chord'], tck_dict['cp_pressure'], der = 0) - interp.splev((target_frac - 0.05) * foil['chord'], tck_dict['cp_pressure'], der = 0)) / (0.05 * foil['chord']) * dyn_press)\n\n    elif run_flag == 0:\n        Dstar_suction = float(\"nan\"); \n        theta_suction = float(\"nan\"); \n        Ue_suction = float(\"nan\"); \n        dpdx_suction = float(\"nan\"); \n        Cf_suction = float('nan'); \n        dpdx_suction1 = float('nan')\n        Dstar_pressure = float(\"nan\"); \n        theta_pressure = float(\"nan\"); \n        Ue_pressure = float(\"nan\"); \n        dpdx_pressure = float(\"nan\"); \n        Cf_pressure = float('nan'); \n        dpdx_pressure1 = float('nan')\n\n    out_dict['Dstar_suction'] = Dstar_suction; \n    out_dict['theta_suction'] = theta_suction; \n    out_dict['Ue_suction'] = Ue_suction; \n    out_dict['dpdx_suction'] = dpdx_suction; \n    out_dict['Cf_suction'] = Cf_suction; \n    out_dict['dpdx_suction1'] = dpdx_suction1\n    out_dict['Dstar_pressure'] = Dstar_pressure; \n    out_dict['theta_pressure'] = theta_pressure; \n    out_dict['Ue_pressure'] = Ue_pressure; \n    out_dict['dpdx_pressure'] = dpdx_pressure; \n    out_dict['Cf_pressure'] = Cf_pressure; \n    out_dict['dpdx_pressure1'] = dpdx_pressure1\n\n    # post process polar files to read Cl, and Cd \n    polar = XFOIL_post2(path)\n\n    return out_dict,polar\n</code></pre>"},{"location":"reference/source/function.html","title":"Reference for <code>prepost/source/function.py</code>","text":""},{"location":"reference/source/function.html#src.prepost.source.function.SPL_SWL_function","title":"<code>SPL_SWL_function(index, input_var, return_dict, BEM=False)</code>","text":"Source code in <code>src/prepost/source/function.py</code> <pre><code>def SPL_SWL_function(index,input_var,return_dict,BEM=False):\n    wind_turbine  = input_var['wind_turbine']\n    atmos = input_var['atmos']\n    coord = input_var['coord']\n    freq = input_var['freq']\n\n    # receivers = cotte_conv(coord)\n    x_rec = coord['x_coord']\n    z_rec = coord['z_coord']\n    tau = coord['tau_coord']\n\n    # Wind turbine input\n    #---------------------------------------------------------------------------\n    H_ref = wind_turbine.href\n    Omega = wind_turbine.omega\n    Nseg = wind_turbine.Nseg\n    Nblade = wind_turbine.Nblade\n    seg = wind_turbine.seg.reshape(1, Nseg)\n    Lspan = wind_turbine.Lspan.reshape(1, Nseg)\n    c = wind_turbine.chord.reshape(1, Nseg)\n    twist = wind_turbine.twist.reshape(1, Nseg)\n    airfoil_data = wind_turbine.airfoil_data\n    delta_beta = wind_turbine.delta_beta\n    blade_length = seg[0, -1] + 0.5 * Lspan[0, -1]\n\n    Reynolds = airfoil_data['reynolds'].reshape(-1)\n    AoA = airfoil_data['AoA'].reshape(-1)\n    delta_star_bot = airfoil_data['delta_star_bot']\n    theta_momen_bot = airfoil_data['theta_momen_bot']\n    dpdx_bot = airfoil_data['dpdx_bot']\n    UeUinf_bot = airfoil_data['UeUinf_bot']\n    cf_bot = airfoil_data['cf_bot']\n\n    delta_star_top = airfoil_data['delta_star_top']\n    theta_momen_top = airfoil_data['theta_momen_top']\n    dpdx_top = airfoil_data['dpdx_top']\n    UeUinf_top = airfoil_data['UeUinf_top']\n    cf_top = airfoil_data['cf_top']\n    if BEM == True :\n        Cl_tck = airfoil_data['Cl_tck']\n        Cd_tck = airfoil_data['Cd_tck']\n        # quit()\n\n    #Corresponds to the blade count\n    dbeta = 2 * np.pi / Nblade\n    # beta in clockwise directions looking in the wind direction\n    # rearrange nbeta and nseg\n    beta = np.linspace(0, 2 * np.pi - dbeta, Nblade).reshape(Nblade, 1) + delta_beta\n    seg = seg.reshape(1,Nseg)\n\n    # Atmospheric inputs\n    #---------------------------------------------------------------------------\n    # old version\n    # epsilon_Kol = atmos.epsilon_Kol\n    # U_inf = atmos.U_inf\n    # z_atmos = atmos.z_coord\n\n    # coordinate of the segment\n    x_ref = (np.sin(beta) * seg).reshape(len(beta), seg.shape[1])                  #x_ref\n    h_temp = (np.cos(beta) * seg + H_ref).reshape(len(beta), seg.shape[1])         #hight of current segment\n\n    # interpolate atmospheric field on segment position (cubic interpolation)\n    # interpolate from 1D profile\n    # U_inf = interp_atmos_data(atmos.z_coord,atmos.U_inf,h_temp)\n    # epsil = interp_atmos_data(z_atmos,epsilon_Kol,h_temp)\n    # epsil = epsilon_Kol + np.zeros((beta.shape[0], seg.shape[1]))\n\n    xnew = np.zeros_like(h_temp)\n    xnew[...] = wind_turbine.absolute_pos[0]\n    # constant value \n    #ynew = x_ref*0 + wind_turbine.absolute_pos[1]\n    # znew = h_temp*0 + H_ref\n\n    # interpolate 1D profile\n    # ynew = x_ref*0 + wind_turbine.absolute_pos[1]\n    # znew = h_temp\n\n    # interpolate from 3D fields\n    ynew = x_ref + wind_turbine.absolute_pos[1]\n    znew = h_temp\n\n    U_inf, epsil = interp_3D_atmos_data(atmos, xnew, ynew, znew)\n\n    # generic atmospheric data \n    Tref = 10 + 273.15                                                        # reference temperature at height zref (10\u00b0C)\n    zref = 2\n    gamma0 = 1.4\n    r = 287\n    c0 = np.sqrt(gamma0 * r * Tref)\n    rho0 = 1.225\n    nu0 = 1.45e-5                                                             #kinetic viscosity of air\n    Cp0 = 1004\n\n    freq = freq.reshape(1,len(freq))\n    Nfreq = freq.shape[1]\n    lambda0 = c0 / freq\n    k0 = 2 * np.pi / lambda0\n    M = U_inf / c0\n\n    # parameters for Amiet's model\n    b = c/2                                                                        # half chord, c=2b\n    d = Lspan/2;\n    e = c * 0.15                                                                   # thickness of each segment (for NACA63415 thickness is 15%)\n    U_rot = seg * Omega\n    M_rot = U_rot / c0\n\n    omega = 2 * np.pi * freq                                                       # frequency of incident pressure, also the frequency of induced acoustic waves\n    k0 = omega / c0                                                                # acoustic wave number\n    k_bar = k0.T * b\n    kappa = 0.41\n\n    #The Kolmogorov term is extracted as per the theory  from  Buck et al 2018\n    A = 1.65;\n    const1 =  (np.pi ** (1/2)) * (gamma(5/6) / gamma(1/3))\n    Kol_term= (A * 9/55 * np.pi / const1) * epsil ** (2/3)\n\n    AoA_seg = np.zeros((beta.shape[0], seg.shape[1]))\n    rey_seg = np.zeros((beta.shape[0], seg.shape[1]))\n    a_array = np.zeros((beta.shape[0], seg.shape[1]))\n    adash_array = np.zeros((beta.shape[0], seg.shape[1]))\n    epsilon_array = np.zeros((beta.shape[0], seg.shape[1]))\n    U_rel = np.zeros((beta.shape[0], seg.shape[1]))\n    Uc = np.zeros((beta.shape[0], seg.shape[1]))\n    M_rel = np.zeros((beta.shape[0], seg.shape[1]))\n    beta_sq = np.zeros((beta.shape[0],seg.shape[1]))\n    Kx = np.zeros((freq.shape[1], beta.shape[0], seg.shape[1]))\n    Kx_bar = np.zeros((freq.shape[1], beta.shape[0], seg.shape[1]))\n    Kc = np.zeros((freq.shape[1], beta.shape[0], seg.shape[1]))\n    Kc_bar = np.zeros((freq.shape[1], beta.shape[0], seg.shape[1]))\n    mu_bar_TEN = np.zeros((freq.shape[1], beta.shape[0], seg.shape[1]))\n    mu_bar_TIN = np.zeros((freq.shape[1], beta.shape[0], seg.shape[1]))\n    CoefB = 1.47                                #for the calculation of the correlation length\n    CoefC = 0.7                                 #for the calculation of the convection velocity\n\n    if BEM is True :\n        print(BEM)\n        for ibeta in range(beta.shape[0]):\n            for iseg in range(seg.shape[1]):   \n                U_rel[ibeta, iseg] = np.sqrt(U_inf[ibeta, iseg] ** 2 + U_rot[0, iseg] ** 2)     \n                Re = U_rel[ibeta, iseg] * c[0, iseg] / nu0\n                J= Omega * blade_length / U_inf[ibeta, iseg]\n\n                theta = 3*c[0,iseg]/(2*np.pi*seg[0,iseg])            \n                # F = 2 / np.pi * np.arccos(np.exp(-(3 / 2) * (1 - seg[0, iseg] / blade_length) * (1 + J ** 2) ** 0.5))\n\n                # AoA_seg[ibeta,iseg],a,adash,F,epsilon = bem.simple(Cl_tck[iseg],Cd_tck[iseg], Re,J,theta,twist[0,iseg],blade_length,seg[0,iseg],F)\n                AoA_seg[ibeta,iseg],a,adash,F,epsilon,a_conv,adash_conv = bem.hemant1(Cl_tck[iseg],Cd_tck[iseg],Re,J,blade_length,seg[0,iseg],twist[0,iseg],c[0,iseg])\n                # AoA_seg[ibeta,iseg],a,adash,F,epsilon = bem.hemant2(Cl_tck[iseg],Cd_tck[iseg],Re,J,blade_length,seg[0,iseg],twist[0,iseg],c[0,iseg])\n                # AoA_seg[ibeta,iseg],a,adash,F,epsilon = bem.noBEM(Cl_tck[iseg],Cd_tck[iseg],Re,J,blade_length,seg[0,iseg],twist[0,iseg],c[0,iseg])\n\n                a_array[ibeta,iseg] = a\n                adash_array[ibeta,iseg] = adash\n                epsilon_array[ibeta,iseg] = epsilon\n                # U_rel[ibeta,iseg] = ((U_inf[ibeta, iseg]*(1-a))**2 +(U_rot[0,iseg]*(1+adash))**2)**0.5\n                U_rel[ibeta, iseg] = np.sqrt((U_inf[ibeta, iseg] * (1 - F * a)) ** 2 + (U_rot[0, iseg] * (1 + adash)) ** 2)\n                rey_seg[ibeta, iseg] = Re\n\n                Uc[ibeta, iseg] = U_rel[ibeta, iseg] * CoefC\n                M_rel[ibeta, iseg] = U_rel[ibeta, iseg] / c0\n                beta_sq[ibeta, iseg] = 1 - M_rel[ibeta, iseg] ** 2\n                Kx[:, ibeta, iseg] = omega / U_rel[ibeta, iseg]\n                Kx_bar[:, ibeta, iseg] = Kx[:, ibeta, iseg] * b[0, iseg]\n                Kc[:, ibeta, iseg] = omega / Uc[ibeta, iseg]\n                Kc_bar[:, ibeta, iseg] = Kc[:, ibeta, iseg] * b[0, iseg]\n                mu_bar_TEN[:, ibeta, iseg] = Kc_bar[:, ibeta, iseg] * M_rel[ibeta, iseg] / beta_sq[ibeta, iseg]\n                mu_bar_TIN[:, ibeta, iseg] = Kx_bar[:, ibeta, iseg] * M_rel[ibeta, iseg] / beta_sq[ibeta,iseg]\n        # print('AoA')\n        # print(AoA_seg)\n        # print('epsilon')\n        # print(epsilon_array)\n\n\n    else: \n        for ibeta in range(beta.shape[0]):\n            for iseg in range(seg.shape[1]):\n                U_rel[ibeta, iseg] = np.sqrt(U_inf[ibeta, iseg] ** 2 + U_rot[0, iseg] ** 2)\n                Uc[ibeta, iseg] = U_rel[ibeta, iseg] * CoefC\n                M_rel[ibeta, iseg] = U_rel[ibeta, iseg] / c0\n                beta_sq[ibeta, iseg] = 1 - M_rel[ibeta, iseg] ** 2\n                Kx[:, ibeta, iseg] = omega / U_rel[ibeta, iseg]\n                Kx_bar[:, ibeta, iseg] = Kx[:, ibeta, iseg] * b[0, iseg]\n                Kc[:, ibeta, iseg] = omega / Uc[ibeta, iseg]\n                Kc_bar[:, ibeta, iseg] = Kc[:, ibeta, iseg] * b[0, iseg]\n                mu_bar_TEN[:, ibeta, iseg] = Kc_bar[:, ibeta, iseg] * M_rel[ibeta, iseg] / beta_sq[ibeta, iseg]\n                mu_bar_TIN[:, ibeta, iseg] = Kx_bar[:, ibeta, iseg] * M_rel[ibeta, iseg] / beta_sq[ibeta,iseg]\n                # different convention for AoA\n                # AoA_seg[ibeta, iseg] = np.arctan(U_inf[ibeta, iseg] / U_rot[0, iseg]) - twist[0, iseg]\n                rey_seg[ibeta, iseg] = U_rel[ibeta, iseg] * c[0, iseg] / nu0\n                AoA_seg[ibeta, iseg] = twist[0, iseg] - np.arctan(U_rot[0, iseg] / U_inf[ibeta, iseg])\n\n\n    AoA_seg1 = AoA_seg * 180 / np.pi\n\n    maxbetac_t = 0                              #corresponding to maximum Clauser's parameter calculated\n    Dopp = np.zeros((x_rec.shape[0], seg.shape[1], beta.shape[0]))\n    omegae = np.zeros((x_rec.shape[0], freq.shape[0], freq.shape[1]))\n    Ky = np.zeros((x_rec.shape[0], freq.shape[0], freq.shape[1]))\n    Ky_bar = np.zeros((x_rec.shape[0], freq.shape[0], freq.shape[1]))\n    Kx_hat = np.zeros((x_rec.shape[0], freq.shape[0], freq.shape[1]))\n    Ky_hat = np.zeros((x_rec.shape[0], freq.shape[0], freq.shape[1]))\n    kappa_bar = np.zeros((x_rec.shape[0], freq.shape[0], freq.shape[1]))\n\n    B = np.zeros((x_rec.shape[0], freq.shape[1], freq.shape[0]))\n    C = np.zeros((x_rec.shape[0], freq.shape[1], freq.shape[0]))\n    C1 = np.zeros((x_rec.shape[0], freq.shape[1], freq.shape[0]))\n    S1 = np.zeros((x_rec.shape[0], freq.shape[1], freq.shape[0]))\n    C2 = np.zeros((x_rec.shape[0], freq.shape[1], freq.shape[0]))\n    S2 = np.zeros((x_rec.shape[0], freq.shape[1], freq.shape[0]))\n\n    LL_TE = np.zeros((x_rec.shape[0], freq.shape[1], freq.shape[0]))\n    ly = np.zeros((x_rec.shape[0], freq.shape[0], freq.shape[1]))\n    Phi_pp_pres1 = np.zeros((x_rec.shape[0], freq.shape[0], freq.shape[1]))\n    Phi_pp_pres2 = np.zeros((x_rec.shape[0], freq.shape[0], freq.shape[1]))\n    Phi_pp_suct1 = np.zeros((x_rec.shape[0], freq.shape[0], freq.shape[1]))\n    Phi_pp_suct2 = np.zeros((x_rec.shape[0], freq.shape[0], freq.shape[1]))\n    Spp_suct = np.zeros((x_rec.shape[0], seg.shape[1], beta.shape[0], freq.shape[1]))\n    Spp_pres = np.zeros((x_rec.shape[0], seg.shape[1], beta.shape[0], freq.shape[1]))\n    Spp_TEN = np.zeros((x_rec.shape[0], seg.shape[1], beta.shape[0], freq.shape[1]))\n\n    theta1 = np.zeros((x_rec.shape[0], freq.shape[1], freq.shape[0]))\n    theta2 = np.zeros((x_rec.shape[0], freq.shape[1], freq.shape[0]))\n    C4 = np.zeros((x_rec.shape[0], freq.shape[1], freq.shape[0]))\n    S4 = np.zeros((x_rec.shape[0], freq.shape[1], freq.shape[0]))\n    LL_TI = np.zeros((x_rec.shape[0], freq.shape[1], freq.shape[0]))\n    Phi_ww = np.zeros((x_rec.shape[0], freq.shape[0], freq.shape[1]))\n    Spp_TIN = np.zeros((x_rec.shape[0], seg.shape[1], beta.shape[0], freq.shape[1]))\n    Spp_tot = np.zeros((x_rec.shape[0], seg.shape[1], beta.shape[0], freq.shape[1]))\n\n    SPL_tot = np.zeros((x_rec.shape[0], Nseg, Nblade, Nfreq))\n    SPL_TEN = np.zeros((x_rec.shape[0], Nseg, Nblade, Nfreq))\n    SPL_TIN = np.zeros((x_rec.shape[0], Nseg, Nblade, Nfreq))\n    SWL_tot = np.zeros((x_rec.shape[0], Nseg, Nblade, Nfreq))\n\n    beta0 = []\n\n    R0 = np.sqrt(x_rec ** 2 + (H_ref-z_rec) ** 2)\n\n    # calculate angles teta and phi according to Schlinker and Amiet (1981) and Rozenberg (2007)\n\n    # receiver coordinates in the (X,Y,Z) coordinate system :\n    # teta = np.arccos(x_rec * np.cos(tau) / R0)\n    teta = np.arccos(np.divide(x_rec * np.cos(tau) ,R0,out=np.zeros_like(R0),where=R0!=0))\n    ZO = R0 * np.cos(teta)\n    XO = R0 * np.sin(teta)\n    YO = np.zeros(XO.shape[0])                                      # by definition\n\n    # loop over the azimutal blade position\n    for ibeta in range(beta.shape[0]):\n        beta0.append(dbeta * ibeta)\n\n        # calculation of angle psi with beta =  0 corresponding to blade pointing up (y-axis)\n        numer = -(x_rec * np.sin(beta[ibeta, 0]) * np.sin(tau) + (H_ref - z_rec) * np.cos(beta[ibeta, 0]))\n        denom = np.sqrt(x_rec ** 2 * np.sin(tau) ** 2 + (H_ref - z_rec) ** 2)\n        cospsi = np.divide(numer,denom,out=np.zeros_like(numer),where=denom!=0)\n\n        numer = (x_rec * np.cos(beta[ibeta, 0]) * np.sin(tau) - (H_ref - z_rec) * np.sin(beta[ibeta, 0]))\n        denom = np.sqrt(x_rec ** 2 * np.sin(tau) ** 2 + (H_ref - z_rec) ** 2)\n        sinpsi = np.divide(numer,denom,out=np.zeros_like(numer),where=denom!=0)\n\n        # cospsi = -(x_rec * np.sin(beta[ibeta, 0]) * np.sin(tau) + (H_ref - z_rec) * np.cos(beta[ibeta, 0])) / np.sqrt(x_rec ** 2 * np.sin(tau) ** 2 + (H_ref - z_rec) ** 2)\n        # sinpsi = (x_rec * np.cos(beta[ibeta, 0]) * np.sin(tau) - (H_ref - z_rec) * np.sin(beta[ibeta, 0])) / np.sqrt(x_rec ** 2 * np.sin(tau) ** 2 + (H_ref - z_rec) ** 2)\n\n        # loop over the segments\n        for iseg in range(seg.shape[1]):\n            if np.isnan(AoA_seg[ibeta,iseg]):\n                continue\n            # receiver coordinates in the hub coordinate system (C,x2,y2,z2)\n            #--------------------------------------------------------------------------------------------\n            # rotation of pi/2-psi to align y-axis with span\n            MZ = np.zeros((x_rec.shape[0], 3, 3))\n            MZ[:, 0, 0] = sinpsi.reshape(x_rec.shape[0], )\n            MZ[:, 0, 1] = -cospsi.reshape(x_rec.shape[0], )\n            MZ[:, 1, 0] = cospsi.reshape(x_rec.shape[0], )\n            MZ[:, 1, 1] = sinpsi.reshape(x_rec.shape[0], )\n            MZ[:, 2, 2] = np.ones(x_rec.shape[0])\n            # MZ = np.asarray([sinpsi, -cospsi, 0, cospsi, sinpsi, 0, 0, 0, 1]).reshape(3, 3)\n            xyz_global = np.asarray([XO.reshape(x_rec.shape[0], ), YO.reshape(x_rec.shape[0], ), ZO.reshape(x_rec.shape[0], )]).T.reshape(x_rec.shape[0], 3, 1)\n            xyzO = np.matmul(MZ, xyz_global)\n\n            # receiver coordinates in the segment coordinate system (S,x3,y3,z3),\n            MU = np.asarray([np.cos(np.pi/2 - twist[0, iseg]), 0, np.sin(np.pi/2 - twist[0, iseg]), 0, 1, 0, -np.sin(np.pi / 2 - twist[0, iseg]), 0, np.cos(np.pi / 2 - twist[0, iseg])]).reshape(3, 3)\n            MU = np.repeat(MU[np.newaxis, :, :], x_rec.shape[0], axis = 0)\n            xyz = np.matmul(MU, xyzO)\n            M_trans = np.asarray([0, -seg[0, iseg], 0]).reshape(3, 1)\n            xyz = xyz + np.repeat(M_trans[np.newaxis, :, :], x_rec.shape[0], axis = 0)\n\n            S0 = np.sqrt(xyz[:, 0, 0] ** 2 + (1 - M_rel[ibeta, iseg] ** 2) * ((xyz[:, 1, 0]) ** 2 + xyz[:, 2, 0] ** 2))\n\n            #calculate Doppler factor and deduce emission frequency omegae\n            #--------------------------------------------------------------------------------------------\n            Dopp[:, iseg, ibeta] = (1 + M_rot[0, iseg] * sinpsi * np.sin(teta) / np.sqrt(1 - M[ibeta, iseg] ** 2 * np.sin(teta) ** 2)).reshape(x_rec.shape[0], ) # omegae/omega - equation (4.4) of Rozenberg (2007)\n            omegae = np.matmul(Dopp[:, iseg, ibeta].reshape(x_rec.shape[0], 1), omega)\n\n            # variables useful for TEN and TIN model at emitted frequency omegae\n            #--------------------------------------------------------------------------------------------\n            Ky = np.matmul((Dopp[:, iseg, ibeta] * xyz[:, 1, 0] / S0).reshape(x_rec.shape[0], 1), k0)\n            Ky_bar = Ky * b[0, iseg]\n\n            #TEN calculation at emitted frequency omegae\n            #--------------------------------------------------------------------------------------------\n            kappa_bar = np.sqrt((np.matmul(Dopp[:, iseg, ibeta].reshape(x_rec.shape[0], 1), mu_bar_TEN[:, ibeta, iseg].reshape(1, Nfreq))) ** 2 - Ky_bar ** 2 / beta_sq[ibeta,iseg])\n\n\n            B = np.matmul(Dopp[:, iseg, ibeta].reshape(x_rec.shape[0], 1), Kc_bar[:, ibeta, iseg].reshape(1, Nfreq)) + np.matmul(Dopp[:, iseg, ibeta].reshape(x_rec.shape[0], 1), (M_rel[ibeta, iseg] * mu_bar_TEN[:, ibeta, iseg]).reshape(1, Nfreq)) + kappa_bar\n            C = Kc_bar[:, ibeta, iseg].reshape(1, Nfreq) * Dopp[:, iseg, ibeta].reshape(x_rec.shape[0], 1) - np.matmul(Dopp[:, iseg, ibeta].reshape(x_rec.shape[0], 1), mu_bar_TEN[:, ibeta, iseg].reshape(1, Nfreq)) * (xyz[:, 0, 0] / S0 - M_rel[ibeta, iseg]).reshape(x_rec.shape[0], 1)\n            C1, S1 = fresnelCS(np.sqrt(2 / np.pi * 2 * np.abs(B-C)))\n            C2, S2 = fresnelCS(np.sqrt(2 / np.pi * 2 * B))\n\n            # Aeroacoustic transfer function\n            LL_TE =  np.abs(-np.exp( 2 * 1j * C) / (1j * C) * ((1 + 1j) * np.exp(-2 * 1j * C) * np.sqrt(B / (B - C)) * (C1 - 1j * S1) - (1 + 1j) * (C2 - 1j * S2) + 1))\n\n            # span-wise correlation length calculated from the Corcos model\n            ly = (omegae / (CoefB * Uc[ibeta, iseg])) / (Ky ** 2 + (omegae / (CoefB * Uc[ibeta,iseg])) ** 2)\n\n            # linear interpolation for AoA and Reynolds of the data base \n            # Warning no interpolation for the segments hence must be exactly the same \n            ind_AoA = find_index(AoA_seg[ibeta,iseg] * 180 / np.pi, AoA)\n            if AoA_seg1[ibeta,iseg] &gt; max(AoA) : \n                logging.warning('AoA outside of bound set to %s instead of %s' % (AoA[-1], AoA_seg1[ibeta,iseg]))\n                ind_AoA_left = len(AoA)-1\n                ind_AoA_right = 0\n                ratio_AoA = 0\n            elif AoA_seg1[ibeta,iseg] &lt; min(AoA) : \n                ind_AoA_left = 0\n                ind_AoA_right = 0\n                ratio_AoA = 0\n                logging.warning('AoA outside of bound set to %s instead of %s' % (AoA[0], AoA_seg1[ibeta,iseg]))\n            else : \n                ind_AoA_left = ind_AoA - 1\n                ind_AoA_right = ind_AoA\n                ratio_AoA = (AoA_seg[ibeta,iseg] * 180 / np.pi - AoA[ind_AoA_left]) / (AoA[ind_AoA_right] - AoA[ind_AoA_left])\n\n            delta_star_top1 = delta_star_top[:, ind_AoA_left, iseg] + ratio_AoA * (delta_star_top[:, ind_AoA_right, iseg] - delta_star_top[:, ind_AoA_left, iseg])\n            delta_star_bot1 = delta_star_bot[:, ind_AoA_left, iseg] + ratio_AoA * (delta_star_bot[:, ind_AoA_right, iseg] - delta_star_bot[:, ind_AoA_left, iseg])\n\n\n            theta_momen_top1 = theta_momen_top[:, ind_AoA_left, iseg] + ratio_AoA * (theta_momen_top[:, ind_AoA_right, iseg] - theta_momen_top[:, ind_AoA_left, iseg])\n            theta_momen_bot1 = theta_momen_bot[:, ind_AoA_left, iseg] + ratio_AoA * (theta_momen_bot[:, ind_AoA_right, iseg] - theta_momen_bot[:, ind_AoA_left, iseg])\n\n            dpdx_top1 = dpdx_top[:, ind_AoA_left, iseg] + ratio_AoA * (dpdx_top[:, ind_AoA_right, iseg] - dpdx_top[:, ind_AoA_left, iseg])\n            dpdx_bot1 = dpdx_bot[:, ind_AoA_left, iseg] + ratio_AoA * (dpdx_bot[:, ind_AoA_right, iseg] - dpdx_bot[:, ind_AoA_left, iseg])\n\n            cf_top1 = cf_top[:, ind_AoA_left, iseg] + ratio_AoA * (cf_top[:, ind_AoA_right, iseg] - cf_top[:, ind_AoA_left, iseg])\n            cf_bot1 = cf_bot[:, ind_AoA_left, iseg] + ratio_AoA * (cf_bot[:, ind_AoA_right, iseg] - cf_bot[:, ind_AoA_left, iseg])\n\n\n            UeUinf_top1 = UeUinf_top[:, ind_AoA_left, iseg] + ratio_AoA * (UeUinf_top[:, ind_AoA_right, iseg] - UeUinf_top[:, ind_AoA_left, iseg])\n            UeUinf_bot1 = np.abs(UeUinf_bot[:, ind_AoA_left, iseg] + ratio_AoA * (UeUinf_bot[:, ind_AoA_right, iseg] - UeUinf_bot[:, ind_AoA_left, iseg]))\n\n            Reyn = U_rel[ibeta,iseg] * c[0, iseg] / nu0\n            ind_re = find_index(Reyn, Reynolds)\n            ind_left = ind_re - 1\n            ind_right = ind_re\n            ratio = (Reyn-Reynolds[ind_left]) / (Reynolds[ind_right] - Reynolds[ind_left])\n\n            delta_star_t = delta_star_top1[ind_left] + ratio * (delta_star_top1[ind_right] - delta_star_top1[ind_left])\n            delta_star_b = delta_star_bot1[ind_left] + ratio * (delta_star_bot1[ind_right] - delta_star_bot1[ind_left])\n\n            theta_momen_t = theta_momen_top1[ind_left] + ratio * (theta_momen_top1[ind_right] - theta_momen_top1[ind_left])\n            theta_momen_b = theta_momen_bot1[ind_left] + ratio * (theta_momen_bot1[ind_right] - theta_momen_bot1[ind_left])\n\n            dpdx_t = dpdx_top1[ind_left] + ratio * (dpdx_top1[ind_right] - dpdx_top1[ind_left])\n            dpdx_b = dpdx_bot1[ind_left] + ratio * (dpdx_bot1[ind_right] - dpdx_bot1[ind_left])\n\n            cf_t = cf_top1[ind_left] + ratio * (cf_top1[ind_right] - cf_top1[ind_left])\n            cf_b = cf_bot1[ind_left] + ratio * (cf_bot1[ind_right] - cf_bot1[ind_left])\n\n            UeUinf_t = UeUinf_top1[ind_left] + ratio * (UeUinf_top1[ind_right] - UeUinf_top1[ind_left])\n            UeUinf_b = np.abs(UeUinf_bot1[ind_left] + ratio * (UeUinf_bot1[ind_right] - UeUinf_bot1[ind_left]))\n\n            #Calculation of Clauser parameter in the pressure and suction sides\n            # to determine which WPS model to use\n            Ue_t = U_rel[ibeta,iseg] * np.abs(UeUinf_t)                    # external velocity (m)\n            tauw_t = cf_t * 0.5 * rho0 * Ue_t ** 2                         # wall shear stress (Pa)\n            betac_t = theta_momen_t / tauw_t * dpdx_t                      # Clauser parameter\n            maxbetac_t = max(maxbetac_t, betac_t)\n\n            # Wall pressure spectrum calculation \n            # Suction side\n            if cf_t &lt; 0:  \n                logging.warning('top : BL separated for seg %s and angle %s, cf= %s' %  (iseg,beta[ibeta, 0], cf_t ))                                                     # no model used because BL is separated\n                Phi_pp_suct1 = 0\n                Phi_pp_suct2 = 0\n            elif betac_t &gt; 60:       \n                logging.warning('top : AP very strong BL may be separated') \n                dpdx_t = 60 / theta_momen_t * tauw_t\n                Phi_pp_suct1, Phi_pp_suct2 = WP_LEE(np.matmul(Dopp[:, iseg, ibeta].reshape(x_rec.shape[0], 1), freq.reshape(1, Nfreq)), delta_star_t, theta_momen_t, dpdx_t, cf_t, UeUinf_t, U_rel[ibeta,iseg])\n            elif betac_t &gt; 0 and betac_t &lt; 60:                                              # Lee's model\n                Phi_pp_suct1, Phi_pp_suct2 = WP_LEE(np.matmul(Dopp[:, iseg, ibeta].reshape(x_rec.shape[0], 1), freq.reshape(1, Nfreq)), delta_star_t, theta_momen_t, dpdx_t, cf_t, UeUinf_t ,U_rel[ibeta, iseg])\n            elif betac_t &lt; 0:     \n                logging.warning('top : BL separated -- &gt; should never happen')                                         #should never happen on the suction side\n                Phi_pp_suct1 = 0\n                Phi_pp_suct2 = 0\n\n            # Pressure side\n            Ue_b = U_rel[ibeta,iseg] * np.abs(UeUinf_b)                    # external velocity (m)\n            tauw_b = cf_b * 0.5 * rho0 * Ue_b ** 2                         # wall shear stress (Pa)\n            betac_b = theta_momen_b / tauw_b * dpdx_b                      # Clauser parameter\n            if dpdx_b &lt; 0:                                                  # use Goody's model if favorable pressure gradient\n                Phi_pp_pres1, Phi_pp_pres2 = WP_Goody(np.matmul(Dopp[:, iseg, ibeta].reshape(x_rec.shape[0], 1), freq.reshape(1, Nfreq)), delta_star_b , theta_momen_b , cf_b , UeUinf_b , U_rel[ibeta,iseg])\n            else:\n                Phi_pp_pres1, Phi_pp_pres2 = WP_LEE(np.matmul(Dopp[:, iseg, ibeta].reshape(x_rec.shape[0], 1), freq.reshape(1, Nfreq)), delta_star_b, theta_momen_b, dpdx_b, cf_b, UeUinf_b, U_rel[ibeta,iseg])\n\n\n            # PSD of acoustic pressure on the pressure and suction sides\n            Spp_suct[:, iseg, ibeta, :] = (omegae * (xyz[:, 2, 0] * b[0, iseg] / (2 * np.pi * c0 * S0 ** 2)).reshape(x_rec.shape[0], 1)) ** 2 * Lspan[0, iseg] * 2 * LL_TE ** 2 * Phi_pp_suct1 * ly\n            Spp_pres[:, iseg, ibeta, :] = (omegae * (xyz[:, 2, 0] * b[0, iseg] / (2 * np.pi * c0 * S0 ** 2)).reshape(x_rec.shape[0], 1)) ** 2 * Lspan[0, iseg] * 2 * LL_TE ** 2 * Phi_pp_pres1 * ly\n            # PSD of acoustic pressure at far-field\n            Spp_TEN[:, iseg, ibeta, :] = Spp_suct[:, iseg, ibeta, :] + Spp_pres[:, iseg, ibeta, :]\n\n\n            # Turbulence Inflow Noise calculation at emitted frequency omegae\n            #--------------------------------------------------------------------------------------------\n            kappa_bar = np.sqrt(np.matmul(Dopp[:, iseg, ibeta].reshape(x_rec.shape[0], 1), mu_bar_TIN[:, ibeta, iseg].reshape(1, Nfreq)) ** 2 - Ky_bar ** 2 / beta_sq[ibeta, iseg])\n\n\n            theta1 = kappa_bar - np.matmul(Dopp[:, iseg, ibeta].reshape(x_rec.shape[0], 1), mu_bar_TIN[:, ibeta, iseg].reshape(1, Nfreq)) * (xyz[:, 0, 0] / S0).reshape(x_rec.shape[0], 1)\n            theta2 = np.matmul(Dopp[:, iseg, ibeta].reshape(x_rec.shape[0], 1), mu_bar_TIN[:, ibeta, iseg].reshape(1, Nfreq)) * (M_rel[ibeta, iseg] - (xyz[0, 0] / S0).reshape(x_rec.shape[0], 1)) - np.pi / 4\n            C4, S4 = fresnelCS(np.sqrt(2 / np.pi * 2 * theta1))\n            LL_TI =  np.abs(np.sqrt(2 / (np.matmul(Dopp[:, iseg, ibeta].reshape(x_rec.shape[0], 1), Kx_bar[:, ibeta, iseg].reshape(1, Nfreq)) + kappa_bar * beta_sq[ibeta, iseg]) / theta1) * (C4 - 1j * S4) * np.exp(1j * theta2) / np.pi)\n\n            kx_kol = np.matmul(Dopp[:, iseg, ibeta].reshape(x_rec.shape[0], 1), Kx[:, ibeta, iseg].reshape(1, Nfreq))              # normalized chordwise turbulent wavenumber\n            ky_kol =  Ky                                                   # normalized spanwise turbulent wavenumber\n\n            Phi_ww =  (4 / 9 / np.pi) * ((kx_kol ** 2 + ky_kol ** 2) ** (-4/3)) * Kol_term[ibeta, iseg]\n            Spp_TIN[:, iseg, ibeta, :] = 2 * (rho0 * np.matmul((Dopp[:, iseg, ibeta] * xyz[:, 2, 0] / S0 ** 2).reshape(x_rec.shape[0], 1), k0) * c[0, iseg] / 2) ** 2 * np.pi * U_rel[ibeta, iseg] * d[0, iseg] * Phi_ww * LL_TI ** 2\n\n\n            # total contribution\n            #------------------------------------------------------------------------------------------\n            Spp_tot[:, iseg, ibeta, :] = Spp_TEN[:, iseg, ibeta, :] + Spp_TIN[:, iseg, ibeta, :]\n\n    #for the calculation of SPL by individual blade segments at the given reciever location\n    #for the net calculation of the SPL at the receiver location due to all the different blade segments\n    for ifreq in range(Nfreq):\n        # SPL tot for all segment, beta position and receivers position \n        SPL_tot[:, :, :, ifreq] = 10 * np.log10(Spp_tot[:, :, :, ifreq] * Dopp ** 2 * 2 * np.pi / 4e-10)\n        SPL_TIN[:, :, :, ifreq] = 10 * np.log10(Spp_TIN[:, :, :, ifreq] * Dopp ** 2 * 2 * np.pi / 4e-10)\n        SPL_TEN[:, :, :, ifreq] = 10 * np.log10(Spp_TEN[:, :, :, ifreq] * Dopp ** 2 * 2 * np.pi / 4e-10)\n\n    R1_array = R1_func(coord, H_ref)\n    SWL_tot = SPL_tot + 10 * np.log10(4 * np.pi * R1_array.reshape(-1,1,1,1) ** 2)\n\n\n    output = {}\n    output['AoA'] = AoA_seg1\n    output['U_inf'] = U_inf\n    output['epsilon'] = epsil\n    output['U_rot'] = np.repeat(U_rot.reshape(1,-1),beta.shape[0],axis=1)\n    output['U_rel'] = U_rel\n    output['a'] = a_array\n    output['adash'] = adash_array\n    # output['epsilon'] = epsilon_array\n    output['SPL_tot'] = SPL_tot\n    output['SPL_TIN'] = SPL_TIN\n    output['SPL_TEN'] = SPL_TEN\n    output['SWL_tot'] = SWL_tot\n    # output['OASPL'] = OASPL\n    # output['OASPL_beta'] = OASPL_beta\n    # output['AM_rec'] = AM_rec\n    # output['SWL_freq'] = SWL_freq\n    # output['SPL_freq'] = SPL_freq\n    output['recon_index'] = input_var['recon_index']\n    # output['SPL_tot'] = SPL_tot\n    # output['Spp_tot'] = Spp_tot\n    # output['Spp_TIN'] = Spp_TIN\n    # output['Spp_TEN'] = Spp_TEN\n    # output['beta'] = beta\n\n    return_dict[index] = output\n</code></pre>"},{"location":"reference/source/function.html#src.prepost.source.function.SPL_SWL_parallel","title":"<code>SPL_SWL_parallel(wt, atmos, mesh, freq, Ncore, BEM=False, fc=None, Nfc=None)</code>","text":"<p>Compute SPL in free field and SWL for a given wind turbine, atmospheric condition, mesh and set of frequency.     The calculations are done in parrallel for different part of the mesh.</p> <p>Parameters:</p> <ul> <li> <code>wt</code>               (<code>WindTurbine</code>)           \u2013            <p>defines the wind turbine geometric property</p> </li> <li> <code>atmos</code>               (<code>Les</code>)           \u2013            <p>Set the amospheric condition around the turbine</p> </li> <li> <code>mesh</code>               (<code>Mesh</code>)           \u2013            <p>Defines the mesh on which to compute the resuls</p> </li> <li> <code>freq</code>               (<code>list</code>)           \u2013            <p>list of frequency for which the calculation are done</p> </li> <li> <code>Ncore</code>               (<code>int</code>)           \u2013            <p>Number of threads used for the parallel (minimum 2)</p> </li> <li> <code>BEM</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True uses BEM theory and drag and lift coefficient of each segment to compute the effective AoA. Defaults to False.</p> </li> <li> <code>fc</code>               (<code>ndarray</code>, default:                   <code>None</code> )           \u2013            <p>Array of third octave band. Must corresponds to freq list and is used to compute SPL and SWL in third octave band. Defaults to None.</p> </li> <li> <code>Nfc</code>               (<code>ndarray</code>, default:                   <code>None</code> )           \u2013            <p>Number of frequency per band. Must correspond with fc and freq. Defaults to None.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>_type_</code>          \u2013            <p>description</p> </li> </ul> Source code in <code>src/prepost/source/function.py</code> <pre><code>def SPL_SWL_parallel(wt:WindTurbine,atmos:Les,mesh:Mesh,freq:list,Ncore:int,BEM:bool=False, fc:np.ndarray = None, Nfc:np.ndarray = None):\n    \"\"\"Compute SPL in free field and SWL for a given wind turbine, atmospheric condition, mesh and set of frequency.\n        The calculations are done in parrallel for different part of the mesh.\n\n    Args:\n        wt (WindTurbine): defines the wind turbine geometric property\n        atmos (Les): Set the amospheric condition around the turbine\n        mesh (Mesh): Defines the mesh on which to compute the resuls\n        freq (list): list of frequency for which the calculation are done\n        Ncore (int): Number of threads used for the parallel (minimum 2)\n        BEM (bool, optional): If True uses BEM theory and drag and lift coefficient of each segment to compute the effective AoA. Defaults to False.\n        fc (np.ndarray, optional): Array of third octave band. Must corresponds to freq list and is used to compute SPL and SWL in third octave band. Defaults to None.\n        Nfc (np.ndarray, optional): Number of frequency per band. Must correspond with fc and freq. Defaults to None.\n\n    Returns:\n        _type_: _description_\n    \"\"\"\n\n    final_coord = domain_facture(mesh, Ncore)\n    nx1 = mesh.x_coord.shape[0]\n    nx2 = mesh.x_coord.shape[1]\n\n    # calculate only the first blade has reached the position of the second\n    beta_array = np.linspace(0,2*np.pi*(wt.Nbeta-1)/wt.Nblade/wt.Nbeta,wt.Nbeta)#+np.pi/3\n\n    # final results matrix to be field\n    final_SPL_tot = np.zeros((nx1 * nx2,wt.Nseg*wt.Nblade, len(freq), wt.Nbeta))\n    final_SPL_TIN = np.zeros((nx1 * nx2,wt.Nseg*wt.Nblade, len(freq), wt.Nbeta))\n    final_SPL_TEN = np.zeros((nx1 * nx2,wt.Nseg*wt.Nblade, len(freq), wt.Nbeta))\n    final_SWL_tot = np.zeros((nx1 * nx2,wt.Nseg*wt.Nblade, len(freq), wt.Nbeta))\n    final_AoA = np.zeros((wt.Nseg*wt.Nblade, wt.Nbeta))\n    final_Uinf = np.zeros((wt.Nseg*wt.Nblade, wt.Nbeta))\n    final_epsilon = np.zeros((wt.Nseg*wt.Nblade, wt.Nbeta))\n    final_Urot = np.zeros((wt.Nseg*wt.Nblade, wt.Nbeta))\n    final_Urel = np.zeros((wt.Nseg*wt.Nblade, wt.Nbeta))\n    final_a = np.zeros((wt.Nseg*wt.Nblade, wt.Nbeta))\n    final_adash = np.zeros((wt.Nseg*wt.Nblade, wt.Nbeta))\n\n    input_array = []\n    start0 = time.time()\n    for ibeta in range(wt.Nbeta):\n        # offset angle\n        wt.delta_beta = beta_array[ibeta]\n        # loop over the sub domain\n        for temp in range(Ncore):\n            temp_dict = {}\n            temp_dict['coord'] = final_coord[temp]\n            temp_dict['wind_turbine'] = wt\n            temp_dict['atmos'] = atmos\n            temp_dict['freq'] = freq\n            temp_dict['recon_index'] = temp\n            input_array.append(temp_dict)\n\n        # initialization of multiprocessing\n        start = time.time()\n        manager = multiprocessing.Manager()\n        return_dict = manager.dict()\n        jobs = []\n        index_array = np.linspace(1, Ncore, Ncore)\n\n        # launch of the threads\n        for i in range(Ncore):\n            p = multiprocessing.Process(target = SPL_SWL_function, args=(index_array[i], input_array[i], return_dict,BEM))\n            jobs.append(p)\n            p.start()\n\n        for proc in jobs:\n            proc.join()\n\n        end = time.time()\n        # end of the mulmtiprocdessing\n        print(str(c_round(end - start)) + ' seconds')\n\n        output_total = return_dict.values()\n        # rearange output to the given shape\n        final_output = reshuffle_output(output_total, Ncore)\n        # construct the needed quantities\n        # OASPL, OASPL_beta, AM_rec, SPL_freq, SWL_freq, SPL_tot_ff,Spp_tot,Spp_TIN,Spp_TEN, beta = output_construct(final_output, mesh, Ncore, len(freq), wt.Nblade, wt.Nseg)\n        SPL_tot, SPL_TIN,SPL_TEN,SWL_tot,AoA,U_inf,epsilon,U_rot,U_rel,a,adash= output_construct(final_output, mesh, Ncore, len(freq), wt.Nblade, wt.Nseg)\n\n        # recorded output over the change in blade position\n        final_SPL_tot[:, :,:, ibeta] = SPL_tot\n        final_SPL_TIN[:, :,:, ibeta] = SPL_TIN\n        final_SPL_TEN[:, :,:, ibeta] = SPL_TEN\n        final_SWL_tot[:, :,:, ibeta] = SWL_tot\n        final_AoA[:, ibeta] = AoA\n        final_Uinf[:,ibeta] = U_inf\n        final_epsilon[:,ibeta] = epsilon\n        final_Urot[:, ibeta] = U_rot\n        final_Urel[:,ibeta] = U_rel\n        final_a[:,ibeta] = a\n        final_adash[:,ibeta] = adash\n\n        final_beta_SPL_tot = 10*np.log10(np.sum(10**(final_SPL_tot/10), (1,3))/wt.Nbeta)\n\n        print('Computations completed: ' + str(ibeta) + '/' + str(wt.Nbeta))\n    end0 = time.time()\n    print('total time: '+ str(c_round(end0-start0))+' seconds')\n\n    # computation of third octave results and overall SPL results \n    if fc:\n        SPL_third_tot = np.zeros((nx1 * nx2,wt.Nseg*wt.Nblade, len(fc), wt.Nbeta))\n        for ifc in range(len(fc)): \n            SPL_third_tot[:,:,ifc,:] = 10*np.log10(fc[ifc]*0.232/Nfc[ifc]* np.sum(10 ** (final_SPL_tot[:,:, int(np.sum(Nfc[0:ifc])):int(np.sum(Nfc[0:ifc+1])),:]/10), axis=2))\n        OASPL = 10*np.log10(np.sum(10**(SPL_third_tot/10),2))\n        dBa = Aweight(np.array(fc)).reshape(1,1,-1,1)\n        OASPL_A = 10*np.log10(np.sum(10**((SPL_third_tot+dBa)/10),2))\n        return final_SPL_tot,final_SPL_TIN, final_SPL_TEN, final_SWL_tot,SPL_third_tot,OASPL,OASPL_A,final_AoA,final_Uinf\n\n    return final_SPL_tot,final_SPL_TIN, final_SPL_TEN, final_SWL_tot, final_AoA,final_Uinf,final_epsilon,final_Urot,final_Urel,final_a,final_adash\n</code></pre>"},{"location":"reference/source/main.html","title":"Reference for <code>prepost/source/main.py</code>","text":""},{"location":"reference/source/main.html#src.prepost.source.main.Source","title":"<code>Source(wt=None, atmos=None, mesh=None, Spp=None)</code>","text":"<p>A class to represent an acoustic source model for wind turbines.</p> <p>This class provides methods to manage wind turbine acoustics data, perform spatial interpolations, compute sound power levels, and visualize results.</p> <p>Attributes:</p> <ul> <li> <code>atmos</code>               (<code>Les</code>)           \u2013            <p>Atmospheric conditions.</p> </li> <li> <code>wt</code>               (<code>WindTurbine</code>)           \u2013            <p>Wind turbine object.</p> </li> <li> <code>mesh</code>               (<code>Mesh</code>)           \u2013            <p>Computational mesh.</p> </li> <li> <code>Spp</code>               (<code>array</code>)           \u2013            <p>Spectral power distribution data.</p> </li> </ul> <p>Initialize the Source object with wind turbine, atmosphere, mesh, and spectral data.</p> <p>Parameters:</p> <ul> <li> <code>wt</code>               (<code>WindTurbine</code>, default:                   <code>None</code> )           \u2013            <p>Wind turbine object. Defaults to None.</p> </li> <li> <code>atmos</code>               (<code>Les</code>, default:                   <code>None</code> )           \u2013            <p>Atmospheric conditions. Defaults to None.</p> </li> <li> <code>mesh</code>               (<code>Mesh</code>, default:                   <code>None</code> )           \u2013            <p>Computational mesh. Defaults to None.</p> </li> <li> <code>Spp</code>               (<code>array</code>, default:                   <code>None</code> )           \u2013            <p>Spectral power distribution data. Defaults to None.</p> </li> </ul> Source code in <code>src/prepost/source/main.py</code> <pre><code>def __init__(self,wt: WindTurbine=None,atmos: Les=None,mesh: Mesh=None,Spp: np.array=None):\n    \"\"\"\n    Initialize the Source object with wind turbine, atmosphere, mesh, and spectral data.\n\n    Args:\n        wt (WindTurbine, optional): Wind turbine object. Defaults to None.\n        atmos (Les, optional): Atmospheric conditions. Defaults to None.\n        mesh (Mesh, optional): Computational mesh. Defaults to None.\n        Spp (np.array, optional): Spectral power distribution data. Defaults to None.\n    \"\"\"\n    self.wt = wt\n    self.atmos = atmos\n    self.mesh = mesh\n    self.Spp = Spp\n\n    if self.Spp is not None:\n        self.nx = self.Spp.shape[0]\n        self.nz = self.Spp.shape[1]\n        self.ntau = self.Spp.shape[2]\n        self.Nfreq = self.Spp.shape[4]\n        self.Nbeta = self.Spp.shape[5]\n    if self.wt is not None :\n        self.Nseg = self.wt.Nseg\n        self.Nblade = self.wt.Nblade\n</code></pre>"},{"location":"reference/source/main.html#src.prepost.source.main.Source.read_pickle","title":"<code>read_pickle(filename)</code>","text":"<p>Load the source data from a pickle file.</p> <p>Parameters:</p> <ul> <li> <code>filename</code>               (<code>str</code>)           \u2013            <p>Path to the pickle file.</p> </li> </ul> Source code in <code>src/prepost/source/main.py</code> <pre><code>def read_pickle(self,filename: str):\n    \"\"\"\n    Load the source data from a pickle file.\n\n    Args:\n        filename (str): Path to the pickle file.\n    \"\"\"\n    repo_out = pickle.load(open(filename,'rb'))\n    self.wt = repo_out['wind_turbine']\n    self.atmos = repo_out['atmos']\n    self.mesh = repo_out['mesh']\n    self.Spp = repo_out['Spp']\n\n    self.nx = self.Spp.shape[0]\n    self.nz = self.Spp.shape[1]\n    self.ntau = self.Spp.shape[2]\n    self.Nseg = self.wt.Nseg\n    self.Nblade = self.wt.Nblade\n    self.Nfreq = self.Spp.shape[4]\n    self.Nbeta = self.Spp.shape[5]\n</code></pre>"},{"location":"reference/source/main.html#src.prepost.source.main.Source.save","title":"<code>save(fname, atmos_data=True)</code>","text":"<p>Save the current Source object to a file.</p> <p>Parameters:</p> <ul> <li> <code>fname</code>               (<code>str</code>)           \u2013            <p>The filename to save data.</p> </li> <li> <code>atmos_data</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to include atmospheric data. Defaults to True.</p> </li> </ul> Source code in <code>src/prepost/source/main.py</code> <pre><code>def save(self, fname: str, atmos_data: bool = True) -&gt; None:\n    \"\"\"\n    Save the current Source object to a file.\n\n    Args:\n        fname (str): The filename to save data.\n        atmos_data (bool, optional): Whether to include atmospheric data. Defaults to True.\n    \"\"\"\n\n    if atmos_data == False:\n        self.atmos = None\n    with open(fname,'wb') as file:\n        pickle.dump(self.__dict__,file)\n</code></pre>"},{"location":"reference/source/main.html#src.prepost.source.main.Source.load","title":"<code>load(fname)</code>","text":"<p>Load the Source object from a file.</p> <p>Parameters:</p> <ul> <li> <code>fname</code>               (<code>str</code>)           \u2013            <p>The filename to load data from.</p> </li> </ul> Source code in <code>src/prepost/source/main.py</code> <pre><code>def load(self, fname: str) -&gt; None:\n    \"\"\"\n    Load the Source object from a file.\n\n    Args:\n        fname (str): The filename to load data from.\n    \"\"\"\n    print('loading source ...')\n    with open(fname,'rb') as file:\n        self.__dict__ = pickle.load(file)\n    print('done.')\n</code></pre>"},{"location":"reference/source/main.html#src.prepost.source.main.Source.computeSpp","title":"<code>computeSpp(freq, Ncore=16, BEM=False)</code>","text":"<p>Compute the spectral power distribution (Spp) for given frequencies.</p> <p>Parameters:</p> <ul> <li> <code>freq</code>               (<code>array</code>)           \u2013            <p>Array of frequencies.</p> </li> <li> <code>Ncore</code>               (<code>int</code>, default:                   <code>16</code> )           \u2013            <p>Number of CPU cores to use. Defaults to 16.</p> </li> <li> <code>BEM</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Use BEM (Blade Element Momentum) method. Defaults to False.</p> </li> </ul> Source code in <code>src/prepost/source/main.py</code> <pre><code>def computeSpp(self, freq: np.array, Ncore: int = 16, BEM: bool = False) -&gt; None:\n    \"\"\"\n    Compute the spectral power distribution (Spp) for given frequencies.\n\n    Args:\n        freq (np.array): Array of frequencies.\n        Ncore (int, optional): Number of CPU cores to use. Defaults to 16.\n        BEM (bool, optional): Use BEM (Blade Element Momentum) method. Defaults to False.\n    \"\"\"\n    self.frequencies = freq\n    self.Nfreq = len(freq)\n    # rotate mesh : \n    mesh = self.mesh\n    # mesh.tau_array = mesh.tau_array - self.wt.tau\n    mesh.tau_coord = mesh.tau_coord - self.wt.tau\n    (self.Spp, self.Spp_tin, self.Spp_ten, self.SWL,\n    self.AoA, self.U_inf,self.epsilon,self.U_rot,self.U_rel, self.a, self.adash  \n                )  = SPL_SWL_parallel(self.wt,self.atmos,mesh,freq,Ncore,BEM)\n    # print(self.Spp.shape)\n    # print(self.Spp_tin.shape)\n    if self.mesh.polar:\n        self.Spp = self.Spp.reshape(self.mesh.nx,self.mesh.nz,self.mesh.ntau,self.wt.Nblade*self.wt.Nseg,self.Nfreq,self.wt.Nbeta)\n        self.Spp_tin = self.Spp_tin.reshape(self.mesh.nx,self.mesh.nz,self.mesh.ntau,self.wt.Nblade*self.wt.Nseg,self.Nfreq,self.wt.Nbeta)\n        self.Spp_ten = self.Spp_ten.reshape(self.mesh.nx,self.mesh.nz,self.mesh.ntau,self.wt.Nblade*self.wt.Nseg,self.Nfreq,self.wt.Nbeta)\n        self.SWL = self.SWL.reshape(self.mesh.nx,self.mesh.nz,self.mesh.ntau,self.wt.Nblade*self.wt.Nseg,self.Nfreq,self.wt.Nbeta)\n        self.nx = self.Spp.shape[0]\n        self.nz = self.Spp.shape[1]\n        self.ntau = self.Spp.shape[2]\n    else : \n        self.Spp = self.Spp.reshape(self.mesh.nx,self.mesh.nz,self.mesh.ny,self.wt.Nblade*self.wt.Nseg,self.Nfreq,self.wt.Nbeta)\n        self.Spp_tin = self.Spp_tin.reshape(self.mesh.nx,self.mesh.nz,self.mesh.ny,self.wt.Nblade*self.wt.Nseg,self.Nfreq,self.wt.Nbeta)\n        self.Spp_ten = self.Spp_ten.reshape(self.mesh.nx,self.mesh.nz,self.mesh.ny,self.wt.Nblade*self.wt.Nseg,self.Nfreq,self.wt.Nbeta)\n        self.SWL = self.SWL.reshape(self.mesh.nx,self.mesh.nz,self.mesh.ny,self.wt.Nblade*self.wt.Nseg,self.Nfreq,self.wt.Nbeta)\n        self.nx = self.Spp.shape[0]\n        self.nz = self.Spp.shape[1]\n        self.ny = self.Spp.shape[2]\n\n\n    self.Nseg = self.Spp.shape[3]\n    self.Nfreq = self.Spp.shape[4]\n    self.Nbeta = self.Spp.shape[5]\n</code></pre>"},{"location":"reference/source/main.html#src.prepost.source.main.Source.interpolate_xy","title":"<code>interpolate_xy(x, y)</code>","text":"<p>Perform 2D interpolation over the XY plane.  Moves form self.Spp(mesh.x_array, mesh.y_array, mesh.z_array) to  self.SppInterpolated(self.x_interpolated, self.y_interpolated, self.z_interpolated)</p> <p>Parameters:</p> <ul> <li> <code>x</code>               (<code>array</code>)           \u2013            <p>Array of x-coordinates.</p> </li> <li> <code>y</code>               (<code>array</code>)           \u2013            <p>Array of y-coordinates.</p> </li> </ul> Source code in <code>src/prepost/source/main.py</code> <pre><code>def interpolate_xy(self, x: np.array, y: np.array) -&gt; None:\n    \"\"\"\n    Perform 2D interpolation over the XY plane. \n    Moves form self.Spp(mesh.x_array, mesh.y_array, mesh.z_array) to \n    self.SppInterpolated(self.x_interpolated, self.y_interpolated, self.z_interpolated)\n\n    Args:\n        x (np.array): Array of x-coordinates.\n        y (np.array): Array of y-coordinates.\n    \"\"\"\n    logging.info('xy 2D interpolation ...')\n    x_grid,y_grid = np.meshgrid(self.mesh.x_array,self.mesh.y_array,indexing='ij')\n\n    xy_old = np.concatenate((x_grid.reshape((-1,1)),y_grid.reshape((-1,1))),1)\n\n    logging.info('start interpolation ...')\n    if (len(x.shape) == 1) and (len(y.shape==1)):\n        x_cart, y_cart = np.meshgrid(x, y, indexing='ij')\n        nx = x_cart.shape[0]\n        ny = x_cart.shape[1]\n        xy_new=np.zeros([nx* ny,2])\n        xy_new[:, 0] = x_cart .flatten()\n        xy_new[:, 1] = y_cart.flatten()\n    elif (len(x.shape) == 2) and (len(y.shape) == 2) and np.all(x.shape==y.shape):\n        nx = x.shape[0]\n        ny = x.shape[1]\n        print(nx)\n        print(ny)\n        xy_new=np.zeros([nx*ny,2])\n        xy_new[:, 0]=x.flatten()\n        xy_new[:, 1]=y.flatten()\n\n\n    vtx, wts = interp_weights(xy_old, xy_new)\n    logging.info('finished creating knot ...')\n\n    self.SppInterpolated = np.zeros((nx,ny,self.nz,self.Nseg,self.Nfreq,self.Nbeta))\n\n    logging.info('starting loop on height and frequency band ...')\n    print(self.nz)\n    print(self.Nseg)\n    print(self.Nfreq)\n    for iz in tqdm(range(self.nz)):\n        for iseg in range(self.Nseg):\n            print(iseg)\n            for ifreq in range(self.Nfreq):\n                for ibeta in range(self.Nbeta):\n                    values = self.Spp[:,iz,:,iseg,ifreq,ibeta].flatten()\n                    valuesInterpolated = interpolate(values, vtx, wts)\n                    self.SppInterpolated[:,:,iz,iseg,ifreq,ibeta] = valuesInterpolated.reshape(nx,ny)\n    logging.info('done')\n\n    # create new 3D mesh \n    self.x_interpolate = np.meshgrid(xy_new[:,0],\n                                     self.mesh.z_array,\n                                     indexing='ij')[0].reshape(nx,ny,self.nz)\n    self.y_interpolate = np.meshgrid(xy_new[:,1],\n                                     self.mesh.z_array,\n                                     indexing='ij')[0].reshape(nx,ny,self.nz)\n    self.z_interpolate = np.meshgrid(xy_new[:,1],\n                                     self.mesh.z_array,\n                                     indexing='ij')[1].reshape(nx,ny,self.nz)\n</code></pre>"},{"location":"reference/source/main.html#src.prepost.source.main.Source.interpolate_xz","title":"<code>interpolate_xz(x, z)</code>","text":"<p>Perform 2D interpolation over the XZ plane. Moves form self.Spp(mesh.x_array, mesh.y_array, mesh.z_array) to  self.SppInterpolated(self.x_interpolated, self.y_interpolated, self.z_interpolated)</p> <p>Parameters:</p> <ul> <li> <code>x</code>               (<code>array</code>)           \u2013            <p>Array of x-coordinates.</p> </li> <li> <code>z</code>               (<code>array</code>)           \u2013            <p>Array of z-coordinates.</p> </li> </ul> Source code in <code>src/prepost/source/main.py</code> <pre><code>def interpolate_xz(self, x: np.array, z: np.array) -&gt; None:\n    \"\"\"\n    Perform 2D interpolation over the XZ plane.\n    Moves form self.Spp(mesh.x_array, mesh.y_array, mesh.z_array) to \n    self.SppInterpolated(self.x_interpolated, self.y_interpolated, self.z_interpolated)\n\n    Args:\n        x (np.array): Array of x-coordinates.\n        z (np.array): Array of z-coordinates.\n    \"\"\"\n    logging.info('xz 2D interpolation ...')\n    x_grid,z_grid = np.meshgrid(self.mesh.x_array,self.mesh.z_array,indexing='ij')\n\n    xz_old = np.concatenate((x_grid.reshape((-1,1)),z_grid.reshape((-1,1))),1)\n\n    logging.info('start interpolation ...')\n    x_new,z_new = np.meshgrid(x,z,indexing='ij')\n    xz_cart=np.zeros([x_new.shape[0]*z_new .shape[1],2])\n    xz_cart[:,0]=x_new .flatten()\n    xz_cart[:,1]=z_new.flatten()\n    vtx, wts = interp_weights(xz_old, xz_cart)\n    logging.info('finished creating knot ...')\n\n    self.SppInterpolated = np.zeros((x_new.shape[0],self.ny,x_new.shape[1],self.Nseg,self.Nfreq,self.Nbeta))\n\n    logging.info('starting loop on height and frequency band ...')\n    # for iy in tqdm(range(self.ny)):\n    for iy in range(self.ny):\n        logging.debug('iy = %s'%(iy))\n        for iseg in range(self.Nseg):\n            logging.debug('iseg = %s'%(iseg))\n            for ifreq in range(self.Nfreq):\n                logging.debug('ifreq = %s'%(ifreq))\n                for ibeta in range(self.Nbeta):\n                    values = self.Spp[:,:,iy,iseg,ifreq,ibeta].flatten()\n                    valuesInterpolated = interpolate(values, vtx, wts)\n                    self.SppInterpolated[:,iy,:,iseg,ifreq,ibeta] = valuesInterpolated.reshape(x_new.shape[0],x_new.shape[1])\n    logging.info('done')\n    [self.x_interpolate,self.y_interpolate,self.z_interpolate] = np.meshgrid(x,self.mesh.y_array,z,indexing='ij')\n</code></pre>"},{"location":"reference/source/main.html#src.prepost.source.main.Source.interpolate_yz","title":"<code>interpolate_yz(y, z)</code>","text":"<p>Perform 2D interpolation over the YZ plane. Moves form self.Spp(mesh.x_array, mesh.y_array, mesh.z_array) to  self.SppInterpolated(self.x_interpolated, self.y_interpolated, self.z_interpolated)</p> <p>Parameters:</p> <ul> <li> <code>y</code>               (<code>array</code>)           \u2013            <p>Array of y-coordinates.</p> </li> <li> <code>z</code>               (<code>array</code>)           \u2013            <p>Array of z-coordinates.</p> </li> </ul> Source code in <code>src/prepost/source/main.py</code> <pre><code>def interpolate_yz(self, y: np.array, z: np.array) -&gt; None:\n    \"\"\"\n    Perform 2D interpolation over the YZ plane.\n    Moves form self.Spp(mesh.x_array, mesh.y_array, mesh.z_array) to \n    self.SppInterpolated(self.x_interpolated, self.y_interpolated, self.z_interpolated)\n\n    Args:\n        y (np.array): Array of y-coordinates.\n        z (np.array): Array of z-coordinates.\n    \"\"\"\n    y_grid,z_grid = np.meshgrid(self.mesh.y_array,self.mesh.z_array,indexing='ij')\n\n    yz_old = np.concatenate((y_grid.reshape((-1,1)),z_grid.reshape((-1,1))),1)\n\n    print('start interpolation ...')\n    y_new,z_new = np.meshgrid(y,z,indexing='ij')\n    yz_cart=np.zeros([y_new.shape[0]*z_new.shape[1],2])\n    yz_cart[:,0]=y_new .flatten()\n    yz_cart[:,1]=z_new.flatten()\n    vtx, wts = interp_weights(yz_old, yz_cart)\n    print('finished creating knot ...')\n\n    self.SppInterpolated = np.zeros((self.nx,y_new.shape[0],y_new.shape[1],self.Nseg,self.Nfreq,self.Nbeta))\n\n    print('starting loop on height and frequency band ...')\n\n    # transpose y /z \n    self.Spp = np.transpose(self.Spp, axes=(0,2,1,3,4,5))\n    for ix in tqdm(range(self.nx)):\n        for iseg in range(self.Nseg):\n            for ifreq in range(self.Nfreq):\n                for ibeta in range(self.Nbeta):\n                    values = self.Spp[ix,:,:,iseg,ifreq,ibeta].flatten()\n                    valuesInterpolated = interpolate(values, vtx, wts)\n                    self.SppInterpolated[ix,:,:,iseg,ifreq,ibeta] = valuesInterpolated.reshape(y_new.shape[0],y_new .shape[1])\n    print('done')\n    [self.x_interpolate, self.y_interpolate, self.z_interpolate] = np.meshgrid(self.mesh.x_array,y,z,indexing='ij')\n</code></pre>"},{"location":"reference/source/main.html#src.prepost.source.main.Source.convert_to_position","title":"<code>convert_to_position()</code>","text":"<p>Convert Spp and SWL data into position-based arrays. Useful for polar plot.</p> Source code in <code>src/prepost/source/main.py</code> <pre><code>def convert_to_position(self):\n    \"\"\"\n    Convert Spp and SWL data into position-based arrays.\n    Useful for polar plot.\n    \"\"\"\n\n    spp = np.transpose(self.SWL.reshape(\n        self.nx, self.ny, self.nz, self.Nseg//self.Nblade,\n        self.Nblade, self.Nfreq, self.Nbeta),\n        axes=(0, 1, 2, 3, 4, 6, 5))\n\n    self.swlPosition = np.zeros((self.nx, self.ny, self.nz,\n                            self.Nseg//self.Nblade,self.Nbeta*self.Nblade, self.Nfreq))\n\n    self.swlPosition[:, :, :, :, 0:12, :] = spp[:, :, :, :, 0, :, :]\n    self.swlPosition[:, :, :, :, 12:24, :] = spp[:, :, :, :, 1, :, :]\n    self.swlPosition[:, :, :, :, 24:, :] = spp[:, :, :, :, 2, :, :]\n\n    spp = np.transpose(self.Spp_tin.reshape(\n        self.nx, self.ny, self.nz, self.Nseg//self.Nblade,\n        self.Nblade, self.Nfreq, self.Nbeta),\n        axes=(0, 1, 2, 3, 4, 6, 5))\n\n    self.tinPosition = np.zeros((self.nx, self.ny, self.nz,\n                            self.Nseg//self.Nblade,self.Nbeta*self.Nblade, self.Nfreq))\n\n    self.tinPosition[:, :, :, :, 0:12, :] = spp[:, :, :, :, 0, :, :]\n    self.tinPosition[:, :, :, :, 12:24, :] = spp[:, :, :, :, 1, :, :]\n    self.tinPosition[:, :, :, :, 24:, :] = spp[:, :, :, :, 2, :, :]\n\n    spp = np.transpose(self.Spp_ten.reshape(\n        self.nx, self.ny, self.nz, self.Nseg//self.Nblade,\n        self.Nblade, self.Nfreq, self.Nbeta),\n        axes=(0, 1, 2, 3, 4, 6, 5))\n\n    self.tenPosition = np.zeros((self.nx, self.ny, self.nz,\n                            self.Nseg//self.Nblade,self.Nbeta*self.Nblade, self.Nfreq))\n\n    self.tenPosition[:, :, :, :, 0:12, :] = spp[:, :, :, :, 0, :, :]\n    self.tenPosition[:, :, :, :, 12:24, :] = spp[:, :, :, :, 1, :, :]\n    self.tenPosition[:, :, :, :, 24:, :] = spp[:, :, :, :, 2, :, :]\n\n    spp = np.transpose(self.Spp.reshape(\n        self.nx, self.ny, self.nz, self.Nseg//self.Nblade,\n        self.Nblade, self.Nfreq, self.Nbeta),\n        axes=(0, 1, 2, 3, 4, 6, 5))\n\n    self.sppPosition = np.zeros((self.nx, self.ny, self.nz,\n                            self.Nseg//self.Nblade,self.Nbeta*self.Nblade, self.Nfreq))\n\n    self.sppPosition[:, :, :, :, 0:12, :] = spp[:, :, :, :, 0, :, :]\n    self.sppPosition[:, :, :, :, 12:24, :] = spp[:, :, :, :, 1, :, :]\n    self.sppPosition[:, :, :, :, 24:, :] = spp[:, :, :, :, 2, :, :]\n    return\n</code></pre>"},{"location":"reference/source/main.html#src.prepost.source.main.Source.convert_to_one_blade","title":"<code>convert_to_one_blade()</code>","text":"<p>Aggregate data to represent a single blade's contribution to sound power levels.</p> Source code in <code>src/prepost/source/main.py</code> <pre><code>def convert_to_one_blade(self):\n    \"\"\"\n    Aggregate data to represent a single blade's contribution to sound power levels.\n    \"\"\"\n\n    spp = np.transpose(self.SWL.reshape(\n        self.ny, self.ny, self.nz, self.Nseg//self.Nblade,\n        self.Nblade, self.Nfreq, self.Nbeta),\n        axes=(0, 1, 2, 3, 4, 6, 5))\n\n    self.sppOneBlade = np.zeros((self.nx, self.ny, self.nz,\n                            self.Nbeta*self.Nblade, self.Nfreq))\n\n    self.sppOneBlade[:, :, :, 0:12, :] = 10 * \\\n        np.log10(np.sum(10**(spp[:, :, :, :, 0, :, :]/10), (3)))\n    self.sppOneBlade[:, :, :, 12:24, :] = 10 * \\\n        np.log10(np.sum(10**(spp[:, :, :, :,  1, :, :]/10), (3)))\n    self.sppOneBlade[:, :, :, 24:, :] = 10 * \\\n        np.log10(np.sum(10**(spp[:, :,:, :, 2, :, :]/10), (3)))\n    return\n</code></pre>"},{"location":"reference/source/main.html#src.prepost.source.main.Source.compute_oaswl","title":"<code>compute_oaswl()</code>","text":"<p>Compute the overall A-weighted sound power levels.</p> <p>Returns:</p> <ul> <li> <code>int</code> (              <code>int</code> )          \u2013            <p>Returns -1 if an error occurs.</p> </li> </ul> Source code in <code>src/prepost/source/main.py</code> <pre><code>def compute_oaswl(self) -&gt; int:\n    \"\"\"\n    Compute the overall A-weighted sound power levels.\n\n    Returns:\n        int: Returns -1 if an error occurs.\n    \"\"\"\n\n    if not hasattr(self, \"swlPosition\"):\n        print('error')\n        return -1\n\n    swl = self.swlPosition\n    self.fc, swl_3rd = integrateThirdOctave(self.frequencies,10**(swl/10))\n    self.oaswl_db = 10*np.log10(np.sum(swl_3rd,5))\n    self.oaswl_dbA = 10*np.log10(np.sum(swl_3rd * 10**(Aweight(self.fc).reshape(1,1,1,1,1,-1)/10),5))\n\n    spp = self.tinPosition\n    self.fc, swl_3rd = integrateThirdOctave(self.frequencies,10**(spp/10))\n    self.tin_dbA = 10*np.log10(np.sum(swl_3rd * 10**(Aweight(self.fc).reshape(1,1,1,1,1,-1)/10),5))\n\n    spp = self.tenPosition\n    self.fc, swl_3rd = integrateThirdOctave(self.frequencies,10**(spp/10))\n    self.ten_dbA = 10*np.log10(np.sum(swl_3rd * 10**(Aweight(self.fc).reshape(1,1,1,1,1,-1)/10),5))\n\n    spp = self.sppPosition\n    self.fc, swl_3rd = integrateThirdOctave(self.frequencies,10**(spp/10))\n    self.spp_dbA = 10*np.log10(np.sum(swl_3rd * 10**(Aweight(self.fc).reshape(1,1,1,1,1,-1)/10),5))\n    return\n</code></pre>"},{"location":"reference/source/main.html#src.prepost.source.main.Source.print_info","title":"<code>print_info(x, y, z)</code>","text":"<p>Print information about the sound power level at a given position.</p> <p>Parameters:</p> <ul> <li> <code>x</code>               (<code>float</code>)           \u2013            <p>X-coordinate.</p> </li> <li> <code>y</code>               (<code>float</code>)           \u2013            <p>Y-coordinate.</p> </li> <li> <code>z</code>               (<code>float</code>)           \u2013            <p>Z-coordinate.</p> </li> </ul> Source code in <code>src/prepost/source/main.py</code> <pre><code>def print_info(self, x: float, y: float, z: float) -&gt; None:\n    \"\"\"\n    Print information about the sound power level at a given position.\n\n    Args:\n        x (float): X-coordinate.\n        y (float): Y-coordinate.\n        z (float): Z-coordinate.\n    \"\"\"\n    ix = np.abs(self.mesh.x_array - x).argmin()\n    iy = np.abs(self.mesh.y_array - y).argmin()\n    iz = np.abs(self.mesh.z_array - z).argmin()\n\n    swl_dbA = 10*np.log10(np.sum(10**(self.SWL[ix, iz, iy, ...]/10),\n              (0, 2))/self.Nbeta)+Aweight(self.frequencies)\n\n    swl_db = 10*np.log10(np.sum(10**(self.SWL[ix, iz, iy, ...]/10),\n              (0, 2))/self.Nbeta)\n\n    print('SWL (dBA)=')\n    print(10*np.log10(simpson(y=10**(swl_dbA/10), x=self.frequencies)))\n\n    print('SWL (dB)=')\n    print(10*np.log10(simpson(y=10**(swl_db/10), x=self.frequencies)))\n\n    print('omega (rpm)=')\n    print(self.wt.omega * 60 / (2*np.pi))\n</code></pre>"},{"location":"reference/source/main.html#src.prepost.source.main.Source.plot_atmos","title":"<code>plot_atmos()</code>","text":"<p>Plot atmospheric data such as wind speed and turbulence.</p> Source code in <code>src/prepost/source/main.py</code> <pre><code>def plot_atmos(self) -&gt; None:\n    \"\"\"\n    Plot atmospheric data such as wind speed and turbulence.\n    \"\"\"\n    plt.figure(0)\n    plt.plot(self.atmos.U_inf,self.atmos.z_coord)\n    plt.xlabel('$u_{inf}$ (m/s)')\n    plt.ylabel('$z$ (m)')\n\n    plt.figure(1)\n    plt.plot(self.atmos.epsilon_Kol,self.atmos.z_coord)\n    plt.xlabel('$\\epsilon$ (m2/s3)')\n    plt.ylabel('$z$ (m)')\n</code></pre>"},{"location":"reference/source/main.html#src.prepost.source.main.Source.plot_OASWL","title":"<code>plot_OASWL(ix, iy, iz, **kwargs)</code>","text":"<p>Plot the overall A-weighted sound power level in a polar plot.</p> <p>Parameters:</p> <ul> <li> <code>ix</code>               (<code>int</code>)           \u2013            <p>Index along the x-axis.</p> </li> <li> <code>iy</code>               (<code>int</code>)           \u2013            <p>Index along the y-axis.</p> </li> <li> <code>iz</code>               (<code>int</code>)           \u2013            <p>Index along the z-axis.</p> </li> </ul> Source code in <code>src/prepost/source/main.py</code> <pre><code>def plot_OASWL(self, ix: int, iy: int, iz: int, **kwargs) -&gt; None:\n    \"\"\"\n    Plot the overall A-weighted sound power level in a polar plot.\n\n    Args:\n        ix (int): Index along the x-axis.\n        iy (int): Index along the y-axis.\n        iz (int): Index along the z-axis.\n    \"\"\"\n    self.convert_to_position()\n    self.compute_oaswl()\n    r = self.wt.seg\n    self.wt.computeBeta()\n    beta = self.wt.beta.reshape(self.wt.Nblade*self.wt.Nbeta)\n    R,B = np.meshgrid(r,beta)\n\n    fig = plt.gcf() \n    ax = fig.add_subplot(polar = True)\n    cax = ax.pcolormesh(B.T + np.pi/2,R.T,self.oaswl_dbA[ix,iy,iz],**kwargs)\n    plt.gca().set_yticklabels([])\n    plt.gca().set_xticklabels([])\n</code></pre>"},{"location":"reference/source/main.html#src.prepost.source.main.Source.plot_tin_ten","title":"<code>plot_tin_ten(ix, iy, iz, **kwargs)</code>","text":"<p>Plot tonal and broadband noise contributions.</p> <p>Parameters:</p> <ul> <li> <code>ix</code>               (<code>int</code>)           \u2013            <p>Index along the x-axis.</p> </li> <li> <code>iy</code>               (<code>int</code>)           \u2013            <p>Index along the y-axis.</p> </li> <li> <code>iz</code>               (<code>int</code>)           \u2013            <p>Index along the z-axis.</p> </li> </ul> Source code in <code>src/prepost/source/main.py</code> <pre><code>def plot_tin_ten(self, ix: int, iy: int, iz: int, **kwargs) -&gt; None:\n    \"\"\"\n    Plot tonal and broadband noise contributions.\n\n    Args:\n        ix (int): Index along the x-axis.\n        iy (int): Index along the y-axis.\n        iz (int): Index along the z-axis.\n    \"\"\"\n    self.convert_to_position()\n    self.compute_oaswl()\n\n    r = self.wt.seg\n    self.wt.computeBeta()\n    beta = self.wt.beta.reshape(self.wt.Nblade*self.wt.Nbeta)\n    R,B = np.meshgrid(r,beta)\n\n    R_tot = np.sqrt((self.mesh.x_array[ix]-self.wt.absolute_pos[0])**2 \n                    + (self.mesh.y_array[iy]-self.wt.absolute_pos[1])**2)\n\n    fig = plt.gcf()\n    ax = fig.add_subplot(1, 3, 1, polar=True)\n    cax = ax.pcolormesh(B.T + np.pi/2,R.T,\n                        self.tin_dbA[ix,iy,iz]+10*np.log10(2*np.pi*R_tot**2),\n                        **kwargs)\n    plt.gca().set_yticklabels([])\n    plt.gca().set_xticklabels([])\n    plt.colorbar(cax)\n    ax.set_title('SWL TIN')\n\n    #fig = plt.gcf()\n    ax = fig.add_subplot(1, 3, 2, polar=True)\n    cax = ax.pcolormesh(B.T + np.pi/2,R.T,\n                        self.ten_dbA[ix,iy,iz]+10*np.log10(2*np.pi*R_tot**2),\n                        **kwargs)\n    plt.gca().set_yticklabels([])\n    plt.gca().set_xticklabels([])\n    plt.colorbar(cax)\n    ax.set_title('SWL TEN')\n\n\n    # fig = plt.figure(1)\n    ax = fig.add_subplot(1, 3, 3, polar=True)\n    cax = ax.pcolormesh(B.T + np.pi/2,R.T,\n                        self.spp_dbA[ix,iy,iz]+10*np.log10(2*np.pi*R_tot**2),\n                        **kwargs)\n    plt.gca().set_yticklabels([])\n    plt.gca().set_xticklabels([])\n    plt.colorbar(cax)\n    ax.set_title('SWL tot')\n</code></pre>"},{"location":"reference/source/main.html#src.prepost.source.main.Source.plot_AoA","title":"<code>plot_AoA(**kwargs)</code>","text":"<p>Plot the angle of attack distribution.</p> <p>Returns:</p> <ul> <li> <code>Axes</code>           \u2013            <p>plt.Axes: Matplotlib axis with the plot.</p> </li> </ul> Source code in <code>src/prepost/source/main.py</code> <pre><code>def plot_AoA(self, **kwargs) -&gt; plt.Axes:\n    \"\"\"\n    Plot the angle of attack distribution.\n\n    Returns:\n        plt.Axes: Matplotlib axis with the plot.\n    \"\"\"\n    r = self.wt.seg\n    self.wt.computeBeta()\n    beta = self.wt.beta.reshape(self.wt.Nblade*self.wt.Nbeta)\n    R,B = np.meshgrid(r,beta,indexing='ij')\n    AoA = self.AoA.reshape(self.wt.Nblade,self.wt.Nseg,self.wt.Nbeta)\n    AoA = AoA.transpose((1,0,2))\n    AoA = AoA.reshape(self.wt.Nseg,self.wt.Nblade*self.wt.Nbeta)\n\n    fig = plt.gcf()\n    ax = fig.add_subplot(polar=True)\n\n    #B = np.concatenate((B,B[:,0:1]),1)\n    #R = np.concatenate((R,R[:,0:1]),1)\n    #AoA = np.concatenate((AoA,AoA[:,0:1]),1)\n    cax = ax.pcolormesh(B + np.pi/2,R,AoA,vmin=2,vmax=5,shading='auto',**kwargs)#,edgecolors='k')   \n    plt.gca().set_yticklabels([])\n    plt.gca().set_xticklabels([])\n    # plt.colorbar()\n    return cax\n</code></pre>"},{"location":"reference/source/main.html#src.prepost.source.main.Source.plot_all_u","title":"<code>plot_all_u(**kwargs)</code>","text":"<p>Plot various wind velocity components.</p> Source code in <code>src/prepost/source/main.py</code> <pre><code>def plot_all_u(self, **kwargs) -&gt; None:\n    \"\"\"\n    Plot various wind velocity components.\n    \"\"\"\n    r = self.wt.seg\n    self.wt.computeBeta()\n    beta = self.wt.beta.reshape(self.wt.Nblade*self.wt.Nbeta)\n    R,B = np.meshgrid(r,beta,indexing='ij')\n\n    # fig = plt.figure()\n    fig = plt.gcf()\n\n    #----------------------------------------------------------------------\n    eps = self.epsilon.reshape(self.wt.Nblade,self.wt.Nseg,self.wt.Nbeta)\n    eps = eps.transpose((1,0,2))\n    eps = eps.reshape(self.wt.Nseg,self.wt.Nblade*self.wt.Nbeta)\n\n    ax = fig.add_subplot(1,4,1,polar=True)\n    cax = ax.pcolormesh(B.T + np.pi/2, R.T, eps.T,cmap=\"Blues\",\n                        vmin=0.01, vmax=0.09,\n                        shading='auto',**kwargs)#,edgecolors='k')   \n    ax.set_yticklabels([])\n    ax.set_xticklabels([])\n    plt.colorbar(cax)\n    ax.set_title('eps')\n\n    #----------------------------------------------------------------------\n    U_inf = self.U_inf.reshape(self.wt.Nblade,self.wt.Nseg,self.wt.Nbeta)\n    U_inf = U_inf.transpose((1,0,2))\n    U_inf = U_inf.reshape(self.wt.Nseg,self.wt.Nblade*self.wt.Nbeta)\n\n    ax = fig.add_subplot(1,4,2,polar=True)\n    cax = ax.pcolormesh(B.T + np.pi/2, R.T, U_inf.T,shading='auto',\n                        vmin=4,vmax=11,\n                        cmap=\"RdYlBu_r\", **kwargs)\n    ax.set_yticklabels([])\n    ax.set_xticklabels([])\n    plt.colorbar(cax)\n    ax.set_title('U_inf')\n\n    # ----------------------------------------------------------------------\n    U_rel = self.U_rel.reshape(self.wt.Nblade,self.wt.Nseg,self.wt.Nbeta)\n    U_rel = U_rel.transpose((1,0,2))\n    U_rel = U_rel.reshape(self.wt.Nseg,self.wt.Nblade*self.wt.Nbeta)\n\n    ax = fig.add_subplot(1,4,3,polar=True)\n    cax = ax.pcolormesh(B.T + np.pi/2, R.T, U_rel.T,\n                        vmin=10,vmax=60,**kwargs)\n    ax.set_yticklabels([])\n    ax.set_xticklabels([])\n    plt.colorbar(cax)\n    ax.set_title('U_rel')\n\n    # ----------------------------------------------------------------------\n    AoA = self.AoA.reshape(self.wt.Nblade,self.wt.Nseg,self.wt.Nbeta)\n    AoA = AoA.transpose((1,0,2))\n    AoA = AoA.reshape(self.wt.Nseg,self.wt.Nblade*self.wt.Nbeta)\n\n    ax = fig.add_subplot(1,4,4,polar=True)\n    cax = ax.pcolormesh(B.T + np.pi/2,R.T,AoA.T,\n                        vmin=2, vmax=10,\n                        shading='auto',**kwargs)#,edgecolors='k')   \n    plt.gca().set_yticklabels([])\n    plt.gca().set_xticklabels([])\n    plt.colorbar(cax)\n    ax.set_title('AoA')\n</code></pre>"},{"location":"reference/source/main.html#src.prepost.source.main.Source.plot_epsilon","title":"<code>plot_epsilon(shading='auto', **kwargs)</code>","text":"<p>Plot turbulence dissipation rate.</p> <p>Parameters:</p> <ul> <li> <code>shading</code>               (<code>str</code>, default:                   <code>'auto'</code> )           \u2013            <p>Shading style for the plot. Defaults to 'auto'.</p> </li> </ul> Source code in <code>src/prepost/source/main.py</code> <pre><code>def plot_epsilon(self, shading: str = 'auto', **kwargs) -&gt; None:\n    \"\"\"\n    Plot turbulence dissipation rate.\n\n    Args:\n        shading (str, optional): Shading style for the plot. Defaults to 'auto'.\n    \"\"\"\n    r = self.wt.seg\n    self.wt.computeBeta()\n    beta = self.wt.beta.reshape(self.wt.Nblade*self.wt.Nbeta)\n    R,B = np.meshgrid(r,beta)\n\n    eps = self.epsilon.reshape(self.wt.Nblade,self.wt.Nseg,self.wt.Nbeta)\n    eps = eps.transpose((1,0,2))\n    eps = eps.reshape(self.wt.Nseg,self.wt.Nblade*self.wt.Nbeta)\n\n    if shading==\"gouraud\":\n        R = np.concatenate((R,R[0:1,:]),axis=0)\n        B = np.concatenate((B,B[0:1,:]),axis=0)\n        eps = np.concatenate((eps,eps[:,0:1]),axis=1)\n\n    fig = plt.figure()\n    ax = fig.add_subplot(polar=True)\n    cax = ax.pcolormesh(B.T + np.pi/2, R.T, eps,shading=shading,**kwargs)#,edgecolors='k')   \n    ax.set_yticklabels([])\n    ax.set_xticklabels([])\n</code></pre>"},{"location":"reference/source/main.html#src.prepost.source.main.Source.plot_Uinf","title":"<code>plot_Uinf(shading='auto', **kwargs)</code>","text":"<p>Plot free-stream wind velocity.</p> <p>Parameters:</p> <ul> <li> <code>shading</code>               (<code>str</code>, default:                   <code>'auto'</code> )           \u2013            <p>Shading style for the plot. Defaults to 'auto'.</p> </li> </ul> Source code in <code>src/prepost/source/main.py</code> <pre><code>def plot_Uinf(self, shading: str = 'auto', **kwargs) -&gt; None:\n    \"\"\"\n    Plot free-stream wind velocity.\n\n    Args:\n        shading (str, optional): Shading style for the plot. Defaults to 'auto'.\n    \"\"\"\n    r = self.wt.seg\n    self.wt.computeBeta()\n    beta = self.wt.beta.reshape(self.wt.Nblade*self.wt.Nbeta)\n    R,B = np.meshgrid(r,beta)\n\n    U_inf = self.U_inf.reshape(self.wt.Nblade,self.wt.Nseg,self.wt.Nbeta)\n    U_inf = U_inf.transpose((1,0,2))\n    U_inf = U_inf.reshape(self.wt.Nseg,self.wt.Nblade*self.wt.Nbeta)\n    if shading==\"gouraud\":\n        R = np.concatenate((R,R[0:1,:]),axis=0)\n        B = np.concatenate((B,B[0:1,:]),axis=0)\n        U_inf = np.concatenate((U_inf,U_inf[:,0:1]),axis=1)\n\n    fig = plt.figure()\n    # ax = fig.add_subplot(131, polar = True)\n    # cax = ax.pcolormesh(B.T + np.pi/2,R.T,U_rel,cmap='RdBu_r',shading='auto')#,edgecolors='k')   \n    # ax.set_yticklabels([])\n    # ax.set_xticklabels([])\n    #plt.colorbar(cax)\n\n    ax = fig.add_subplot(polar=True)\n    cax = ax.pcolormesh(B.T + np.pi/2, R.T, U_inf,shading=shading,**kwargs)\n    ax.set_yticklabels([])\n    ax.set_xticklabels([])\n</code></pre>"},{"location":"reference/source/main.html#src.prepost.source.main.Source.plot_Urel","title":"<code>plot_Urel(shading='auto', **kwargs)</code>","text":"<p>Plot relative wind velocity.</p> <p>Parameters:</p> <ul> <li> <code>shading</code>               (<code>str</code>, default:                   <code>'auto'</code> )           \u2013            <p>Shading style for the plot. Defaults to 'auto'.</p> </li> </ul> Source code in <code>src/prepost/source/main.py</code> <pre><code>def plot_Urel(self, shading: str = 'auto', **kwargs) -&gt; None:\n    \"\"\"\n    Plot relative wind velocity.\n\n    Args:\n        shading (str, optional): Shading style for the plot. Defaults to 'auto'.\n    \"\"\"\n    r = self.wt.seg\n    self.wt.computeBeta()\n    beta = self.wt.beta.reshape(self.wt.Nblade*self.wt.Nbeta)\n    R,B = np.meshgrid(r,beta)\n\n    U_rel = self.U_rel.reshape(self.wt.Nblade,self.wt.Nseg,self.wt.Nbeta)\n    U_rel = U_rel.transpose((1,0,2))\n    U_rel = U_rel.reshape(self.wt.Nseg,self.wt.Nblade*self.wt.Nbeta)\n\n    if shading==\"gouraud\":\n        R = np.concatenate((R,R[0:1,:]),axis=0)\n        B = np.concatenate((B,B[0:1,:]),axis=0)\n        U_rel = np.concatenate((U_rel,U_rel[:,0:1]),axis=1)\n\n    fig = plt.figure()\n    ax = fig.add_subplot(polar=True)\n    cax = ax.pcolormesh(B.T + np.pi/2, R.T, U_rel,shading=shading,**kwargs)\n    ax.set_yticklabels([])\n    ax.set_xticklabels([])\n</code></pre>"},{"location":"reference/source/main.html#src.prepost.source.main.Source.plot_Urot","title":"<code>plot_Urot(shading='auto')</code>","text":"<p>Plot the rotational velocity.</p> <p>Parameters:</p> <ul> <li> <code>shading</code>               (<code>str</code>, default:                   <code>'auto'</code> )           \u2013            <p>Shading style for the plot. Defaults to 'auto'.</p> </li> </ul> Source code in <code>src/prepost/source/main.py</code> <pre><code>def plot_Urot(self, shading: str = 'auto') -&gt; None:\n    \"\"\"\n    Plot the rotational velocity.\n\n    Args:\n        shading (str, optional): Shading style for the plot. Defaults to 'auto'.\n    \"\"\"\n    r = self.wt.seg\n    self.wt.computeBeta()\n    beta = self.wt.beta.reshape(self.wt.Nblade*self.wt.Nbeta)\n    R,B = np.meshgrid(r,beta)\n\n    U_rot = self.U_rot.reshape(self.wt.Nblade,self.wt.Nseg,self.wt.Nbeta)\n    U_rot = U_rot.transpose((1,0,2))\n    U_rot = U_rot.reshape(self.wt.Nseg,self.wt.Nblade*self.wt.Nbeta)\n\n    if shading==\"gouraud\":\n        R = np.concatenate((R,R[0:1,:]),axis=0)\n        B = np.concatenate((B,B[0:1,:]),axis=0)\n        U_rot = np.concatenate((U_rot,U_rot[:,0:1]),axis=1)\n\n    fig = plt.figure()\n    ax = fig.add_subplot(polar=True)\n    cax = ax.pcolormesh(B.T + np.pi/2, R.T, U_rot,shading=shading,**kwargs)   \n    ax.set_yticklabels([])\n    ax.set_xticklabels([])\n</code></pre>"},{"location":"reference/source/main.html#src.prepost.source.main.Source.plot_induction","title":"<code>plot_induction()</code>","text":"<p>Plot the induction factors (axial and tangential).</p> Source code in <code>src/prepost/source/main.py</code> <pre><code>def plot_induction(self) -&gt; None:\n    \"\"\"\n    Plot the induction factors (axial and tangential).\n    \"\"\"\n    r = self.wt.seg\n    self.wt.computeBeta()\n    beta = self.wt.beta.reshape(self.wt.Nblade*self.wt.Nbeta)\n    R,B = np.meshgrid(r,beta)\n    a = self.a.reshape(self.wt.Nblade,self.wt.Nseg,self.wt.Nbeta)\n    a = a.transpose((1,0,2))\n    a = a.reshape(self.wt.Nseg,self.wt.Nblade*self.wt.Nbeta)\n\n    adash = self.adash.reshape(self.wt.Nblade,self.wt.Nseg,self.wt.Nbeta)\n    adash = adash.transpose((1,0,2))\n    adash = adash.reshape(self.wt.Nseg,self.wt.Nblade*self.wt.Nbeta)\n\n\n    fig = plt.figure()\n    ax = fig.add_subplot(121, polar = True)\n    cax = ax.pcolormesh(B.T + np.pi/2,R.T,a,cmap='RdBu_r',shading='auto')#,edgecolors='k')   \n    ax.set_yticklabels([])\n    ax.set_xticklabels([])\n    plt.colorbar(cax)\n\n    ax = fig.add_subplot(122, polar = True)\n    cax = ax.pcolormesh(B.T + np.pi/2,R.T,adash,cmap='RdBu_r',shading='auto')#,edgecolors='k')   \n    ax.set_yticklabels([])\n    ax.set_xticklabels([])\n    plt.colorbar(cax)\n</code></pre>"},{"location":"reference/source/mesh.html","title":"Reference for <code>prepost/source/mesh.py</code>","text":""},{"location":"reference/source/mesh.html#src.prepost.source.mesh.Mesh","title":"<code>Mesh(polar)</code>","text":"<p>A class to create, manipulate, and transform spatial meshes in Cartesian and polar coordinate systems.</p> <p>The Mesh class provides methods to generate Cartesian and polar meshes, transform between coordinate systems, add topography or curvilinear features, and apply shifts.</p> Source code in <code>src/prepost/source/mesh.py</code> <pre><code>def __init__(self, polar):\n    self.polar = polar\n</code></pre>"},{"location":"reference/source/mesh.html#src.prepost.source.mesh.Mesh.create_polar_mesh","title":"<code>create_polar_mesh(xmin, xmax, dx, zmin, zmax, dz, taumin, taumax, dtau)</code>","text":"<p>Create a polar mesh with specified spatial and angular ranges.</p> <p>Parameters:</p> <ul> <li> <code>xmin</code>               (<code>float</code>)           \u2013            <p>Minimum x value.</p> </li> <li> <code>xmax</code>               (<code>float</code>)           \u2013            <p>Maximum x value.</p> </li> <li> <code>dx</code>               (<code>float</code>)           \u2013            <p>Step size for x.</p> </li> <li> <code>zmin</code>               (<code>float</code>)           \u2013            <p>Minimum z value.</p> </li> <li> <code>zmax</code>               (<code>float</code>)           \u2013            <p>Maximum z value.</p> </li> <li> <code>dz</code>               (<code>float</code>)           \u2013            <p>Step size for z.</p> </li> <li> <code>taumin</code>               (<code>float</code>)           \u2013            <p>Minimum tau value (angle in radians).</p> </li> <li> <code>taumax</code>               (<code>float</code>)           \u2013            <p>Maximum tau value (angle in radians).</p> </li> <li> <code>dtau</code>               (<code>float</code>)           \u2013            <p>Step size for tau.</p> </li> </ul> Source code in <code>src/prepost/source/mesh.py</code> <pre><code>def create_polar_mesh(self, xmin, xmax, dx, zmin, zmax, dz, taumin, taumax, dtau):\n    \"\"\"\n    Create a polar mesh with specified spatial and angular ranges.\n\n    Args:\n        xmin (float): Minimum x value.\n        xmax (float): Maximum x value.\n        dx (float): Step size for x.\n        zmin (float): Minimum z value.\n        zmax (float): Maximum z value.\n        dz (float): Step size for z.\n        taumin (float): Minimum tau value (angle in radians).\n        taumax (float): Maximum tau value (angle in radians).\n        dtau (float): Step size for tau.\n    \"\"\"\n    print('creating polar mesh')\n    self.xmin = xmin\n    self.xmax = xmax\n\n    self.zmin = zmin\n    self.zmax = zmax\n\n    self.taumin = taumin\n    self.taumax = taumax\n\n    self.dx = dx\n    self.dz = dz\n    self.dtau = dtau\n\n    self.x_array = np.arange(xmin, xmax, dx)\n    self.tau_array = np.arange(taumin, taumax, dtau)\n    self.z_array = np.arange(zmin, zmax, dz)\n\n    self.nx = len(self.x_array)\n    self.nz = len(self.z_array)\n    self.ntau = len(self.tau_array)\n\n    self.x_coord, self.z_coord, self.tau_coord,  = np.meshgrid(\n        self.x_array, self.z_array, self.tau_array, indexing='ij')\n\n    self.x_coord = self.x_coord.reshape(self.nx*self.ntau*self.nz, 1)\n    self.z_coord = self.z_coord.reshape(self.nx*self.ntau*self.nz, 1)\n    self.tau_coord = self.tau_coord.reshape(self.nx*self.ntau*self.nz, 1)\n\n    self.x_coord[self.x_coord == 0] = 0.00001\n    self.z_coord[self.z_coord == 0] = 0.00001\n</code></pre>"},{"location":"reference/source/mesh.html#src.prepost.source.mesh.Mesh.create_cartesian_mesh","title":"<code>create_cartesian_mesh(xmin, xmax, nx, ymin, ymax, ny, zmin, zmax, nz)</code>","text":"<p>Create a Cartesian mesh with specified ranges and dimensions.</p> <p>Parameters:</p> <ul> <li> <code>xmin</code>               (<code>float</code>)           \u2013            <p>Minimum x value.</p> </li> <li> <code>xmax</code>               (<code>float</code>)           \u2013            <p>Maximum x value.</p> </li> <li> <code>nx</code>               (<code>int</code>)           \u2013            <p>Number of points along x-axis.</p> </li> <li> <code>ymin</code>               (<code>float</code>)           \u2013            <p>Minimum y value.</p> </li> <li> <code>ymax</code>               (<code>float</code>)           \u2013            <p>Maximum y value.</p> </li> <li> <code>ny</code>               (<code>int</code>)           \u2013            <p>Number of points along y-axis.</p> </li> <li> <code>zmin</code>               (<code>float</code>)           \u2013            <p>Minimum z value.</p> </li> <li> <code>zmax</code>               (<code>float</code>)           \u2013            <p>Maximum z value.</p> </li> <li> <code>nz</code>               (<code>int</code>)           \u2013            <p>Number of points along z-axis.</p> </li> </ul> Source code in <code>src/prepost/source/mesh.py</code> <pre><code>def create_cartesian_mesh(self, xmin, xmax, nx, ymin, ymax, ny, zmin, zmax, nz):\n    \"\"\"\n    Create a Cartesian mesh with specified ranges and dimensions.\n\n    Args:\n        xmin (float): Minimum x value.\n        xmax (float): Maximum x value.\n        nx (int): Number of points along x-axis.\n        ymin (float): Minimum y value.\n        ymax (float): Maximum y value.\n        ny (int): Number of points along y-axis.\n        zmin (float): Minimum z value.\n        zmax (float): Maximum z value.\n        nz (int): Number of points along z-axis.\n    \"\"\"\n    print('creating cartesian mesh')\n    self.xmin = xmin\n    self.xmax = xmax\n    self.nx = nx\n    self.ymin = ymin\n    self.ymax = ymax\n    self.ny = ny\n    self.zmin = zmin\n    self.zmax = zmax\n    self.nz = nz\n\n    self.x_array = np.linspace(xmin, xmax, nx)\n    self.y_array = np.linspace(ymin, ymax, ny)\n    self.z_array = np.linspace(zmin, zmax, nz)\n\n    self.x_coord, self.y_coord, self.z_coord, = np.meshgrid(\n        self.x_array, self.y_array, self.z_array, indexing='ij')\n\n    self.x_coord = self.x_coord.reshape(nx*ny*nz, 1)\n    self.y_coord = self.y_coord.reshape(nx*ny*nz, 1)\n    self.z_coord = self.z_coord.reshape(nx*ny*nz, 1)\n\n    self.x_coord[self.x_coord == 0] = 0.0001\n    self.y_coord[self.y_coord == 0] = 0.0001\n    self.z_coord[self.z_coord == 0] = 0.0001\n    return\n</code></pre>"},{"location":"reference/source/mesh.html#src.prepost.source.mesh.Mesh.set_polar_mesh","title":"<code>set_polar_mesh(x, tau, z)</code>","text":"<p>Set a polar mesh using predefined coordinate arrays.</p> <p>Parameters:</p> <ul> <li> <code>x</code>               (<code>ndarray</code>)           \u2013            <p>Array of x coordinates.</p> </li> <li> <code>tau</code>               (<code>ndarray</code>)           \u2013            <p>Array of tau coordinates (angles).</p> </li> <li> <code>z</code>               (<code>ndarray</code>)           \u2013            <p>Array of z coordinates.</p> </li> </ul> Source code in <code>src/prepost/source/mesh.py</code> <pre><code>def set_polar_mesh(self, x, tau, z):\n    \"\"\"\n    Set a polar mesh using predefined coordinate arrays.\n\n    Args:\n        x (np.ndarray): Array of x coordinates.\n        tau (np.ndarray): Array of tau coordinates (angles).\n        z (np.ndarray): Array of z coordinates.\n    \"\"\"\n    self.x_array = x\n    self.tau_array = tau\n    self.z_array = z\n\n    self.xmin = x[0]\n    self.xmax = x[-1]\n    self.nx = len(x)\n    self.taumin = tau[0]\n    self.taumax = tau[-1]\n    self.ntau = len(tau)\n    self.zmin = z[0]\n    self.zmax = z[-1]\n    self.nz = len(z)\n\n    self.x_coord, self.z_coord, self.tau_coord, = np.meshgrid(\n        self.x_array, self.z_array, self.tau_array, indexing='ij')\n    self.y_coord = None\n    self.x_coord = self.x_coord.reshape(self.nx*self.ntau*self.nz, 1)\n    self.tau_coord = self.tau_coord.reshape(self.nx*self.ntau*self.nz, 1)\n    self.z_coord = self.z_coord.reshape(self.nx*self.ntau*self.nz, 1)\n\n    self.x_coord[self.x_coord == 0] = 0.0001\n    self.y_coord[self.y_coord == 0] = 0.0001\n    self.z_coord[self.z_coord == 0] = 0.0001\n</code></pre>"},{"location":"reference/source/mesh.html#src.prepost.source.mesh.Mesh.set_cartesian_mesh","title":"<code>set_cartesian_mesh(x, y, z)</code>","text":"<p>Set a Cartesian mesh using predefined coordinate arrays.</p> <p>Parameters:</p> <ul> <li> <code>x</code>               (<code>ndarray</code>)           \u2013            <p>Array of x coordinates.</p> </li> <li> <code>y</code>               (<code>ndarray</code>)           \u2013            <p>Array of y coordinates.</p> </li> <li> <code>z</code>               (<code>ndarray</code>)           \u2013            <p>Array of z coordinates.</p> </li> </ul> Source code in <code>src/prepost/source/mesh.py</code> <pre><code>def set_cartesian_mesh(self, x, y, z):\n    \"\"\"\n    Set a Cartesian mesh using predefined coordinate arrays.\n\n    Args:\n        x (np.ndarray): Array of x coordinates.\n        y (np.ndarray): Array of y coordinates.\n        z (np.ndarray): Array of z coordinates.\n    \"\"\"\n    self.x_array = x\n    self.y_array = y\n    self.z_array = z\n\n    self.xmin = x[0]\n    self.xmax = x[-1]\n    self.nx = len(x)\n    self.ymin = y[0]\n    self.ymax = y[-1]\n    self.ny = len(y)\n    self.zmin = z[0]\n    self.zmax = z[-1]\n    self.nz = len(z)\n\n    self.x_coord, self.z_coord, self.y_coord, = np.meshgrid(\n        self.x_array, self.z_array, self.y_array, indexing='ij')\n    self.tau_coord = None\n    self.x_coord = self.x_coord.reshape(self.nx*self.ny*self.nz, 1)\n    self.y_coord = self.y_coord.reshape(self.nx*self.ny*self.nz, 1)\n    self.z_coord = self.z_coord.reshape(self.nx*self.ny*self.nz, 1)\n\n    self.x_coord[self.x_coord == 0] = 0.0001\n    self.y_coord[self.y_coord == 0] = 0.0001\n    self.z_coord[self.z_coord == 0] = 0.0001\n</code></pre>"},{"location":"reference/source/mesh.html#src.prepost.source.mesh.Mesh.polar_2_curvilinear","title":"<code>polar_2_curvilinear(hpos, hlength, hheight)</code>","text":"<p>Transform polar mesh to curvilinear coordinates with a 2D hill. Usully used to create the mesh for a 2D xz plane</p> <p>Parameters:</p> <ul> <li> <code>hpos</code>               (<code>float</code>)           \u2013            <p>Position of the hilltop.</p> </li> <li> <code>hlength</code>               (<code>float</code>)           \u2013            <p>Length of the hill.</p> </li> <li> <code>hheight</code>               (<code>float</code>)           \u2013            <p>Height of the hill.</p> </li> </ul> Source code in <code>src/prepost/source/mesh.py</code> <pre><code>def polar_2_curvilinear(self, hpos, hlength, hheight):\n    \"\"\"\n    Transform polar mesh to curvilinear coordinates with a 2D hill.\n    Usully used to create the mesh for a 2D xz plane\n\n    Args:\n        hpos (float): Position of the hilltop.\n        hlength (float): Length of the hill.\n        hheight (float): Height of the hill.\n    \"\"\"\n    self.hpos = hpos\n    self.hlength = hlength\n    self.hheight = hheight\n    self.z_coord = self.z_coord.reshape(self.nx, self.nz, self.ntau)\n    for itau in range(self.ntau):\n        m1 = (self.x_array*np.cos(self.tau_array[itau]) &gt; (hpos-hlength)) * (\n            self.x_array*np.cos(self.tau_array[itau]) &lt; (hpos+hlength))\n        H = np.zeros(self.nx)\n        H[m1] = hheight * np.cos(np.pi * (self.x_array[m1]\n                                 * np.cos(self.tau_array[itau])-hpos)/(2*hlength))**2\n        self.z_coord[:, :, itau] = H.reshape(-1, 1) + self.z_coord[:, :, itau]*(\n            self.zmax - H.reshape(-1, 1))/self.zmax\n\n    self.z_coord = self.z_coord.reshape(self.nx*self.nz*self.ntau, 1)\n</code></pre>"},{"location":"reference/source/mesh.html#src.prepost.source.mesh.Mesh.add_topography","title":"<code>add_topography(hpos, hlength, hheight)</code>","text":"<p>Add topography to the mesh. All z coordinates are modified similarly in function of the 2D hill. Usually used to create the mesh for the 2D xy plane, where receiver are at 2m height.</p> <p>Parameters:</p> <ul> <li> <code>hpos</code>               (<code>float</code>)           \u2013            <p>Position of the topography peak.</p> </li> <li> <code>hlength</code>               (<code>float</code>)           \u2013            <p>Length of the topography.</p> </li> <li> <code>hheight</code>               (<code>float</code>)           \u2013            <p>Height of the topography.</p> </li> </ul> Source code in <code>src/prepost/source/mesh.py</code> <pre><code>def add_topography(self, hpos, hlength, hheight):\n    \"\"\"\n    Add topography to the mesh. All z coordinates are modified similarly in function of the 2D hill.\n    Usually used to create the mesh for the 2D xy plane, where receiver are at 2m height.\n\n    Args:\n        hpos (float): Position of the topography peak.\n        hlength (float): Length of the topography.\n        hheight (float): Height of the topography.\n    \"\"\"\n    self.z_coord = self.z_coord.reshape(self.nx, self.nz, self.ntau)\n    for itau in range(self.ntau):\n        m1 = ((self.x_array*np.cos(self.tau_array[itau]) &gt; (hpos-hlength))\n              * (self.x_array*np.cos(self.tau_array[itau]) &lt; (hpos+hlength)))\n        H = np.zeros(self.nx)\n        H[m1] = hheight * np.cos(np.pi * (self.x_array[m1]\n                                          * np.cos(self.tau_array[itau])-hpos)/(2*hlength))**2\n        self.z_coord[:, :, itau] = (H.reshape(-1, 1)\n                                    + self.z_coord[:, :, itau])\n\n    self.z_coord = self.z_coord.reshape(self.nx*self.nz*self.ntau, 1)\n</code></pre>"},{"location":"reference/source/mesh.html#src.prepost.source.mesh.Mesh.cartesian_2_polar","title":"<code>cartesian_2_polar()</code>","text":"<p>Convert the Cartesian mesh to polar coordinates.</p> Source code in <code>src/prepost/source/mesh.py</code> <pre><code>def cartesian_2_polar(self):\n    \"\"\"\n    Convert the Cartesian mesh to polar coordinates.\n    \"\"\"\n    self.tau_coord = (np.arctan2(self.y_coord, self.x_coord))\n    self.x_coord = np.sqrt(self.x_coord ** 2 + self.y_coord ** 2)\n    self.y_coord = None\n</code></pre>"},{"location":"reference/source/mesh.html#src.prepost.source.mesh.Mesh.polar_2_cartesian","title":"<code>polar_2_cartesian()</code>","text":"<p>Convert the polar mesh to Cartesian coordinates.</p> Source code in <code>src/prepost/source/mesh.py</code> <pre><code>def polar_2_cartesian(self):\n    \"\"\"\n    Convert the polar mesh to Cartesian coordinates.\n    \"\"\"\n    self.y_coord = np.sin(self.tau_coord)*self.x_coord\n    self.x_coord = np.cos(self.tau_coord)*self.x_coord\n    self.tau_coord = None\n</code></pre>"},{"location":"reference/source/mesh.html#src.prepost.source.mesh.Mesh.shift","title":"<code>shift(x, y)</code>","text":"<p>Shift the mesh in Cartesian coordinates. This is usefull to create first a general cartesian mesh. Then shift it to put the wind turbine at position (0,0). Compute the Spp using Source class. And then shift it again.</p> <p>Parameters:</p> <ul> <li> <code>x</code>               (<code>float</code>)           \u2013            <p>Shift along x-axis.</p> </li> <li> <code>y</code>               (<code>float</code>)           \u2013            <p>Shift along y-axis.</p> </li> </ul> Source code in <code>src/prepost/source/mesh.py</code> <pre><code>def shift(self, x, y):\n    \"\"\"\n    Shift the mesh in Cartesian coordinates.\n    This is usefull to create first a general cartesian mesh.\n    Then shift it to put the wind turbine at position (0,0).\n    Compute the Spp using Source class.\n    And then shift it again.\n\n    Args:\n        x (float): Shift along x-axis.\n        y (float): Shift along y-axis.\n    \"\"\"\n    if self.tau_coord is not None:\n        print('warning not in cartesian coordinate')\n        return\n\n    self.x_array = self.x_array + x\n    self.y_array = self.y_array + y\n    self.z_array = self.z_array\n\n    self.xmin = self.x_array[0]\n    self.xmax = self.x_array[-1]\n    self.nx = len(self.x_array)\n    self.ymin = self.y_array[0]\n    self.ymax = self.y_array[-1]\n    self.ny = len(self.y_array)\n\n    self.x_coord, self.z_coord, self.y_coord, = np.meshgrid(\n        self.x_array, self.z_array, self.y_array, indexing='ij')\n\n    self.x_coord = self.x_coord.reshape(self.nx*self.ny*self.nz, 1)\n    self.y_coord = self.y_coord.reshape(self.nx*self.ny*self.nz, 1)\n    self.z_coord = self.z_coord.reshape(self.nx*self.ny*self.nz, 1)\n\n    self.x_coord[self.x_coord == 0] = 0.0001\n    self.y_coord[self.y_coord == 0] = 0.0001\n    self.z_coord[self.z_coord == 0] = 0.0001\n</code></pre>"},{"location":"reference/source/mio.html","title":"Reference for <code>prepost/source/mio.py</code>","text":""},{"location":"reference/source/mio.html#src.prepost.source.mio.delta_L_ip","title":"<code>delta_L_ip(path, file_name, freq, nx, nz)</code>","text":"Source code in <code>src/prepost/source/mio.py</code> <pre><code>def delta_L_ip(path, file_name, freq, nx, nz):\n    os.chdir(path)\n    delta_L_freq = np.zeros((nx, nz, freq.shape[0]))\n    print(delta_L_freq.shape)\n    for temp in range(freq.shape[0]):\n        delta_L_freq[:, :, temp] = np.transpose(np.array(h5py.File(file_name, 'r+')['solution'][\"%04d\" % freq[temp]]['deltaL']))\n\n    mesh = {}\n    mesh['x_coord'] = np.transpose(np.array(h5py.File(file_name, 'r+')['mesh']['x']))\n    mesh['z_coord'] = np.transpose(np.array(h5py.File(file_name, 'r+')['mesh']['y']))\n\n    return delta_L_freq, mesh\n</code></pre>"},{"location":"reference/source/mio.html#src.prepost.source.mio.delta_L_ip_2dpe","title":"<code>delta_L_ip_2dpe(path, file_name, freq, MX, MZ)</code>","text":"Source code in <code>src/prepost/source/mio.py</code> <pre><code>def delta_L_ip_2dpe(path, file_name, freq, MX, MZ):\n    os.chdir(path)\n    delta_L_freq = np.zeros((MZ, MX, freq.shape[1]))\n    for temp in range(freq.shape[1]):\n        delta_L_freq[:, :, temp] = np.array(h5py.File(file_name, 'r+')[\"freq_%04d\" % freq[0, temp]]).T\n    return delta_L_freq\n</code></pre>"},{"location":"reference/source/parallel.html","title":"Reference for <code>prepost/source/parallel.py</code>","text":""},{"location":"reference/source/parallel.html#src.prepost.source.parallel.domain_facture","title":"<code>domain_facture(mesh, Ncore)</code>","text":"<p>Divide the computational mesh into subdomains for multiprocessing.</p> <p>Parameters:</p> <ul> <li> <code>mesh</code>               (<code>Mesh</code>)           \u2013            <p>The computational mesh containing coordinate arrays.</p> </li> <li> <code>Ncore</code>               (<code>int</code>)           \u2013            <p>The number of cores to divide the domain.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list</code> (              <code>list</code> )          \u2013            <p>A list of dictionaries, each containing a subdomain with    'x_coord', 'z_coord', and 'tau_coord' arrays.</p> </li> </ul> Source code in <code>src/prepost/source/parallel.py</code> <pre><code>def domain_facture(mesh, Ncore: int) -&gt; list:\n    \"\"\"\n    Divide the computational mesh into subdomains for multiprocessing.\n\n    Args:\n        mesh (Mesh): The computational mesh containing coordinate arrays.\n        Ncore (int): The number of cores to divide the domain.\n\n    Returns:\n        list: A list of dictionaries, each containing a subdomain with \n              'x_coord', 'z_coord', and 'tau_coord' arrays.\n    \"\"\"\n    domain_length = mesh.x_coord.shape[0] * mesh.x_coord.shape[1]\n    delta = domain_length // Ncore\n    final_coord = []\n    for temp in range(Ncore - 1):\n        temp_dict = {}\n        temp_dict['x_coord'] = mesh.x_coord[temp * delta : (temp + 1) * delta]\n        temp_dict['z_coord'] = mesh.z_coord[temp * delta : (temp + 1) * delta]\n        temp_dict['tau_coord'] = mesh.tau_coord[temp * delta : (temp + 1) * delta]\n        final_coord.append(temp_dict)\n\n    temp_dict = {}\n    temp_dict['x_coord'] = mesh.x_coord[(Ncore-1) * delta : ]\n    temp_dict['z_coord'] = mesh.z_coord[(Ncore-1) * delta : ]\n    temp_dict['tau_coord'] = mesh.tau_coord[(Ncore-1) * delta : ]\n    final_coord.append(temp_dict)\n\n    return final_coord\n</code></pre>"},{"location":"reference/source/parallel.html#src.prepost.source.parallel.output_construct","title":"<code>output_construct(output, mesh, Ncore, Nfreq, Nblade, Nseg)</code>","text":"<p>Reconstruct output data from multiple processing subdomains into a unified dataset.</p> <p>Parameters:</p> <ul> <li> <code>output</code>               (<code>list</code>)           \u2013            <p>List of dictionaries containing computed data for each subdomain.</p> </li> <li> <code>mesh</code>               (<code>Mesh</code>)           \u2013            <p>The computational mesh used in the calculations.</p> </li> <li> <code>Ncore</code>               (<code>int</code>)           \u2013            <p>Number of processing cores used.</p> </li> <li> <code>Nfreq</code>               (<code>int</code>)           \u2013            <p>Number of frequency bands.</p> </li> <li> <code>Nblade</code>               (<code>int</code>)           \u2013            <p>Number of wind turbine blades.</p> </li> <li> <code>Nseg</code>               (<code>int</code>)           \u2013            <p>Number of blade segments.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>tuple</code>          \u2013            <p>A tuple containing reconstructed arrays: - SPL_tot (np.array): Total Sound Pressure Level. - SPL_TIN (np.array): Tonal noise SPL. - SPL_TEN (np.array): Broadband noise SPL. - SWL_tot (np.array): Sound power levels. - AoA (np.array): Angle of Attack values. - U_inf (np.array): Freestream wind velocity. - epsilon (np.array): Turbulence dissipation rate. - U_rot (np.array): Rotational wind velocity. - U_rel (np.array): Relative wind velocity. - a (np.array): Axial induction factor. - adash (np.array): Tangential induction factor.</p> </li> </ul> Source code in <code>src/prepost/source/parallel.py</code> <pre><code>def output_construct(output: list, mesh, Ncore: int, Nfreq: int, Nblade: int, Nseg: int):\n    \"\"\"\n    Reconstruct output data from multiple processing subdomains into a unified dataset.\n\n    Args:\n        output (list): List of dictionaries containing computed data for each subdomain.\n        mesh (Mesh): The computational mesh used in the calculations.\n        Ncore (int): Number of processing cores used.\n        Nfreq (int): Number of frequency bands.\n        Nblade (int): Number of wind turbine blades.\n        Nseg (int): Number of blade segments.\n\n    Returns:\n        tuple: A tuple containing reconstructed arrays:\n            - SPL_tot (np.array): Total Sound Pressure Level.\n            - SPL_TIN (np.array): Tonal noise SPL.\n            - SPL_TEN (np.array): Broadband noise SPL.\n            - SWL_tot (np.array): Sound power levels.\n            - AoA (np.array): Angle of Attack values.\n            - U_inf (np.array): Freestream wind velocity.\n            - epsilon (np.array): Turbulence dissipation rate.\n            - U_rot (np.array): Rotational wind velocity.\n            - U_rel (np.array): Relative wind velocity.\n            - a (np.array): Axial induction factor.\n            - adash (np.array): Tangential induction factor.\n    \"\"\"\n    x1 = mesh.x_coord.shape[0]\n    x2 = mesh.x_coord.shape[1]\n    print(x1,x2)\n    delta = x1 * x2 // Ncore\n    SPL_tot = np.zeros((x1 * x2, Nseg, Nblade, Nfreq))\n    SPL_TIN = np.zeros((x1 * x2, Nseg, Nblade, Nfreq))\n    SPL_TEN = np.zeros((x1 * x2, Nseg, Nblade, Nfreq))\n    SWL_tot = np.zeros((x1 * x2, Nseg, Nblade, Nfreq))\n    for temp in range(Ncore - 1):\n        SPL_tot[temp * delta : (temp + 1) * delta, :, :, :] = output[temp]['SPL_tot']\n        SPL_TIN[temp * delta : (temp + 1) * delta, :, :, :] = output[temp]['SPL_TIN']\n        SPL_TEN[temp * delta : (temp + 1) * delta, :, :, :] = output[temp]['SPL_TEN']\n        SWL_tot[temp * delta : (temp + 1) * delta, :, :, :] = output[temp]['SWL_tot']\n\n\n    SPL_tot[(temp + 1) * delta : , :, :, :] = output[temp + 1]['SPL_tot']\n    SPL_TIN[(temp + 1) * delta : , :, :, :] = output[temp + 1]['SPL_TIN']\n    SPL_TEN[(temp + 1) * delta : , :, :, :] = output[temp + 1]['SPL_TEN']\n    SWL_tot[(temp + 1) * delta : , :, :, :] = output[temp + 1]['SWL_tot']\n    SPL_tot = SPL_tot.reshape(x1 * x2, Nseg*Nblade, Nfreq)\n    SPL_TIN = SPL_TIN.reshape(x1 * x2, Nseg*Nblade, Nfreq)\n    SPL_TEN = SPL_TEN.reshape(x1 * x2, Nseg*Nblade, Nfreq)\n    SWL_tot = SWL_tot.reshape(x1 * x2, Nseg*Nblade, Nfreq)\n    AoA = output[0]['AoA'].reshape(Nseg*Nblade)\n    U_inf = output[0]['U_inf'].reshape(Nseg*Nblade)\n\n    epsilon = output[0]['epsilon'].reshape(Nseg*Nblade)\n    U_rot = output[0]['U_rot'].reshape(Nseg*Nblade)\n    U_rel = output[0]['U_rel'].reshape(Nseg*Nblade)\n    a = output[0]['a'].reshape(Nseg*Nblade)\n    adash = output[0]['adash'].reshape(Nseg*Nblade)\n\n    return SPL_tot, SPL_TIN,SPL_TEN,SWL_tot,AoA,U_inf, epsilon, U_rot,U_rel,a,adash\n</code></pre>"},{"location":"reference/source/parallel.html#src.prepost.source.parallel.reshuffle_output","title":"<code>reshuffle_output(output_total, Ncore)</code>","text":"<p>Reorder the output from parallel processing based on reconstruction indices.</p> <p>Parameters:</p> <ul> <li> <code>output_total</code>               (<code>list</code>)           \u2013            <p>List of dictionaries containing output data from processing.</p> </li> <li> <code>Ncore</code>               (<code>int</code>)           \u2013            <p>Number of processing cores.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list</code> (              <code>list</code> )          \u2013            <p>The reordered list of output data sorted by their reconstruction indices.</p> </li> </ul> Source code in <code>src/prepost/source/parallel.py</code> <pre><code>def reshuffle_output(output_total: list, Ncore: int) -&gt; list:\n    \"\"\"\n    Reorder the output from parallel processing based on reconstruction indices.\n\n    Args:\n        output_total (list): List of dictionaries containing output data from processing.\n        Ncore (int): Number of processing cores.\n\n    Returns:\n        list: The reordered list of output data sorted by their reconstruction indices.\n    \"\"\"\n    order = []\n    for temp in range(Ncore):\n        order.append(output_total[temp]['recon_index'])\n    order_index = np.argsort(order)\n    final_output = []\n    for temp in range(Ncore):\n        final_output.append(output_total[order_index[temp]])\n    return final_output\n</code></pre>"},{"location":"reference/source/utils.html","title":"Reference for <code>prepost/source/utils.py</code>","text":""},{"location":"reference/source/utils.html#src.prepost.source.utils.interp_atmos_data","title":"<code>interp_atmos_data(z, u, znew)</code>","text":"<p>Interpolate 1D atmospheric data using cubic splines.</p> <p>Parameters:</p> <ul> <li> <code>z</code>               (<code>ndarray</code>)           \u2013            <p>Original altitude values.</p> </li> <li> <code>u</code>               (<code>ndarray</code>)           \u2013            <p>Original wind speed values.</p> </li> <li> <code>znew</code>               (<code>ndarray</code>)           \u2013            <p>New altitude values for interpolation.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ndarray</code>           \u2013            <p>np.ndarray: Interpolated wind speed values at new altitudes.</p> </li> </ul> Source code in <code>src/prepost/source/utils.py</code> <pre><code>def interp_atmos_data(z: np.ndarray, u: np.ndarray, znew: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    Interpolate 1D atmospheric data using cubic splines.\n\n    Args:\n        z (np.ndarray): Original altitude values.\n        u (np.ndarray): Original wind speed values.\n        znew (np.ndarray): New altitude values for interpolation.\n\n    Returns:\n        np.ndarray: Interpolated wind speed values at new altitudes.\n    \"\"\"\n    cs = CubicSpline(z, u)\n    return cs(znew)\n</code></pre>"},{"location":"reference/source/utils.html#src.prepost.source.utils.interp_3D_atmos_data","title":"<code>interp_3D_atmos_data(atmos, xnew, ynew, znew)</code>","text":"<p>Interpolate 3D atmospheric data for given spatial coordinates.</p> <p>Parameters:</p> <ul> <li> <code>atmos</code>               (<code>Atmosphere</code>)           \u2013            <p>Atmosphere object containing wind speed and turbulence data.</p> </li> <li> <code>xnew</code>               (<code>ndarray</code>)           \u2013            <p>New x-coordinates.</p> </li> <li> <code>ynew</code>               (<code>ndarray</code>)           \u2013            <p>New y-coordinates.</p> </li> <li> <code>znew</code>               (<code>ndarray</code>)           \u2013            <p>New z-coordinates.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>tuple</code> (              <code>tuple</code> )          \u2013            <p>Interpolated wind speed and turbulence dissipation values.</p> </li> </ul> Source code in <code>src/prepost/source/utils.py</code> <pre><code>def interp_3D_atmos_data(atmos, xnew: np.ndarray, ynew: np.ndarray, znew: np.ndarray) -&gt; tuple:\n    \"\"\"\n    Interpolate 3D atmospheric data for given spatial coordinates.\n\n    Args:\n        atmos (Atmosphere): Atmosphere object containing wind speed and turbulence data.\n        xnew (np.ndarray): New x-coordinates.\n        ynew (np.ndarray): New y-coordinates.\n        znew (np.ndarray): New z-coordinates.\n\n    Returns:\n        tuple: Interpolated wind speed and turbulence dissipation values.\n    \"\"\"\n    # check:\n    if xnew.shape != ynew.shape or xnew.shape != znew.shape:\n        raise Exception(\"new points must have same shape\")\n    points = np.concatenate(\n        (znew.reshape(-1, 1), ynew.reshape(-1, 1), xnew.reshape(-1, 1)), axis=1)\n\n    interpoland = RegularGridInterpolator(\n        (atmos.z, atmos.y, atmos.x), atmos.u, method='linear',bounds_error=False)\n    u_new = interpoland(points)\n    u_new = u_new.reshape(xnew.shape)\n    interpoland = RegularGridInterpolator(\n        (atmos.z, atmos.y, atmos.x), atmos.epsilon, method='linear',bounds_error=False)\n    epsilon_new = interpoland(points)\n    epsilon_new = epsilon_new.reshape(xnew.shape)\n    return u_new, epsilon_new\n</code></pre>"},{"location":"reference/source/utils.html#src.prepost.source.utils.cotte_conv","title":"<code>cotte_conv(coord)</code>","text":"<p>Convert (x, y, z) coordinate system to (x, z, tau) system.</p> <p>Parameters:</p> <ul> <li> <code>coord</code>               (<code>dict</code>)           \u2013            <p>Dictionary containing 'x_coord', 'y_coord', and 'z_coord'.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict</code> (              <code>dict</code> )          \u2013            <p>Converted coordinates with 'x_rec', 'z_rec', and 'tau'.</p> </li> </ul> Source code in <code>src/prepost/source/utils.py</code> <pre><code>def cotte_conv(coord: dict) -&gt; dict:\n    \"\"\"\n    Convert (x, y, z) coordinate system to (x, z, tau) system.\n\n    Args:\n        coord (dict): Dictionary containing 'x_coord', 'y_coord', and 'z_coord'.\n\n    Returns:\n        dict: Converted coordinates with 'x_rec', 'z_rec', and 'tau'.\n    \"\"\"\n    receivers = {}\n    receivers['x_rec'] = np.sqrt(coord['x_coord'] ** 2 + coord['y_coord'] ** 2).reshape(\n        coord['x_coord'].shape[0] * coord['x_coord'].shape[1], 1)\n    receivers['z_rec'] = (coord['z_coord']).reshape(\n        coord['x_coord'].shape[0] * coord['x_coord'].shape[1], 1)\n    receivers['tau'] = (np.arctan2(coord['y_coord'], coord['x_coord'])).reshape(\n        coord['x_coord'].shape[0] * coord['x_coord'].shape[1], 1)\n    return receivers\n</code></pre>"},{"location":"reference/source/utils.html#src.prepost.source.utils.computeThirdOctaveFrequencies","title":"<code>computeThirdOctaveFrequencies(fc, Nfc)</code>","text":"<p>Compute third-octave band center frequencies.</p> <p>Parameters:</p> <ul> <li> <code>fc</code>               (<code>list</code>)           \u2013            <p>List of center frequencies.</p> </li> <li> <code>Nfc</code>               (<code>list</code>)           \u2013            <p>List of frequency counts for each band.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ndarray</code>           \u2013            <p>np.ndarray: Computed third-octave frequencies.</p> </li> </ul> Source code in <code>src/prepost/source/utils.py</code> <pre><code>def computeThirdOctaveFrequencies(fc: list, Nfc: list) -&gt; np.ndarray:\n    \"\"\"\n    Compute third-octave band center frequencies.\n\n    Args:\n        fc (list): List of center frequencies.\n        Nfc (list): List of frequency counts for each band.\n\n    Returns:\n        np.ndarray: Computed third-octave frequencies.\n    \"\"\"\n    if len(fc) != len(Nfc):\n        print('Fc and Nfc must be of same length')\n        return\n    Nfreq = sum(Nfc)\n    print(Nfreq)\n    freq = np.array([])\n    for ii in range(len(fc)):\n        freq = np.concatenate(\n            (freq, np.round(fc[ii]*2**((2*np.arange(1, Nfc[ii]+1)/(Nfc[ii]+1) - 1)/6))))\n    print(len(freq))\n    return (freq)\n</code></pre>"},{"location":"reference/source/utils.html#src.prepost.source.utils.Aweight","title":"<code>Aweight(f)</code>","text":"<p>Compute A-weighting for given frequencies.</p> <p>Parameters:</p> <ul> <li> <code>f</code>               (<code>ndarray</code>)           \u2013            <p>Array of frequencies in Hz.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ndarray</code>           \u2013            <p>np.ndarray: A-weighted values in decibels.</p> </li> </ul> Source code in <code>src/prepost/source/utils.py</code> <pre><code>def Aweight(f: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    Compute A-weighting for given frequencies.\n\n    Args:\n        f (np.ndarray): Array of frequencies in Hz.\n\n    Returns:\n        np.ndarray: A-weighted values in decibels.\n    \"\"\"\n    Af = 12200**2*f**4./(f**2+20.6**2)/(f**2+12200**2) / \\\n        (f**2+107.7**2)**0.5/(f**2+737.9**2)**0.5\n    dBA = 20*np.log10(Af/0.7943)\n    return dBA\n</code></pre>"},{"location":"reference/source/utils.html#src.prepost.source.utils.c_round","title":"<code>c_round(temp)</code>","text":"<p>Round a number to two decimal places.</p> <p>Parameters:</p> <ul> <li> <code>temp</code>               (<code>float</code>)           \u2013            <p>Number to be rounded.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>float</code> (              <code>float</code> )          \u2013            <p>Rounded value to two decimal places.</p> </li> </ul> Source code in <code>src/prepost/source/utils.py</code> <pre><code>def c_round(temp: float) -&gt; float:\n    \"\"\"\n    Round a number to two decimal places.\n\n    Args:\n        temp (float): Number to be rounded.\n\n    Returns:\n        float: Rounded value to two decimal places.\n    \"\"\"\n    return round(temp * 100) / 100\n</code></pre>"},{"location":"reference/source/utils.html#src.prepost.source.utils.find_index","title":"<code>find_index(aoa, AOA)</code>","text":"<p>Find the index of the given angle of attack (aoa) in the array AOA.</p> <p>Parameters:</p> <ul> <li> <code>aoa</code>               (<code>float</code>)           \u2013            <p>Angle of attack to search for.</p> </li> <li> <code>AOA</code>               (<code>ndarray</code>)           \u2013            <p>Array of available angles.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>int</code> (              <code>int</code> )          \u2013            <p>Index of the found angle in the AOA array.</p> </li> </ul> Source code in <code>src/prepost/source/utils.py</code> <pre><code>def find_index(aoa: float, AOA: np.ndarray) -&gt; int:\n    \"\"\"\n    Find the index of the given angle of attack (aoa) in the array AOA.\n\n    Args:\n        aoa (float): Angle of attack to search for.\n        AOA (np.ndarray): Array of available angles.\n\n    Returns:\n        int: Index of the found angle in the AOA array.\n    \"\"\"\n    for temp in range(len(AOA)):\n        if aoa &lt;= AOA[temp]:\n            break\n    return temp\n</code></pre>"},{"location":"reference/source/utils.html#src.prepost.source.utils.R1_func","title":"<code>R1_func(coord, H_ref)</code>","text":"<p>Calculate the distance between each blade segment and the receiver locations.</p> <p>Parameters:</p> <ul> <li> <code>coord</code>               (<code>dict</code>)           \u2013            <p>Dictionary containing 'x_coord' and 'z_coord'.</p> </li> <li> <code>H_ref</code>               (<code>float</code>)           \u2013            <p>Reference height for the source.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ndarray</code>           \u2013            <p>np.ndarray: Array of computed distances.</p> </li> </ul> Source code in <code>src/prepost/source/utils.py</code> <pre><code>def R1_func(coord: dict, H_ref: float) -&gt; np.ndarray:\n    \"\"\"\n    Calculate the distance between each blade segment and the receiver locations.\n\n    Args:\n        coord (dict): Dictionary containing 'x_coord' and 'z_coord'.\n        H_ref (float): Reference height for the source.\n\n    Returns:\n        np.ndarray: Array of computed distances.\n    \"\"\"\n    R1_array = np.sqrt((0 - coord['x_coord']) **\n                       2 + (H_ref - coord['z_coord']) ** 2)\n    return R1_array\n</code></pre>"},{"location":"reference/source/wind_turbine.html","title":"Reference for <code>prepost/source/wind_turbine.py</code>","text":""},{"location":"reference/source/wind_turbine.html#src.prepost.source.wind_turbine.WindTurbine","title":"<code>WindTurbine()</code>","text":"<p>A class to create a wind turbine, with geometry and boundary layer quantities</p> Source code in <code>src/prepost/source/wind_turbine.py</code> <pre><code>def __init__(self):\n    return\n</code></pre>"},{"location":"reference/source/wind_turbine.html#src.prepost.source.wind_turbine.WindTurbine.setOptimalTwist","title":"<code>setOptimalTwist(U_ref, AoA_opt)</code>","text":"<p>Create optimal twist for a given angle of attack (used to create Cotte wind turbines)</p> <p>Parameters:</p> <ul> <li> <code>U_ref</code>               (<code>ndarray</code>)           \u2013            <p>wind profile</p> </li> <li> <code>AoA_opt</code>               (<code>float</code>)           \u2013            <p>optimal angle of attack wanted</p> </li> </ul> Source code in <code>src/prepost/source/wind_turbine.py</code> <pre><code>def setOptimalTwist(self, U_ref:np.array, AoA_opt: float):\n    \"\"\"Create optimal twist for a given angle of attack (used to create Cotte wind turbines)\n\n    Args:\n        U_ref (np.ndarray): wind profile\n        AoA_opt (float): optimal angle of attack wanted \n    \"\"\"\n    # twist and AoA of the wind turbine blades\n    U_rot = self.seg*self.omega\n    self.twist = np.arctan(U_rot / U_ref) + AoA_opt * np.pi / 180\n</code></pre>"},{"location":"reference/source/wind_turbine.html#src.prepost.source.wind_turbine.WindTurbine.default","title":"<code>default()</code>","text":"<p>Create default wind turbine same as Cotte but scaled up for D = 100m</p> Source code in <code>src/prepost/source/wind_turbine.py</code> <pre><code>def default(self):\n    \"\"\"Create default wind turbine\n    same as Cotte but scaled up for D = 100m\n    \"\"\"\n    self.tau = 0\n    self.absolute_pos = (0., 0.)\n    self.href = 100\n    self.Nseg = 8\n    self.Nblade = 3\n    self.Nbeta = 12\n    self.omega =  12.1 * 2 * np.pi / 60\n    self.delta_beta = 0\n    self.seg = 1.07*np.asarray([6.0454, 14.8958, 22.7309, 29.1557, 34.4240, 38.7440, 42.2865, 45.1913])  #Spnwise location of segment center point\n    self.Lspan = 1.07* np.asarray([9.0908, 8.6100, 7.0602, 5.7894, 4.7473, 3.8928, 3.1921, 2.6175])       #Spanwise lengths of blade segments\n    self.chord = np.asarray([3.2273, 2.6963, 2.2261, 1.8407, 1.5246, 1.2654, 1.0528, 0.8785])\n    self.setOptimalTwist(8, 4)\n    self.airfoilIndex = np.asarray([0,0,0,0,0,0,0,0])\n    path2data =  path.join(path.dirname(__file__), 'BL_data/NACA63415')\n    self.airfoilDataPath = np.asarray([path2data])\n    self.airfoil_data = {}\n    self.airfoil_data = pickle.load(open(path2data,'rb'))\n</code></pre>"},{"location":"reference/source/wind_turbine.html#src.prepost.source.wind_turbine.WindTurbine.computeBeta","title":"<code>computeBeta()</code>","text":"<p>compute beta angle according to number of blade and number of discretization per 1/Nblade turn  the beta array is of shape (Nblade, Nbeta). The total number of angular position is Nblade*Nbeta and cover a complete 360 rotation.</p> Source code in <code>src/prepost/source/wind_turbine.py</code> <pre><code>def computeBeta(self):\n    \"\"\"compute beta angle according to number of blade and number of discretization per 1/Nblade turn \n    the beta array is of shape (Nblade, Nbeta). The total number of angular position is Nblade*Nbeta and cover a complete 360 rotation.\n    \"\"\"\n    dbeta = 2 * np.pi / self.Nblade\n    self.beta = (np.linspace(0, 2 * np.pi - dbeta, self.Nblade).reshape(self.Nblade, 1) + np.linspace(0,2*np.pi*(self.Nbeta-1)/self.Nblade/self.Nbeta,self.Nbeta).reshape(1,self.Nbeta)) #+ np.pi/3\n</code></pre>"},{"location":"reference/source/wind_turbine.html#src.prepost.source.wind_turbine.WindTurbine.proximity","title":"<code>proximity(height_array)</code>","text":"<p>Compute the proximity matrix to combine delta L and Spp. </p> <p>Parameters:</p> <ul> <li> <code>height_array</code>               (<code>ndarray</code>)           \u2013            <p>the source heights array corresponding to the Delta L computations </p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ndarray</code>           \u2013            <p>np.ndarray: array of shape (Nseg*Nblade,Nbeta) of the index corsponding to the closest Delta L source</p> </li> </ul> Source code in <code>src/prepost/source/wind_turbine.py</code> <pre><code>def proximity(self,height_array: np.ndarray)-&gt;np.ndarray:\n    \"\"\"Compute the proximity matrix to combine delta L and Spp. \n\n    Args:\n        height_array (np.ndarray): the source heights array corresponding to the Delta L computations \n\n    Returns:\n        np.ndarray: array of shape (Nseg*Nblade,Nbeta) of the index corsponding to the closest Delta L source \n    \"\"\"\n\n    proximity = np.zeros((self.Nseg*self.Nblade, self.Nbeta))\n    self.computeBeta()\n    # print(self.beta.shape)\n    for ibeta in range(self.Nbeta):\n        h_temp = (np.cos(self.beta[:,ibeta]).reshape(1,self.Nblade) * self.seg.reshape(self.Nseg,1) + self.href).reshape(self.Nblade * self.Nseg)\n        # print(h_temp.shape)\n        # print( np.abs(h_temp - height_array).argmin(axis = 0))\n        proximity[:, ibeta] = np.abs(h_temp.reshape(1,-1) - height_array.reshape(-1,1)).argmin(axis = 0)\n    return proximity.astype(int)\n</code></pre>"},{"location":"reference/source/wind_turbine.html#src.prepost.source.wind_turbine.WindTurbine.proximityLinear","title":"<code>proximityLinear(height_array)</code>","text":"<p>compute th proximity matrix to combine delta L and Spp, with linear interpolation between the Delta L</p> <p>Parameters:</p> <ul> <li> <code>height_array</code>               (<code>ndarray</code>)           \u2013            <p>the source heights array corresponding to the Delta L computations </p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ndarray</code>           \u2013            <p>np.ndarray: array of shape (Nseg*Nblade,Nbeta,3) of the two index corresponding to the closest DeltaL computations, and the ratio between them.</p> </li> </ul> Source code in <code>src/prepost/source/wind_turbine.py</code> <pre><code>def proximityLinear(self, height_array: np.ndarray)-&gt;np.ndarray:\n    \"\"\"compute th proximity matrix to combine delta L and Spp, with linear interpolation between the Delta L\n\n    Args:\n        height_array (np.ndarray): the source heights array corresponding to the Delta L computations \n\n    Returns:\n        np.ndarray: array of shape (Nseg*Nblade,Nbeta,3) of the two index corresponding to the closest DeltaL computations, and the ratio between them. \n    \"\"\"\n    # height_array is the heigth of the delta L computations \n    # third dimension to store the  2 delta L index for each source and the ratio between the two delta L \n    proximity = np.zeros((self.Nseg*self.Nblade, self.Nbeta,3),dtype=object)\n    # compute beta matrix \n    self.computeBeta()\n    # loop on the blades position\n    for ibeta in range(self.Nbeta):\n        # calculate heigth of each segment at each blade position \n        h_temp = (np.cos(self.beta[:,ibeta]).reshape(1,self.Nblade) * self.seg.reshape(self.Nseg,1) + self.href).reshape(self.Nblade * self.Nseg)\n        for iseg in range (self.Nseg*self.Nblade) : \n            prox0 = np.abs(h_temp[iseg] - height_array).argmin()\n            if h_temp[iseg]&lt;height_array[prox0] and prox0&gt;0:\n                prox1 = prox0-1 \n                prox2 = prox0   \n                ratio = (height_array[prox2] - h_temp[iseg])/(height_array[prox2]-height_array[prox1])\n            elif h_temp[iseg]&gt;height_array[prox0] and prox0&lt;len(height_array)-1:\n                prox1 = prox0\n                prox2 = prox0+1\n                ratio = (height_array[prox2] - h_temp[iseg])/(height_array[prox2]-height_array[prox1])\n            else : \n                prox1 = prox0\n                prox2 = prox0\n                ratio = 1\n            proximity[iseg,ibeta,0] = int(prox1)\n            proximity[iseg,ibeta,1] = int(prox2)\n            proximity[iseg,ibeta,2] = float(ratio) \n    return proximity\n</code></pre>"},{"location":"reference/source/wind_turbine.html#src.prepost.source.wind_turbine.WindTurbine.plotProximity","title":"<code>plotProximity(height_array, ax1=None, ibeta=None)</code>","text":"<p>plot the corespondance between segement and Delta L (using colors)</p> <p>Parameters:</p> <ul> <li> <code>height_array</code>               (<code>ndarray</code>)           \u2013            <p>the source heights array corresponding to the Delta L computations </p> </li> <li> <code>ax1</code>               (<code>_type_</code>, default:                   <code>None</code> )           \u2013            <p>ax object on which to plot. Defaults to None.</p> </li> <li> <code>ibeta</code>               (<code>int</code>, default:                   <code>None</code> )           \u2013            <p>index of the angular position to plot, if None cycle through all beta. Defaults to None.</p> </li> </ul> Source code in <code>src/prepost/source/wind_turbine.py</code> <pre><code>def plotProximity(self,height_array:np.ndarray,ax1=None,ibeta :int=None):\n    \"\"\"plot the corespondance between segement and Delta L (using colors)\n\n    Args:\n        height_array (np.ndarray): the source heights array corresponding to the Delta L computations \n        ax1 (_type_, optional): ax object on which to plot. Defaults to None.\n        ibeta (int, optional): index of the angular position to plot, if None cycle through all beta. Defaults to None.\n    \"\"\"\n    proximity = self.proximity(height_array)\n    Ncolor = np.max(proximity)+1\n    icol = np.linspace(0,1,Ncolor)\n    cmap = cm.get_cmap('coolwarm')\n    color = []\n\n    for ii in icol:\n        color.append(cmap(ii))\n\n    beta = self.beta.reshape(self.Nblade,self.Nbeta)\n    if ibeta is not None:\n        # fig, ax = plt.subplots()\n        for i, height in  enumerate(height_array):\n            if ax1 is None : \n                plt.plot([-100,100], [height,height],'--', color= color[i])\n            else : \n                ax1.plot([-100,100], [height,height],'--', color= color[i])\n\n        proximity_temp = proximity[:,ibeta].reshape(self.Nseg, self.Nblade)\n        for iblade in range(self.Nblade):\n            for iseg in range(self.Nseg) :\n                # TODO probelm with angle \n                # x = np.sin(beta[iblade,ibeta]) * self.seg[iseg] + np.sin(beta[iblade,ibeta])*0.5*self.Lspan[iseg]  - np.cos(beta[iblade,ibeta])*0.5*self.chord[iseg]\n                # y = self.href + np.cos(beta[iblade,ibeta]) * self.seg[iseg] - np.cos(beta[iblade,ibeta])*0.5*self.Lspan[iseg]  - np.sin(beta[iblade,ibeta])*0.5*self.chord[iseg]\n                # height = self.Lspan[iseg]\n                # width = self.chord[iseg]\n                # angle = beta[iblade,ibeta]\n                # if ax1 is None : \n                #     plt.gca().add_patch(Rectangle((x, y), width,height, -angle*180/np.pi,\n                #     facecolor =color[proximity_temp[iseg,iblade]],\n                #     fill=True))\n                # else:\n                #     ax1.add_patch(Rectangle((x, y), width,height, -angle*180/np.pi,\n                #     facecolor =color[proximity_temp[iseg,iblade]],\n                #     fill=True))\n\n                #segment \n                if iseg == 0 :\n                        x0 = 0\n                        z0 = self.href\n                else :\n                    x0 =np.sin(beta[iblade,ibeta]) * self.seg[iseg-1]\n                    z0 = np.cos(beta[iblade,ibeta]) * self.seg[iseg-1] + self.href\n                x1 =np.sin(beta[iblade,ibeta]) * self.seg[iseg]\n                z1 = np.cos(beta[iblade,ibeta]) * self.seg[iseg] + self.href\n                if ax1 is None : \n                    plt.plot([x0,x1],[z0,z1],'-',linewidth = 5, color = color[proximity_temp[iseg,iblade]])\n                else :\n                    ax1.plot([x0,x1],[z0,z1],'-',linewidth = 5, color = color[proximity_temp[iseg,iblade]])\n\n\n        if ax1 is None :         \n            plt.gca().set_aspect('equal', adjustable='box')\n            plt.ylim(self.href -50,self.href + 50)\n            plt.xlim(-50,50) \n        else :\n            ax1.set_aspect('equal', adjustable='box')   \n            ax1.set_ylim(self.href -50,self.href + 50)\n            ax1.set_xlim(-50,50)\n\n    else :\n        for ibeta in range(self.Nbeta):\n            proximity_temp = proximity[:,ibeta].reshape(self.Nseg, self.Nblade)\n            plt.figure(ibeta)\n            for iblade in range(self.Nblade):\n                for iseg in range(self.Nseg) :\n                    if iseg == 0 :\n                        x0 = 0\n                        z0 = self.href\n                    else :\n                        x0 =np.sin(beta[iblade,ibeta]) * self.seg[iseg-1]\n                        z0 = np.cos(beta[iblade,ibeta]) * self.seg[iseg-1] + self.href\n                    x1 =np.sin(beta[iblade,ibeta]) * self.seg[iseg]\n                    z1 = np.cos(beta[iblade,ibeta]) * self.seg[iseg] + self.href\n\n\n                    plt.plot([x0,x1],[z0,z1],'-',linewidth = 5, color = color[proximity_temp[iseg,iblade]])\n            plt.gca().set_aspect('equal', adjustable='box')\n            plt.xlim(-50,50)\n            plt.ylim(self.href -50,self.href + 50)\n            plt.show()\n</code></pre>"},{"location":"reference/source/wind_turbine.html#src.prepost.source.wind_turbine.WindTurbine.createGeometry","title":"<code>createGeometry(seg, Lspan, c, twist, airfoilIndex, target_l_c=3.0, D=None)</code>","text":"<p>Create the geometry for the source model from aero geometry of a blade. The final blade respect the given target_lc_c ratio</p> <p>Parameters:</p> <ul> <li> <code>seg</code>               (<code>array</code>)           \u2013            <p>array of the center position of the segments</p> </li> <li> <code>Lspan</code>               (<code>array</code>)           \u2013            <p>array of teh span length of the segments</p> </li> <li> <code>c</code>               (<code>array</code>)           \u2013            <p>array of the chord length of the segments</p> </li> <li> <code>twist</code>               (<code>array</code>)           \u2013            <p>array of the twist of the segments</p> </li> <li> <code>airfoilIndex</code>               (<code>array</code>)           \u2013            <p>index of the airfoil to be used (coresponding to self.airfoilDataPath )</p> </li> <li> <code>target_l_c</code>               (<code>float</code>, default:                   <code>3.0</code> )           \u2013            <p>span/chord target ratio (to respect the incoherent source assumption). Defaults to 3.0.</p> </li> <li> <code>D</code>               (<code>float</code>, default:                   <code>None</code> )           \u2013            <p>new Diameter to resize the wind turbine. Defaults to None.</p> </li> </ul> Source code in <code>src/prepost/source/wind_turbine.py</code> <pre><code>def createGeometry(self,seg:np.array,Lspan:np.array,c:np.array,twist:np.array,airfoilIndex:np.array, target_l_c=3.0, D=None):\n    \"\"\"Create the geometry for the source model from aero geometry of a blade. The final blade respect the given target_lc_c ratio\n\n    Args:\n        seg (np.array): array of the center position of the segments\n        Lspan (np.array): array of teh span length of the segments\n        c (np.array): array of the chord length of the segments\n        twist (np.array): array of the twist of the segments\n        airfoilIndex (np.array): index of the airfoil to be used (coresponding to self.airfoilDataPath )\n        target_l_c (float, optional): span/chord target ratio (to respect the incoherent source assumption). Defaults to 3.0.\n        D (float, optional): new Diameter to resize the wind turbine. Defaults to None.\n    \"\"\"\n\n    # change diameter size \n    if D is not None : \n        originalDiameter = seg[-1] + 0.5*Lspan[-1]\n        seg = (0.5*D/originalDiameter) * seg\n        Lspan =  (0.5*D/originalDiameter) * Lspan\n        c = (0.5*D/originalDiameter) * c\n        logging.info('WT radius set to %s m' % (seg[-1] + 0.5*Lspan[-1]))\n    if target_l_c is None : \n        self.seg = seg\n        self.Lspan = Lspan \n        self.twist = twist\n        self.chord = c\n        self.airfoilIndex = airfoilIndex\n        return\n    # for interpolation of chord and twist \n    tck_c = interp.splrep(seg, c, k = 2)\n    tck_twist = interp.splrep(seg, twist, k = 2)\n\n    # init list for new geometry \n    new_seg = []\n    new_Lspan = []\n    new_twist = []\n    new_c = []\n    new_airfoilIndex = []\n\n    # init first segment \n    total_span = seg[0]- 0.5*Lspan[0]\n    current_span = 0 \n    current_seg = seg[0]- 0.5*Lspan[0]\n    current_c = float(interp.splev(current_seg, tck_c, der = 0))\n    delta_span = 0.1\n    # increase length until the end of the blade \n    while total_span &lt;= seg[-1]+0.5*Lspan[-1]:\n        # increase length of current segment until target is reach \n        if current_span / current_c &lt; target_l_c:\n            current_span += 2*delta_span\n            total_span += 2*delta_span\n            current_seg += delta_span \n            current_c = float(interp.splev(current_seg, tck_c, der = 0))\n        # interpolate and store new values for the segment \n        else:\n            new_seg.append(current_seg)\n            new_Lspan.append(current_span)\n            new_c.append(current_c)\n            new_twist.append(float(interp.splev(current_seg, tck_twist, der = 0)))\n            print(np.where(current_seg-seg-0.5*Lspan&lt;0)[0][0])\n            new_airfoilIndex.append(airfoilIndex[np.where(current_seg-seg-0.5*Lspan&lt;0)[0][0]])\n            # new_airfoilIndex.append(airfoilIndex[(np.abs(seg-current_seg)).argmin()])\n\n            # move the current segment position to the end of the segment \n            current_seg += 0.5*current_span\n            # reset curent span to 0\n            current_span = 0\n            # set current to twist according to segment position \n            current_c = float(interp.splev(current_seg, tck_c, der = 0))\n\n    # add something to reach final    D size \n    new_seg[-1] = new_seg[-1] + 0.5*current_span\n    new_Lspan[-1] = new_Lspan[-1] + current_span  \n    new_twist[-1] = float(interp.splev(new_seg[-1], tck_twist, der = 0))\n    new_c[-1] = float(interp.splev(new_seg[-1], tck_c, der = 0))\n\n    new_airfoilIndex[-1] = airfoilIndex[(np.abs(seg-current_seg)).argmin()]\n\n    self.seg = np.array(new_seg)\n    self.Lspan = np.array(new_Lspan)\n    self.twist = np.array(new_twist)\n    self.chord = np.array(new_c)\n    self.airfoilIndex = np.array(new_airfoilIndex)\n    return\n</code></pre>"},{"location":"reference/source/wind_turbine.html#src.prepost.source.wind_turbine.WindTurbine.createBLData","title":"<code>createBLData(AoA, reynolds, fname)</code>","text":"<p>create the BL quantites data base for the given blade, AoA and re</p> <p>Parameters:</p> <ul> <li> <code>AoA</code>               (<code>ndarray</code>)           \u2013            <p>Angle of attack array to compute for the DB</p> </li> <li> <code>reynolds</code>               (<code>ndarray</code>)           \u2013            <p>Re numbers to compute for the DB</p> </li> <li> <code>fname</code>               (<code>str</code>)           \u2013            <p>file name to save the BL quantities</p> </li> </ul> Source code in <code>src/prepost/source/wind_turbine.py</code> <pre><code>def createBLData(self,AoA:np.ndarray,reynolds:np.ndarray,fname:str):\n    \"\"\"create the BL quantites data base for the given blade, AoA and re\n\n    Args:\n        AoA (np.ndarray): Angle of attack array to compute for the DB\n        reynolds (np.ndarray): Re numbers to compute for the DB\n        fname (str): file name to save the BL quantities\n    \"\"\"\n\n    # Init BL array\n    delta_star_bot = np.zeros((reynolds.shape[0], AoA.shape[0], self.chord.shape[0]))\n    theta_momen_bot = np.zeros((reynolds.shape[0], AoA.shape[0], self.chord.shape[0]))\n    cf_bot = np.zeros((reynolds.shape[0], AoA.shape[0], self.chord.shape[0]))\n    dpdx_bot = np.zeros((reynolds.shape[0], AoA.shape[0], self.chord.shape[0]))\n    UeUinf_bot = np.zeros((reynolds.shape[0], AoA.shape[0], self.chord.shape[0]))\n\n    delta_star_top = np.zeros((reynolds.shape[0], AoA.shape[0], self.chord.shape[0]))\n    theta_momen_top = np.zeros((reynolds.shape[0], AoA.shape[0], self.chord.shape[0]))\n    cf_top = np.zeros((reynolds.shape[0], AoA.shape[0], self.chord.shape[0]))\n    dpdx_top = np.zeros((reynolds.shape[0], AoA.shape[0], self.chord.shape[0]))\n    UeUinf_top = np.zeros((reynolds.shape[0], AoA.shape[0], self.chord.shape[0]))\n\n    foil = {}\n    # airfoil geometry\n\n    # no artificial  trip\n    foil['trip_top'] = 1.0\n    foil['trip_bottom'] = 1.0\n\n    # percent of chord length\n    # should be 95 :'(  but does the flow detached \n    target_frac = 0.85\n\n    # out_dict = XFOIL(path, target_frac, inf, foil)\n    # run virtual buffer server before xfoil calculation\n    run_Xvfb()\n\n    inf = {}\n    inf['rho'] = 1.225\n    inf['nu'] = 1.48e-5\n    inf['T'] = 300\n    # loop over the parameters of the dB\n    for temp3 in range(self.chord.shape[0]):\n        for temp2 in range(AoA.shape[0]):\n            for temp1 in range(reynolds.shape[0]):\n                print(self.airfoilIndex[temp3])\n                print(self.airfoilDataName)\n                print(self.airfoilDataName[self.airfoilIndex[temp3]])\n                # create the input dictionnary for Xfoil\n                foil['name'] = self.pathToAirfoilGeom + self.airfoilDataName[self.airfoilIndex[temp3]] + '.dat'\n                foil['chord'] = self.chord[temp3]\n                foil['span'] = self.Lspan[temp3]\n                foil['AoA'] = AoA[temp2]\n                foil['re'] = reynolds[temp1]\n                inf_velocity = foil['re'] * inf['nu'] / foil['chord']\n                foil['mach'] = inf_velocity / (1.4 * 287 * inf['T']) ** 0.5\n                inf['mach'] = foil['mach']\n                # run Xfoil to obtain the BL quantities \n                out_dict = XFOIL('./metadata/' , target_frac, inf, foil)\n\n                delta_star_top[temp1, temp2, temp3] = out_dict['Dstar_suction']\n                theta_momen_top[temp1, temp2, temp3] = out_dict['theta_suction']\n                cf_top[temp1, temp2, temp3] = out_dict['Cf_suction']\n                dpdx_top[temp1, temp2, temp3] = out_dict['dpdx_suction']\n                UeUinf_top[temp1, temp2, temp3] = out_dict['Ue_suction']\n\n                delta_star_bot[temp1, temp2, temp3] = out_dict['Dstar_pressure']\n                theta_momen_bot[temp1, temp2, temp3] = out_dict['theta_pressure']\n                cf_bot[temp1, temp2, temp3] = out_dict['Cf_pressure']\n                dpdx_bot[temp1, temp2, temp3] = out_dict['dpdx_pressure']\n                UeUinf_bot[temp1, temp2, temp3] = out_dict['Ue_pressure']\n        file_name = './metadata/' + str(temp3) + '.dat'\n        outfile = open(file_name, mode = 'w')\n        outfile.write('Data generation has started!!!\\n')\n        outfile.write(str(self.chord[temp3]) + 'm has been completed')\n        outfile.close()\n\n    # kill the virtual frame buffer\n    kill_Xvfb()\n\n    # save the data base\n    print(\"saving the data Base\")\n    print(AoA.shape)\n    print(reynolds.shape)\n    print(delta_star_bot.shape)\n\n    airfoil_data = {}\n    airfoil_data['AoA'] = AoA\n    airfoil_data['reynolds'] = reynolds\n    airfoil_data['chord'] = self.chord\n    airfoil_data['Lspan'] = self.Lspan\n    airfoil_data['seg'] = self.seg\n    airfoil_data['twist'] = self.twist\n    airfoil_data['airfoildIndex'] = self.airfoilIndex\n    airfoil_data['airfoilDataName'] = self.airfoilDataName\n\n\n    airfoil_data['delta_star_bot'] = delta_star_bot\n    airfoil_data['delta_star_top'] = delta_star_top\n    airfoil_data['cf_bot'] = cf_bot\n    airfoil_data['cf_top'] = cf_top\n    airfoil_data['dpdx_bot'] = dpdx_bot\n    airfoil_data['dpdx_top'] = dpdx_top\n    airfoil_data['theta_momen_bot'] = theta_momen_bot\n    airfoil_data['theta_momen_top'] = theta_momen_top\n    airfoil_data['UeUinf_bot'] = UeUinf_bot\n    airfoil_data['UeUinf_top'] = UeUinf_top\n\n    pickle.dump(airfoil_data,  open(fname, 'wb'))\n</code></pre>"},{"location":"reference/source/wind_turbine.html#src.prepost.source.wind_turbine.WindTurbine.createBLData2","title":"<code>createBLData2(AoA, reynolds, fname)</code>","text":"<p>create the BL quantites data base for the given blade, AoA and re also compute Cl and Cd (for BEM implementation) NOT CHECKED YET </p> <p>Parameters:</p> <ul> <li> <code>AoA</code>               (<code>ndarray</code>)           \u2013            <p>Angle of attack array to compute for the DB</p> </li> <li> <code>reynolds</code>               (<code>ndarray</code>)           \u2013            <p>Re numbers to compute for the DB</p> </li> <li> <code>fname</code>               (<code>str</code>)           \u2013            <p>file name to save the BL quantities</p> </li> </ul> Source code in <code>src/prepost/source/wind_turbine.py</code> <pre><code>def createBLData2(self,AoA:np.ndarray,reynolds:np.ndarray,fname:str):\n    \"\"\"create the BL quantites data base for the given blade, AoA and re\n    also compute Cl and Cd (for BEM implementation)\n    NOT CHECKED YET \n\n    Args:\n        AoA (np.ndarray): Angle of attack array to compute for the DB\n        reynolds (np.ndarray): Re numbers to compute for the DB\n        fname (str): file name to save the BL quantities\n    \"\"\"\n    delta_star_bot = np.zeros((reynolds.shape[0], AoA.shape[0], self.chord.shape[0]))\n    theta_momen_bot = np.zeros((reynolds.shape[0], AoA.shape[0], self.chord.shape[0]))\n    cf_bot = np.zeros((reynolds.shape[0], AoA.shape[0], self.chord.shape[0]))\n    dpdx_bot = np.zeros((reynolds.shape[0], AoA.shape[0], self.chord.shape[0]))\n    UeUinf_bot = np.zeros((reynolds.shape[0], AoA.shape[0], self.chord.shape[0]))\n\n    delta_star_top = np.zeros((reynolds.shape[0], AoA.shape[0], self.chord.shape[0]))\n    theta_momen_top = np.zeros((reynolds.shape[0], AoA.shape[0], self.chord.shape[0]))\n    cf_top = np.zeros((reynolds.shape[0], AoA.shape[0], self.chord.shape[0]))\n    dpdx_top = np.zeros((reynolds.shape[0], AoA.shape[0], self.chord.shape[0]))\n    UeUinf_top = np.zeros((reynolds.shape[0], AoA.shape[0], self.chord.shape[0]))\n    Cl = np.zeros((reynolds.shape[0], AoA.shape[0], self.chord.shape[0]))\n    Cd = np.zeros((reynolds.shape[0], AoA.shape[0], self.chord.shape[0]))\n    Cl_tck = []\n    Cd_tck = []\n    foil = {}\n    # no artificial  trip\n    foil['trip_top'] = 0.05 #1.0\n    foil['trip_bottom'] = 0.05 #1.0\n    # percent of chord length\n    target_frac = 0.95\n\n    # run virtual buffer server before xfoil calculation\n    run_Xvfb()\n\n    inf = {}\n    inf['rho'] = 1.2\n    inf['nu'] = 1.48e-5\n    # inf['nu'] = 1.62e-5\n    inf['T'] = 273+20 \n    # loop over the parameters of the dB (segments, reynolds, AoA) \n    for temp3 in range(self.chord.shape[0]):\n        # change input \n        foil['name'] = self.pathToAirfoilGeom + self.airfoilDataName[self.airfoilIndex[temp3]] + '.dat'\n        foil['chord'] = self.chord[temp3]\n        foil['span'] = self.Lspan[temp3]\n        for temp1 in range(reynolds.shape[0]):\n            # foil['re'] = reynolds[temp1]\n            # modif after B cott\u00e9 reunion Re diff\u00e9rent de Rc\n            foil['re'] = reynolds[temp1]/foil['chord']\n            inf_velocity = reynolds[temp1] * inf['nu'] / foil['chord']\n            foil['mach'] = inf_velocity / (1.4 * 287 * inf['T']) ** 0.5\n            inf['mach'] = foil['mach']\n\n            for temp2 in range(AoA.shape[0]):\n                print(self.airfoilIndex[temp3])\n                print(self.airfoilDataName)\n                print(self.airfoilDataName[self.airfoilIndex[temp3]])\n                foil['AoA'] = AoA[temp2]\n                out_dict,polar = XFOIL('./metadata/' , target_frac, inf, foil)\n                # this is a hard coded shit in case XFOIl does converge for the given AoA \n                # it whil decrease slightly until it converges \n                cont = 0\n                print(polar.size)\n\n                if polar.size ==0:\n                    while polar.size == 0 and cont&lt;10:\n                        print(foil['AoA'])\n                        foil['AoA'] = foil['AoA'] - 0.05\n                        out_dict,polar = XFOIL('./metadata/' , target_frac, inf, foil)\n                        cont+=1\n\n                    print(AoA[temp2])\n                    print(cont)                        \n                    print(foil['AoA'])\n                    time.sleep(5)\n                if polar.size == 0:\n                    print(\"seg No %s\"%temp3)\n                    print(\"Re = %s\"%reynolds[temp1])\n                    print(\"AoA = %s\"%AoA[temp2])\n                    print(\"error to big cant converge problem \")\n                    quit()\n                delta_star_top[temp1, temp2, temp3] = out_dict['Dstar_suction']\n                theta_momen_top[temp1, temp2, temp3] = out_dict['theta_suction']\n                cf_top[temp1, temp2, temp3] = out_dict['Cf_suction']\n                dpdx_top[temp1, temp2, temp3] = out_dict['dpdx_suction']\n                UeUinf_top[temp1, temp2, temp3] = out_dict['Ue_suction']\n\n                delta_star_bot[temp1, temp2, temp3] = out_dict['Dstar_pressure']\n                theta_momen_bot[temp1, temp2, temp3] = out_dict['theta_pressure']\n                cf_bot[temp1, temp2, temp3] = out_dict['Cf_pressure']\n                dpdx_bot[temp1, temp2, temp3] = out_dict['dpdx_pressure']\n                UeUinf_bot[temp1, temp2, temp3] = out_dict['Ue_pressure'] \n\n                Cl[temp1,temp2,temp3] = polar[1]\n                Cd[temp1,temp2,temp3] = polar[2]\n        print(polar[1])\n        print(polar[2])\n        print(Cl.shape)\n        print(Cd.shape)\n\n\n        # time.sleep(5.5) \n        R,A = np.meshgrid(reynolds,AoA,indexing='ij')\n        # print(R)\n        # print(A)\n\n        # print(Cd)\n        Cl_tck.append(interp.bisplrep(R,A,Cl[:,:,temp3]))\n        Cd_tck.append(interp.bisplrep(R,A,Cd[:,:,temp3]))\n\n\n        file_name = './metadata/' + str(temp3) + '.dat'\n        outfile = open(file_name, mode = 'w')\n        outfile.write('Data generation has started!!!\\n')\n        outfile.write(str(self.chord[temp3]) + 'm has been completed')\n        outfile.close()\n\n    # kill the virtual frame buffer\n    kill_Xvfb()\n\n    # save the data base\n    print(\"saving the data Base\")\n    print(AoA.shape)\n    print(reynolds.shape)\n    print(delta_star_bot.shape)\n\n\n    self.airfoil_data = {}\n    self.airfoil_data['AoA'] = AoA\n    self.airfoil_data['reynolds'] = reynolds\n    self.airfoil_data['chord'] = self.chord\n    self.airfoil_data['Lspan'] = self.Lspan\n    self.airfoil_data['seg'] = self.seg\n    self.airfoil_data['twist'] = self.twist\n    self.airfoil_data['airfoildIndex'] = self.airfoilIndex\n    self.airfoil_data['airfoilDataName'] = self.airfoilDataName\n\n\n    self.airfoil_data['delta_star_bot'] = delta_star_bot\n    self.airfoil_data['delta_star_top'] = delta_star_top\n    self.airfoil_data['cf_bot'] = cf_bot\n    self.airfoil_data['cf_top'] = cf_top\n    self.airfoil_data['Cl'] = Cl\n    self.airfoil_data['Cd'] = Cd\n    self.airfoil_data['Cl_tck'] = Cl_tck\n    self.airfoil_data['Cd_tck'] = Cd_tck\n    self.airfoil_data['dpdx_bot'] = dpdx_bot\n    self.airfoil_data['dpdx_top'] = dpdx_top\n    self.airfoil_data['theta_momen_bot'] = theta_momen_bot\n    self.airfoil_data['theta_momen_top'] = theta_momen_top\n    self.airfoil_data['UeUinf_bot'] = UeUinf_bot\n    self.airfoil_data['UeUinf_top'] = UeUinf_top\n\n    pickle.dump(self.airfoil_data,  open(fname, 'wb'))\n</code></pre>"},{"location":"reference/source/wind_turbine.html#src.prepost.source.wind_turbine.WindTurbine.readBladeData","title":"<code>readBladeData(fname)</code>","text":"<p>read the BL data from file, set the seg, twist, chord and span accordingly</p> <p>Parameters:</p> <ul> <li> <code>fname</code>               (<code>str</code>)           \u2013            <p>path to the BL file</p> </li> </ul> Source code in <code>src/prepost/source/wind_turbine.py</code> <pre><code>def readBladeData(self, fname:str):\n    \"\"\"read the BL data from file, set the seg, twist, chord and span accordingly\n\n    Args:\n        fname (str): path to the BL file\n    \"\"\"\n    self.airfoil_data = pickle.load(open(fname, 'rb'))\n    self.chord = self.airfoil_data['chord']\n    self.Lspan = self.airfoil_data['Lspan']\n    self.seg = self.airfoil_data['seg']\n    self.twist = self.airfoil_data['twist']\n    self.airfoilIndex = self.airfoil_data['airfoildIndex']\n    self.airfoilDataname = self.airfoil_data['airfoilDataName']\n    self.Nseg = len(self.chord)\n</code></pre>"},{"location":"reference/source/wind_turbine.html#src.prepost.source.wind_turbine.WindTurbine.controlRotSpeed","title":"<code>controlRotSpeed(Uref, omega=None)</code>","text":"<p>set omega according to Uref from NREL documentation</p> <p>Parameters:</p> <ul> <li> <code>Uref</code>               (<code>float</code>)           \u2013            <p>reference wind speed (usually taken at hub height)</p> </li> <li> <code>omega</code>               (<code>float</code>, default:                   <code>None</code> )           \u2013            <p>if set, forces omega to the given value. Defaults to None.</p> </li> </ul> Source code in <code>src/prepost/source/wind_turbine.py</code> <pre><code>def controlRotSpeed(self, Uref:float, omega:float=None):\n    \"\"\"set omega according to Uref from NREL documentation\n\n    Args:\n        Uref (float): reference wind speed (usually taken at hub height)\n        omega (float, optional): if set, forces omega to the given value. Defaults to None.\n    \"\"\"\n    # from Nrel decsription \n    cutin=3; rated=11.4; cutOut=25\n    cutin_ratio = 6.9; rated_ratio = 12.1\n\n    U =  np.array([3.0760869565217392,\n    4.315217391304348,\n        5.016304347826087,\n    6.010869565217392,\n    7.478260869565218,\n    8.994565217391305,\n    9.711956521739129,\n    10.413043478260871,\n    11.032608695652172,\n    11.4,\n    12.23913043478261,\n    13.021739130434781,\n    14.815217391304348,\n    16.934782608695652,\n    19.46195652173913,\n    24.95652173913043])\n\n    omega_rpm = np.array([ 6.96319018404909,\n    7.208588957055213,\n    7.453987730061357,\n    7.944785276073617,\n    8.680981595092028,\n    10.235173824130882,\n    11.053169734151332,\n    11.625766871165645,\n    11.871165644171782,\n    12.1,\n    12.1,\n    12.1,\n    12.1,\n    12.1,\n    12.1,\n    12.1])\n\n    omega_tck = interp.splrep(U, omega_rpm, k=2)\n\n    if omega is None:\n        # self.omega = (omega_rpm[np.argmin(np.abs(Uref-U))]) * 2*np.pi/60\n        self.omega = interp.splev(Uref, omega_tck) * 2*np.pi/60\n\n        print('Omega set to :' +str( self.omega * 60/(2*np.pi)) + ' rpm')\n    else:\n        self.omega = omega\n</code></pre>"},{"location":"reference/source/wind_turbine.html#src.prepost.source.wind_turbine.WindTurbine.controlPitchAngle","title":"<code>controlPitchAngle(Uref, pitch=None)</code>","text":"<p>set pitcch angle with respect to Uref according to Nrel documentation</p> <p>Parameters:</p> <ul> <li> <code>Uref</code>               (<code>float</code>)           \u2013            <p>reference wind speed (usually taken at hub height)</p> </li> <li> <code>pitch</code>               (<code>float</code>, default:                   <code>None</code> )           \u2013            <p>if set, forces th pitch angle to the given value. Defaults to None.</p> </li> </ul> Source code in <code>src/prepost/source/wind_turbine.py</code> <pre><code>def controlPitchAngle(self,Uref:float,pitch:float=None):\n    \"\"\"set pitcch angle with respect to Uref according to Nrel documentation\n\n    Args:\n        Uref (float): reference wind speed (usually taken at hub height)\n        pitch (float, optional): if set, forces th pitch angle to the given value. Defaults to None.\n    \"\"\"\n    # from NREL calculation for a unifrom wind speed \n    # pitch_array = np.array([0,3.8,6.6,8.7,10.4,12,13.5,14.9,16.2,17.4,18.7,19.9,21.18,22.35,23.47])\n    # U = np.array([11.4,12,13,14,15,16,17,18,19,20,21,22,23,24,25])\n\n    U = np.array([3.0271739130434785,\n        9.01086956521739,\n        11.309782608695652,\n        11.456521739130434,\n        12.02717391304348,\n        13.005434782608695,\n        14,\n        15.98913043478261,\n        17,\n        17.994565217391305,\n        19.005434782608695,\n        19.983695652173914,\n        20.994565217391305,\n        21.989130434782606,\n        23.016304347826086,\n        23.9945652173913,\n        24.97282608695652])\n    pitch_array = np.array([ 0,\n                    0,\n                    0,\n                    0.9918200408998032,\n                    3.7730061349693287,\n                    6.635991820040907,\n                    8.517382413087937,\n                    12.034764826175874,\n                    13.425357873210636,\n                    14.897750511247445,\n                    16.20654396728017,\n                    17.43353783231084,\n                    18.742331288343564,\n                    19.969325153374236,\n                    21.11451942740286,\n                    22.259713701431494,\n                    23.48670756646217])\n    if pitch is None:\n        alpha = 1\n        self.twist = self.twist - alpha * np.pi/180 * (pitch_array[np.argmin(np.abs(Uref-U))])\n        print(' wind turbine blade pitched : ' + str(pitch_array[np.argmin(np.abs(Uref-U))]) + 'deg')\n    else:\n        self.twist = self.twist - np.pi/180 * pitch\n</code></pre>"},{"location":"reference/source/wind_turbine.html#src.prepost.source.wind_turbine.WindTurbine.save","title":"<code>save(fname)</code>","text":"<p>save class as self.name.dat</p> Source code in <code>src/prepost/source/wind_turbine.py</code> <pre><code>def save(self, fname: str):\n    \"\"\"save class as self.name.dat\"\"\"\n    with open(fname, 'wb') as file:\n        pickle.dump(self.__dict__, file)\n</code></pre>"},{"location":"reference/source/wind_turbine.html#src.prepost.source.wind_turbine.WindTurbine.load","title":"<code>load(fname)</code>","text":"<p>try load self.name.dat</p> Source code in <code>src/prepost/source/wind_turbine.py</code> <pre><code>def load(self, fname: str):\n    \"\"\"try load self.name.dat\"\"\"\n    with open(fname, 'rb') as file:\n        self.__dict__ = pickle.load(file)\n</code></pre>"}]}